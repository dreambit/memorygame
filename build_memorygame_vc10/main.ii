# 1 "c:/Users/dreambit/Documents/memorygame/src/main.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "c:/Users/dreambit/Documents/memorygame/build_memorygame_vc10/temp_defines_release.h" 1
# 1 "<command-line>" 2
# 1 "c:/Users/dreambit/Documents/memorygame/src/main.cpp"
# 1 "d:/marmalade/6.1/s3e/h/s3e.h" 1
# 19 "d:/marmalade/6.1/s3e/h/s3e.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eAccelerometer.h" 1
# 15 "d:/marmalade/6.1/s3e/h/s3eAccelerometer.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eTypes.h" 1
# 35 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
typedef unsigned char s3e_uint8_t;
typedef signed char s3e_int8_t;
typedef unsigned short int s3e_uint16_t;
typedef signed short int s3e_int16_t;
typedef unsigned int s3e_uint32_t;
typedef signed int s3e_int32_t;
# 49 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
  typedef signed long long s3e_int64_t;
  typedef unsigned long long s3e_uint64_t;
# 72 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
typedef s3e_uint64_t uint64_t;
typedef s3e_int64_t int64_t;
typedef s3e_uint32_t uint32_t;
typedef s3e_int32_t int32_t;
typedef s3e_uint16_t uint16_t;
typedef s3e_int16_t int16_t;
typedef s3e_uint8_t uint8_t;
typedef s3e_int8_t int8_t;
# 94 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
    typedef int intptr_t;
    typedef unsigned int uintptr_t;
# 106 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
typedef unsigned int uint;
typedef unsigned short int ushort;
typedef unsigned long int ulong;
typedef unsigned char uint8;
typedef signed char int8;







typedef int64_t int64;
typedef uint64_t uint64;





typedef unsigned int uint32;






typedef signed int int32;






typedef uint16_t uint16;




typedef int16_t int16;
# 224 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
typedef enum s3eResult
{
    S3E_RESULT_SUCCESS = 0,
    S3E_RESULT_ERROR = 1
} s3eResult;




typedef uint8 s3eBool;
# 242 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
typedef wchar_t s3eWChar;
# 254 "d:/marmalade/6.1/s3e/h/s3eTypes.h"
typedef int32 (*s3eCallback) (void* systemData, void* userData);
# 16 "d:/marmalade/6.1/s3e/h/s3eAccelerometer.h" 2
# 64 "d:/marmalade/6.1/s3e/h/s3eAccelerometer.h"
typedef enum s3eAccelerometerError
{
    S3E_ACCELEROMETER_ERR_NONE = 0,
    S3E_ACCELEROMETER_ERR_PARAM = 1,
    S3E_ACCELEROMETER_ERR_UNAVAIL = 5
} s3eAccelerometerError;







extern "C" s3eAccelerometerError s3eAccelerometerGetError();
# 86 "d:/marmalade/6.1/s3e/h/s3eAccelerometer.h"
extern "C" const char* s3eAccelerometerGetErrorString();






typedef enum s3eAccelerometerProperty
{
    S3E_ACCELEROMETER_AVAILABLE = 0
} s3eAccelerometerProperty;

extern "C" int32 s3eAccelerometerGetInt(s3eAccelerometerProperty property);
# 108 "d:/marmalade/6.1/s3e/h/s3eAccelerometer.h"
extern "C" s3eResult s3eAccelerometerStart();







extern "C" void s3eAccelerometerStop();






extern "C" int32 s3eAccelerometerGetX();






extern "C" int32 s3eAccelerometerGetY();






extern "C" int32 s3eAccelerometerGetZ();
# 20 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eAudio.h" 1
# 59 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
typedef enum s3eAudioCodec
{
    S3E_AUDIO_CODEC_MIDI = 1,
    S3E_AUDIO_CODEC_MP3 = 2,
    S3E_AUDIO_CODEC_AAC = 3,
    S3E_AUDIO_CODEC_AACPLUS = 4,
    S3E_AUDIO_CODEC_QCP = 5,
    S3E_AUDIO_CODEC_PCM = 6,
    S3E_AUDIO_CODEC_SPF = 7,
    S3E_AUDIO_CODEC_AMR = 8,
    S3E_AUDIO_CODEC_MP4 = 9
} s3eAudioCodec;






typedef enum s3eAudioStatus
{





    S3E_AUDIO_STOPPED = 0,




    S3E_AUDIO_PLAYING = 1,




    S3E_AUDIO_PAUSED = 2,
# 103 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
    S3E_AUDIO_FAILED = 3
} s3eAudioStatus;
# 113 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
typedef enum s3eAudioProperty
{





    S3E_AUDIO_VOLUME = 0,





    S3E_AUDIO_STATUS = 1,





    S3E_AUDIO_POSITION = 2,
# 145 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
    S3E_AUDIO_VOLUME_DEFAULT = 3,





    S3E_AUDIO_CHANNEL = 4,





    S3E_AUDIO_NUM_CHANNELS = 5,

    S3E_AUDIO_AVAILABLE = 6,







    S3E_AUDIO_MUTES_S3ESOUND = 7,






    S3E_AUDIO_DURATION = 8,






    S3E_AUDIO_PLAYBACK_FROM_HTTP_AVAILABLE = 9
} s3eAudioProperty;
# 199 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" int32 s3eAudioGetInt(s3eAudioProperty property);
# 219 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioSetInt(s3eAudioProperty property, int32 value);
# 229 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
typedef enum s3eAudioCallback
{
# 246 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
    S3E_AUDIO_STOP = 2,

    S3E_AUDIO_CALLBACK_MAX
} s3eAudioCallback;






typedef struct s3eAudioCallbackData
{

    uint32 m_ChannelID;
} s3eAudioCallbackData;
# 281 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioRegister(s3eAudioCallback cbid, s3eCallback fn, void* userData);
# 297 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioUnRegister(s3eAudioCallback cbid, s3eCallback fn);
# 306 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
typedef enum s3eAudioError
{
    S3E_AUDIO_ERR_NONE = 0,
    S3E_AUDIO_ERR_PARAM = 1,
    S3E_AUDIO_ERR_TOO_MANY = 2,
    S3E_AUDIO_ERR_ALREADY_REG = 3,
    S3E_AUDIO_ERR_NOT_FOUND = 4,
    S3E_AUDIO_ERR_UNAVAIL = 5,
    S3E_AUDIO_ERR_DEVICE = 6,
    S3E_AUDIO_ERR_UNSUPPORTED = 7,
    S3E_AUDIO_ERR_MEM = 8,
    S3E_AUDIO_ERR_INVALID_DRIVE = 10,
    S3E_AUDIO_ERR_INVALID_PATH = 11,
    S3E_AUDIO_ERR_FILEFORMAT = 1000,
    S3E_AUDIO_ERR_WRONG_STATE = 1001
} s3eAudioError;
# 335 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eAudioError s3eAudioGetError();
# 349 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" const char* s3eAudioGetErrorString();
# 423 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioPlay(const char* filename, uint32 repeatCount =1);
# 494 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioPlayFromBuffer(void* buffer, uint32 bufferLen, uint32 repeatCount =0);
# 519 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioPause();
# 538 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eResult s3eAudioResume();
# 552 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" void s3eAudioStop();
# 563 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eBool s3eAudioIsPlaying();
# 577 "d:/marmalade/6.1/s3e/h/s3eAudio.h"
extern "C" s3eBool s3eAudioIsCodecSupported(s3eAudioCodec codec);





# 1 "d:/marmalade/6.1/s3e/h/legacy/s3eAudio_legacy.h" 1
# 584 "d:/marmalade/6.1/s3e/h/s3eAudio.h" 2
# 21 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eCompression.h" 1
# 33 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
typedef enum s3eCompressionAlgorithms
{
    S3E_COMPRESSION_ALG_AUTO = 0,
    S3E_COMPRESSION_ALG_NONE = 1,







    S3E_COMPRESSION_ALG_ZLIB = 2,







    S3E_COMPRESSION_ALG_GZIP = 3,





    S3E_COMPRESSION_ALG_LZMA = 4,

    S3E_COMPRESSION_ALG_MAX
} s3eCompressionAlgorithms;






typedef enum s3eCompressionError
{
    S3E_COMPRESSION_ERR_NONE = 0,
    S3E_COMPRESSION_ERR_PARAM = 1,
    S3E_COMPRESSION_ERR_TOO_MANY = 2,
    S3E_COMPRESSION_ERR_DEVICE = 6,
    S3E_COMPRESSION_ERR_MEM = 8,

    S3E_COMPRESSION_ERR_BAD_DATA = 1000,
    S3E_COMPRESSION_ERR_INSUFF = 1002
} s3eCompressionError;





typedef struct s3eDecompressionHandle s3eDecompressionHandle;
# 95 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
typedef struct s3eDecompressionInput
{

    void* m_Data;

    int32 m_Size;
} s3eDecompressionInput;
# 137 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
extern "C" s3eDecompressionHandle* s3eCompressionDecompInit(s3eCompressionAlgorithms alg, s3eCallback inputFn, void* userData);
# 190 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
extern "C" s3eResult s3eCompressionDecompRead(s3eDecompressionHandle* handle, void* bufferOut, uint32* lenOut);
# 210 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
extern "C" s3eResult s3eCompressionDecompFinal(s3eDecompressionHandle* handle);
# 260 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
extern "C" s3eResult s3eCompressionDecomp(void* bufferIn, uint32 lenIn, void** bufferOut, uint32 *lenOut, s3eCompressionAlgorithms algorithm);
# 273 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
extern "C" s3eCompressionError s3eCompressionGetError();
# 286 "d:/marmalade/6.1/s3e/h/s3eCompression.h"
extern "C" const char* s3eCompressionGetErrorString();
# 22 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eConfig.h" 1
# 16 "d:/marmalade/6.1/s3e/h/s3eConfig.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eFile.h" 1
# 33 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef struct s3eFile s3eFile;
# 58 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef enum s3eFileSeekOrigin
{
    S3E_FILESEEK_SET = 0,
    S3E_FILESEEK_CUR = 1,
    S3E_FILESEEK_END = 2
} s3eFileSeekOrigin;




typedef struct s3eFileList s3eFileList;
# 89 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef enum s3eFileProperty
{






    S3E_FILE_ROM_EXISTS = 1,





    S3E_FILE_BYTES_TOTAL = 2,




    S3E_FILE_BYTES_FREE = 3
} s3eFileProperty;
# 119 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef enum s3eFileStats
{







    S3E_FILE_ISFILE = 0,







    S3E_FILE_ISDIR = 1,






    S3E_FILE_ISUSER = 2,
# 156 "d:/marmalade/6.1/s3e/h/s3eFile.h"
    S3E_FILE_ISWRITABLE = 3,





    S3E_FILE_SIZE = 4,
# 172 "d:/marmalade/6.1/s3e/h/s3eFile.h"
    S3E_FILE_MODIFIED_DATE = 5,
# 184 "d:/marmalade/6.1/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_FREE = 6,
# 193 "d:/marmalade/6.1/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE = 7,
# 202 "d:/marmalade/6.1/s3e/h/s3eFile.h"
    S3E_FILE_DRIVE_BYTES_TOTAL = 8,






    S3E_FILE_REAL_PATH = 9,
} s3eFileStats;
# 228 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetInt(s3eFileProperty property);
# 253 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" int64 s3eFileGetFileInt(const char* filename, s3eFileStats stat);
# 278 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" char* s3eFileGetFileString(const char* filename, s3eFileStats stat, char* str, int len);
# 287 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef enum s3eFileError
{
    S3E_FILE_ERR_NONE = 0,
    S3E_FILE_ERR_PARAM = 1,
    S3E_FILE_ERR_TOO_MANY = 2,
    S3E_FILE_ERR_ALREADY_REG = 3,
    S3E_FILE_ERR_NOT_FOUND = 4,
    S3E_FILE_ERR_UNAVAIL = 5,
    S3E_FILE_ERR_DEVICE = 6,
    S3E_FILE_ERR_UNSUPPORTED = 7,
    S3E_FILE_ERR_MEM = 8,
    S3E_FILE_ERR_GENERIC = 9,
    S3E_FILE_ERR_INVALID_DRIVE = 10,
    S3E_FILE_ERR_INVALID_PATH = 11,
    S3E_FILE_ERR_DATA = 12,

    S3E_FILE_ERR_INVALID_MODE = 1000,
    S3E_FILE_ERR_EXISTS = 1001,
    S3E_FILE_ERR_NOT_EMPTY = 1002,
    S3E_FILE_ERR_ACCESS = 1003,
    S3E_FILE_ERR_NO_MORE = 1004,
    S3E_FILE_ERR_EOF = 1005
} s3eFileError;
# 322 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eFileError s3eFileGetError();
# 336 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" const char* s3eFileGetErrorString();
# 387 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpen(const char* filename, const char* mode);
# 406 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eFile* s3eFileOpenFromMemory(void* buffer, uint32 bufferLen);
# 423 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileClose(s3eFile* file);
# 444 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileFlush(s3eFile* file);
# 475 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" uint32 s3eFileRead(void* buffer, uint32 elemSize, uint32 noElems, s3eFile* file);
# 502 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" uint32 s3eFileWrite(const void* buffer, uint32 elemSize, uint32 noElems, s3eFile* file);
# 516 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" int s3eFilePrintf(s3eFile* f, const char *fmt, ...);
# 536 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetChar(s3eFile* file);
# 559 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" int32 s3eFilePutChar(char c, s3eFile* file);
# 597 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" char* s3eFileReadString(char* string, uint32 maxLen, s3eFile* file);
# 620 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileEOF(s3eFile* file);
# 655 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileSeek(s3eFile* file, int32 offset, s3eFileSeekOrigin origin);
# 671 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" int32 s3eFileTell(s3eFile* file);
# 688 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" int32 s3eFileGetSize(s3eFile* file);
# 714 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileMakeDirectory(const char* dirName);
# 739 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDeleteDirectory(const char* dirName);
# 755 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eBool s3eFileCheckExists(const char* filename);
# 789 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRename(const char* src, const char* dest);
# 814 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileDelete(const char* filename);
# 842 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileTruncate(const char* filename, uint32 length);
# 852 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" uint64 s3eFileGetLastWriteTime(const char* filename);
# 881 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eFileList* s3eFileListDirectory(const char* dirName);
# 903 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListNext(s3eFileList* handle, char* filename, int filenameLen);
# 918 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileListClose(s3eFileList* handle);







typedef struct s3eUsrFile s3eUsrFile;
# 936 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eUsrFile*(*s3eUserOpenFn)(const char* filename, const char *mode);
# 948 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef uint32 (*s3eUserReadFn)(void* buffer, uint32 elemLen, uint32 noElems, s3eUsrFile *file);
# 960 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef uint32 (*s3eUserWriteFn)(const void* buffer, uint32 elemLen, uint32 noElems, s3eUsrFile *file);
# 969 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eBool (*s3eUserEOFFn)(s3eUsrFile* file);
# 980 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserSeekFn)(s3eUsrFile* file, int32 offset, s3eFileSeekOrigin origin);
# 989 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef int32 (*s3eUserTellFn)(s3eUsrFile* file);
# 998 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserCloseFn)(s3eUsrFile* file);




typedef struct s3eUsrFileList s3eUsrFileList;
# 1013 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eUsrFileList* (*s3eUserListDirFn)(const char* path);
# 1027 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListNextFn)(s3eUsrFileList* handle, char* filename, int filenameLen);
# 1037 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserListCloseFn)(s3eUsrFileList* handle);
# 1047 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef s3eResult (*s3eUserDeleteFn)(const char* filename);
# 1084 "d:/marmalade/6.1/s3e/h/s3eFile.h"
typedef struct
{
    s3eUserOpenFn m_Open;
    s3eUserReadFn m_Read;
    s3eUserEOFFn m_EOF;
    s3eUserSeekFn m_Seek;
    s3eUserTellFn m_Tell;
    s3eUserCloseFn m_Close;

    s3eUserListDirFn m_ListDir;
    s3eUserListNextFn m_ListNext;
    s3eUserListCloseFn m_ListClose;

    s3eUserWriteFn m_Write;
    s3eUserDeleteFn m_Delete;

    void* m_Reserved[5];
} s3eFileUserCallbacks;
# 1114 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileAddUserFileSys(s3eFileUserCallbacks* callbacks);
# 1124 "d:/marmalade/6.1/s3e/h/s3eFile.h"
extern "C" s3eResult s3eFileRemoveUserFileSys(s3eFileUserCallbacks* callbacks);





# 1 "d:/marmalade/6.1/s3e/h/legacy/s3eFile_legacy.h" 1
# 16 "d:/marmalade/6.1/s3e/h/legacy/s3eFile_legacy.h"
typedef enum s3eFilePath
{
    S3E_FILEPATH_ROM,
    S3E_FILEPATH_RAM,
    S3E_FILEPATH_MMC,
    S3E_FILEPATH_MAX
} s3eFilePath;
# 34 "d:/marmalade/6.1/s3e/h/legacy/s3eFile_legacy.h"
extern "C" uint64 s3eFileGetFree(s3eFilePath path);
# 1131 "d:/marmalade/6.1/s3e/h/s3eFile.h" 2
# 17 "d:/marmalade/6.1/s3e/h/s3eConfig.h" 2
# 39 "d:/marmalade/6.1/s3e/h/s3eConfig.h"
typedef enum s3eConfigError
{
    S3E_CONFIG_ERR_NONE = 0,
    S3E_CONFIG_ERR_PARAM = 1,

    S3E_CONFIG_ERR_NOT_FOUND = 4,

    S3E_CONFIG_ERR_PARSE = 6
} s3eConfigError;
# 67 "d:/marmalade/6.1/s3e/h/s3eConfig.h"
extern "C" s3eConfigError s3eConfigGetError();
# 81 "d:/marmalade/6.1/s3e/h/s3eConfig.h"
extern "C" const char* s3eConfigGetErrorString();
# 104 "d:/marmalade/6.1/s3e/h/s3eConfig.h"
extern "C" s3eResult s3eConfigGetString(const char* group, const char* name, char* value);

extern "C" s3eResult s3eConfigGetStringHash(uint32 hash, char* value);
# 133 "d:/marmalade/6.1/s3e/h/s3eConfig.h"
extern "C" s3eResult s3eConfigGetInt(const char* group, const char* name, int* value);

extern "C" s3eResult s3eConfigGetIntHash(uint32 hash, int* value);
# 23 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eCrypto.h" 1
# 33 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
typedef struct s3eSHA1 s3eSHA1;
# 42 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
typedef enum s3eCryptoError
{
    S3E_CRYPTO_ERR_NONE = 0,
    S3E_CRYPTO_ERR_PARAM = 1,
    S3E_CRYPTO_ERR_TOO_MANY = 2,
    S3E_CRYPTO_ERR_DEVICE = 6,


    S3E_CRYPTO_ERR_INVALID_SIG = 1000,
    S3E_CRYPTO_ERR_SIG_CHECK = 1001
} s3eCryptoError;
# 68 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" uint32 s3eCryptoRand();
# 84 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoSha1(const uint8* data, uint32 dataLen, uint8* hash);
# 100 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" s3eSHA1* s3eCryptoSha1Init();
# 117 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoSha1Update(s3eSHA1* ctx, const uint8* data, uint32 dataLen);
# 133 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoSha1Final(s3eSHA1* ctx, uint8* hash);
# 150 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" s3eResult s3eCryptoVerifyRsa(uint8* sig, int sigLen,
                                     uint8* hash, int hashLen,
                                     uint8* mod, int modLen,
                                     uint8* exp, int expLen);
# 166 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" s3eCryptoError s3eCryptoGetError();
# 180 "d:/marmalade/6.1/s3e/h/s3eCrypto.h"
extern "C" const char* s3eCryptoGetErrorString();
# 24 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eDebug.h" 1
# 38 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
typedef enum s3eDebugProperty
{



    S3E_DEBUG_TRACE_ENABLED = 0,





    S3E_DEBUG_TRACE_TO_FILE = 1,




    S3E_DEBUG_ASSERT_ENABLED = 2,





    S3E_DEBUG_AVAILABLE = 3,




    S3E_DEBUG_FONT_SCALE = 4,




    S3E_DEBUG_FONT_WIDTH = 5,




    S3E_DEBUG_FONT_HEIGHT = 6

} s3eDebugProperty;
# 95 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" int32 s3eDebugGetInt(s3eDebugProperty property);
# 113 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugSetInt(s3eDebugProperty property, int32 value);







typedef enum s3eDebugCallback
{
# 137 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
    S3E_DEBUG_ASSERT = 0,
# 152 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
    S3E_DEBUG_ERROR = 1,

    S3E_DEBUG_CALLBACK_MAX
} s3eDebugCallback;
# 180 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugRegister(s3eDebugCallback cbid, s3eCallback fn, void* userData);
# 197 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" s3eResult s3eDebugUnRegister(s3eDebugCallback cbid, s3eCallback fn);
# 206 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
typedef enum s3eDebugError
{
    S3E_DEBUG_ERR_NONE = 0,
    S3E_DEBUG_ERR_PARAM = 1,
    S3E_DEBUG_ERR_TOO_MANY = 2,
    S3E_DEBUG_ERR_ALREADY_REG = 3,
    S3E_DEBUG_ERR_NOT_FOUND = 4
} s3eDebugError;
# 226 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" s3eDebugError s3eDebugGetError();
# 239 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" const char* s3eDebugGetErrorString();

typedef enum s3eErrorShowResult
{

    S3E_ERROR_SHOW_CONTINUE = 0,

    S3E_ERROR_SHOW_STOP = 1,

    S3E_ERROR_SHOW_IGNORE = 2,





    S3E_ERROR_SHOW_AGAIN = 3
} s3eErrorShowResult;




typedef enum s3eMessageType
{





    S3E_MESSAGE_CONTINUE = 0,





    S3E_MESSAGE_CONTINUE_STOP = 1,






    S3E_MESSAGE_CONTINUE_STOP_IGNORE = 2
} s3eMessageType;







extern "C" s3eBool s3eDebugIsDebuggerPresent();
# 305 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" void s3eDebugOutputString(const char* pStr);
# 317 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugErrorShow(s3eMessageType type, const char* string);






extern "C" s3eErrorShowResult s3eDebugErrorPrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 342 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" s3eErrorShowResult s3eDebugAssertShow(s3eMessageType type, const char* string);
# 355 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceLine(const char* string);






extern "C" int s3eDebugTracePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






extern "C" void s3eDebugTraceClearFile();
# 382 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" void s3eDebugTraceFlush();
# 407 "d:/marmalade/6.1/s3e/h/s3eDebug.h"
extern "C" void s3eDebugPrint(int x, int y, const char* string, s3eBool wrap);






extern "C" void s3eDebugPrintf(int x, int y, s3eBool wrap, const char* fmt, ...)

__attribute__((format(printf, 4, 5)))

;







extern "C" s3eBool s3eDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 25 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eDevice.h" 1
# 39 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
typedef enum s3eDeviceError
{
    S3E_DEVICE_ERR_NONE = 0,
    S3E_DEVICE_ERR_PARAM = 1,
    S3E_DEVICE_ERR_TOO_MANY = 2,
    S3E_DEVICE_ERR_ALREADY_REG = 3,
    S3E_DEVICE_ERR_NOT_FOUND = 4,
    S3E_DEVICE_ERR_UNAVAIL = 5,
    S3E_DEVICE_ERR_DEVICE = 6,
    S3E_DEVICE_ERR_UNSUPPORTED = 7,
    S3E_DEVICE_ERR_MEM = 8,
    S3E_DEVICE_ERR_GENERIC = 9,
    S3E_DEVICE_ERR_INVALID_DRIVE = 10,
    S3E_DEVICE_ERR_INVALID_PATH = 11
} s3eDeviceError;
# 66 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" s3eDeviceError s3eDeviceGetError();
# 80 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetErrorString();
# 89 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
typedef enum s3eDeviceFPUType
{
    S3E_DEVICE_FPU_NONE = 0,
    S3E_DEVICE_FPU_VFP = 1,
    S3E_DEVICE_FPU_VFPV3 = 2,
    S3E_DEVICE_FPU_NEON = 3
} s3eDeviceFPUType;






typedef enum s3eDeviceProperty
{







    S3E_DEVICE_OS = 0,





    S3E_DEVICE_CLASS = 1,
# 128 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_ID = 2,





    S3E_DEVICE_PHONE_NUMBER = 3,





    S3E_DEVICE_LANGUAGE = 4,






    S3E_DEVICE_STATE = 5,




    S3E_DEVICE_FREE_RAM = 6,




    S3E_DEVICE_TOTAL_RAM = 7,







    S3E_DEVICE_ARCHITECTURE = 8,
# 175 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_S3E_VERSION = 9,





    S3E_DEVICE_BATTERY_LEVEL = 10,






    S3E_DEVICE_LEFT_SOFTKEY_IS_BACK = 11,






    S3E_DEVICE_MAINS_POWER = 12,
# 204 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_OS_VERSION = 13,





    S3E_DEVICE_CHIPSET = 14,
# 219 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT_CODE = 15,





    S3E_DEVICE_FPU = 16,





    S3E_DEVICE_BACK_SOFTKEY_POSITION = 17,





    S3E_DEVICE_ADVANCE_SOFTKEY_POSITION = 18,
# 248 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_SDK_VERSION = 19,
# 257 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_LOCALE = 20,





    S3E_DEVICE_NAME = 21,







    S3E_DEVICE_SUPPORTS_SIGNAL_HANDLING = 22,







    S3E_DEVICE_EXIT_SIGNAL = 23,







    S3E_DEVICE_PROXIMITY = 24,
# 303 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNIQUE_ID = 25,
# 314 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_IMSI = 26,





    S3E_DEVICE_SILENT_MODE = 27,




    S3E_DEVICE_NUM_CPU_CORES = 28,




    S3E_DEVICE_MEM_TOTAL = 29,






    S3E_DEVICE_MEM_FREE = 30,





    S3E_DEVICE_TIMEZONE = 31,





    S3E_DEVICE_3D_MODE = 32

} s3eDeviceProperty;






typedef enum s3eDeviceOSID
{

    S3E_OS_ID_WINDOWS = 3,

    S3E_OS_ID_LINUX = 5,

    S3E_OS_ID_ARM_SEMIH = 8,

    S3E_OS_ID_OSX = 13,

    S3E_OS_ID_IPHONE = 14,

    S3E_OS_ID_BADA = 18,

    S3E_OS_ID_ANDROID = 19,

    S3E_OS_ID_QNX = 24,

    S3E_OS_ID_ROKU = 25,


    S3E_OS_ID_SYMBIAN = 1,

    S3E_OS_ID_BREW = 2,

    S3E_OS_ID_WINMOBILE = 4,

    S3E_OS_ID_WIPI = 6,

    S3E_OS_ID_NDS = 7,

    S3E_OS_ID_NUCLEUS = 9,

    S3E_OS_ID_NGI = 10,

    S3E_OS_ID_WINCE = 11,

    S3E_OS_ID_SHARPEMP = 12,

    S3E_OS_ID_UIQ = 15,

    S3E_OS_ID_PS3 = 16,

    S3E_OS_ID_X360 = 17,

    S3E_OS_ID_WEBOS = 20,

    S3E_OS_ID_PSP = 21,

    S3E_OS_ID_WII = 22,
    S3E_OS_ID_MEEGO = 23

} s3eDeviceOSID;






typedef enum s3eDeviceClassID
{
    S3E_DEVICE_CLASS_UNKNOWN = 0,

    S3E_DEVICE_CLASS_WINDOWS_GENERIC = 3000,
    S3E_DEVICE_CLASS_LINUX_GENERIC = 5000,
    S3E_DEVICE_CLASS_LINUX_DESKTOP = 5001,
    S3E_DEVICE_CLASS_LINUX_EMBED = 5002,
    S3E_DEVICE_CLASS_ARM_SEMIH_GENERIC = 8000,
    S3E_DEVICE_CLASS_OSX_DESKTOP = 11000,
    S3E_DEVICE_CLASS_IPHONE = 12000,
    S3E_DEVICE_CLASS_BADA_GENERIC = 15000,
    S3E_DEVICE_CLASS_ANDROID_GENERIC = 16000,
    S3E_DEVICE_CLASS_QNX = 19000,

    S3E_DEVICE_CLASS_SYMBIAN_GENERIC = 1000,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60 = 1001,
    S3E_DEVICE_CLASS_SYMBIAN_SERIES60_EMULATOR = 1002,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ = 1003,
    S3E_DEVICE_CLASS_SYMBIAN_UIQ_EMULATOR = 1004,
    S3E_DEVICE_CLASS_BREW_GENERIC = 2000,
    S3E_DEVICE_CLASS_BREW_QCIF_3G = 2001,
    S3E_DEVICE_CLASS_BREW_QCIF_25G = 2002,
    S3E_DEVICE_CLASS_BREW_SQCIF_25G = 2003,
    S3E_DEVICE_CLASS_BREW_QVGA_3G = 2004,
    S3E_DEVICE_CLASS_WINCE_GENERIC = 4000,
    S3E_DEVICE_CLASS_WINMOBILE_SP = 4001,
    S3E_DEVICE_CLASS_WINMOBILE_PPC = 4002,
    S3E_DEVICE_CLASS_WIPI_GENERIC = 6000,
    S3E_DEVICE_CLASS_NDS_GENERIC = 7000,
    S3E_DEVICE_CLASS_NDS_NDSI = 7001,
    S3E_DEVICE_CLASS_NUCLEUS_GENERIC = 9000,
    S3E_DEVICE_CLASS_NGI_GENERIC = 10000,
    S3E_DEVICE_CLASS_PS3 = 13000,
    S3E_DEVICE_CLASS_X360 = 14000,
    S3E_DEVICE_CLASS_PSP = 17000,
    S3E_DEVICE_CLASS_WII = 18000

} s3eDeviceClassID;




typedef enum s3eDeviceLanguage
{
    S3E_DEVICE_LANGUAGE_UNKNOWN = 0,
    S3E_DEVICE_LANGUAGE_ENGLISH = 1,
    S3E_DEVICE_LANGUAGE_FRENCH = 2,
    S3E_DEVICE_LANGUAGE_GERMAN = 3,
    S3E_DEVICE_LANGUAGE_SPANISH = 4,
    S3E_DEVICE_LANGUAGE_ITALIAN = 5,
    S3E_DEVICE_LANGUAGE_PORTUGUESE = 6,
    S3E_DEVICE_LANGUAGE_DUTCH = 7,
    S3E_DEVICE_LANGUAGE_TURKISH = 8,
    S3E_DEVICE_LANGUAGE_CROATIAN = 9,
    S3E_DEVICE_LANGUAGE_CZECH = 10,
    S3E_DEVICE_LANGUAGE_DANISH = 11,
    S3E_DEVICE_LANGUAGE_FINNISH = 12,
    S3E_DEVICE_LANGUAGE_HUNGARIAN = 13,
    S3E_DEVICE_LANGUAGE_NORWEGIAN = 14,
    S3E_DEVICE_LANGUAGE_POLISH = 15,
    S3E_DEVICE_LANGUAGE_RUSSIAN = 16,
    S3E_DEVICE_LANGUAGE_SERBIAN = 17,
    S3E_DEVICE_LANGUAGE_SLOVAK = 18,
    S3E_DEVICE_LANGUAGE_SLOVENIAN = 19,
    S3E_DEVICE_LANGUAGE_SWEDISH = 20,
    S3E_DEVICE_LANGUAGE_UKRAINIAN = 21,
    S3E_DEVICE_LANGUAGE_GREEK = 22,
    S3E_DEVICE_LANGUAGE_JAPANESE = 23,
    S3E_DEVICE_LANGUAGE_SIMPL_CHINESE = 24,
    S3E_DEVICE_LANGUAGE_TRAD_CHINESE = 25,
    S3E_DEVICE_LANGUAGE_KOREAN = 26,
    S3E_DEVICE_LANGUAGE_ICELANDIC = 27,
    S3E_DEVICE_LANGUAGE_FLEMISH = 28,
    S3E_DEVICE_LANGUAGE_THAI = 29,
    S3E_DEVICE_LANGUAGE_AFRIKAANS = 30,
    S3E_DEVICE_LANGUAGE_ALBANIAN = 31,
    S3E_DEVICE_LANGUAGE_AMHARIC = 32,
    S3E_DEVICE_LANGUAGE_ARABIC = 33,
    S3E_DEVICE_LANGUAGE_ARMENIAN = 34,
    S3E_DEVICE_LANGUAGE_AZERBAIJANI = 35,
    S3E_DEVICE_LANGUAGE_TAGALOG = 36,
    S3E_DEVICE_LANGUAGE_BELARUSSIAN = 37,
    S3E_DEVICE_LANGUAGE_BENGALI = 38,
    S3E_DEVICE_LANGUAGE_BULGARIAN = 39,
    S3E_DEVICE_LANGUAGE_BURMESE = 40,
    S3E_DEVICE_LANGUAGE_CATALAN = 41,
    S3E_DEVICE_LANGUAGE_ESTONIAN = 42,
    S3E_DEVICE_LANGUAGE_FARSI = 43,
    S3E_DEVICE_LANGUAGE_GAELIC = 44,
    S3E_DEVICE_LANGUAGE_GEORGIAN = 45,
    S3E_DEVICE_LANGUAGE_GUJARATI = 46,
    S3E_DEVICE_LANGUAGE_HEBREW = 47,
    S3E_DEVICE_LANGUAGE_HINDI = 48,
    S3E_DEVICE_LANGUAGE_INDONESIAN = 49,
    S3E_DEVICE_LANGUAGE_IRISH = 50,
    S3E_DEVICE_LANGUAGE_KANNADA = 51,
    S3E_DEVICE_LANGUAGE_KAZAKH = 52,
    S3E_DEVICE_LANGUAGE_KHMER = 53,
    S3E_DEVICE_LANGUAGE_LAO = 54,
    S3E_DEVICE_LANGUAGE_LATVIAN = 55,
    S3E_DEVICE_LANGUAGE_LITHUANIAN = 56,
    S3E_DEVICE_LANGUAGE_MACEDONIAN = 57,
    S3E_DEVICE_LANGUAGE_MALAY = 58,
    S3E_DEVICE_LANGUAGE_MALAYALAM = 59,
    S3E_DEVICE_LANGUAGE_MARATHI = 60,
    S3E_DEVICE_LANGUAGE_MOLDOVIAN = 61,
    S3E_DEVICE_LANGUAGE_MONGOLIAN = 62,
    S3E_DEVICE_LANGUAGE_PUNJABI = 63,
    S3E_DEVICE_LANGUAGE_ROMANIAN = 64,
    S3E_DEVICE_LANGUAGE_SINHALESE = 65,
    S3E_DEVICE_LANGUAGE_SOMALI = 66,
    S3E_DEVICE_LANGUAGE_SWAHILI = 67,
    S3E_DEVICE_LANGUAGE_TAJIK = 68,
    S3E_DEVICE_LANGUAGE_TAMIL = 69,
    S3E_DEVICE_LANGUAGE_TELUGU = 70,
    S3E_DEVICE_LANGUAGE_TIBETAN = 71,
    S3E_DEVICE_LANGUAGE_TIGRINYA = 72,
    S3E_DEVICE_LANGUAGE_TURKMEN = 73,
    S3E_DEVICE_LANGUAGE_URDU = 74,
    S3E_DEVICE_LANGUAGE_UZBEK = 75,
    S3E_DEVICE_LANGUAGE_VIETNAMESE = 76,
    S3E_DEVICE_LANGUAGE_WELSH = 77,
    S3E_DEVICE_LANGUAGE_ZULU = 78
} s3eDeviceLanguage;






typedef enum s3eDeviceArchitecture
{
    S3E_DEVICE_ARCHITECTURE_ARM4T = 0,
    S3E_DEVICE_ARCHITECTURE_ARM4 = 1,
    S3E_DEVICE_ARCHITECTURE_ARM5T = 2,
    S3E_DEVICE_ARCHITECTURE_ARM5TE = 3,
    S3E_DEVICE_ARCHITECTURE_ARM5TEJ = 4,
    S3E_DEVICE_ARCHITECTURE_ARM6 = 5,
    S3E_DEVICE_ARCHITECTURE_ARM6K = 6,
    S3E_DEVICE_ARCHITECTURE_ARM6T2 = 7,
    S3E_DEVICE_ARCHITECTURE_ARM6Z = 8,
    S3E_DEVICE_ARCHITECTURE_ARM7 = 12,
    S3E_DEVICE_ARCHITECTURE_X86 = 9,
    S3E_DEVICE_ARCHITECTURE_PPC = 10,
    S3E_DEVICE_ARCHITECTURE_AMD64 = 11,
    S3E_DEVICE_ARCHITECTURE_MIPS = 13,
    S3E_DEVICE_ARCHITECTURE_MAX = 14
} s3eDeviceArchitecture;
# 575 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
typedef enum s3eDeviceSoftKeyPosition
{
    S3E_DEVICE_SOFTKEY_BOTTOM_LEFT = 0,
    S3E_DEVICE_SOFTKEY_BOTTOM_RIGHT = 1,
    S3E_DEVICE_SOFTKEY_TOP_RIGHT = 2,
    S3E_DEVICE_SOFTKEY_TOP_LEFT = 3
} s3eDeviceSoftKeyPosition;
# 616 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" const char* s3eDeviceGetString(s3eDeviceProperty property);
# 651 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" int32 s3eDeviceGetInt(s3eDeviceProperty property);
# 671 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceSetInt(s3eDeviceProperty property, int32 value);
# 699 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" int64 s3eDeviceYield(int32 ms =0);
# 721 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceUnYield();
# 749 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceYieldUntilEvent(int32 ms =0x7fffffffL);
# 784 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceExecPushNext(const char* filename, const char* config_prepend =__null, const char* config_append =__null);
# 800 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceExit(int code =0) __attribute__ ((noreturn));






typedef enum s3eDeviceState
{




    S3E_DEVICE_STATE_PAUSED = 3,





    S3E_DEVICE_STATE_EXITING = 4,




    S3E_DEVICE_STATE_RUNNING = 5
} s3eDeviceState;
# 837 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
typedef enum s3eDeviceCallback
{
# 850 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_PAUSE = 0,
# 862 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_UNPAUSE = 1,
# 874 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_EXIT = 2,
# 890 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_UP = 17,
# 906 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_VOL_DOWN = 18,
# 924 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_MAINS_POWER_CHANGED = 20,
# 936 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_BACKGROUND = 22,
# 948 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_FOREGROUND = 23,
# 962 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_ONLINE = 24,
# 976 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_NETWORK_OFFLINE = 25,
# 989 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    S3E_DEVICE_SIMULATOR_RESTART = 26,


    S3E_DEVICE_CALLBACK_MAX
} s3eDeviceCallback;
# 1011 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
typedef struct s3eDeviceVolChangeInfo
{





    s3eBool m_VolUp;
# 1036 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
    s3eBool m_OverrideDefaultBehaviour;
} s3eDeviceVolChangeInfo;





typedef struct s3eDeviceStateChangeInfo
{



    int32 m_State;
} s3eDeviceStateChangeInfo;
# 1071 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceRegister(s3eDeviceCallback cbid, s3eCallback fn, void* userdata);
# 1091 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" s3eResult s3eDeviceUnRegister(s3eDeviceCallback cbid, s3eCallback fn);







extern "C" void s3eDeviceRequestQuit();
# 1110 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckQuitRequest();
# 1120 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" s3eBool s3eDeviceCheckPauseRequest();
# 1134 "d:/marmalade/6.1/s3e/h/s3eDevice.h"
extern "C" void s3eDeviceBacklightOn();


extern "C" s3eBool s3eDeviceNetworkCheckStart();


extern "C" s3eBool s3eDeviceNetworkCheckStop();


extern "C" void s3eDeviceLoaderCallStart(s3eBool lock, void* function);


extern "C" void s3eDeviceLoaderCallDone(s3eBool lock, void* function);
# 26 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eExt.h" 1
# 31 "d:/marmalade/6.1/s3e/h/s3eExt.h"
typedef enum s3eExtError
{
    S3E_EXT_ERR_NONE = 0,
    S3E_EXT_ERR_PARAM = 1,
    S3E_EXT_ERR_NOT_FOUND = 4
} s3eExtError;
# 49 "d:/marmalade/6.1/s3e/h/s3eExt.h"
extern "C" s3eExtError s3eExtGetError();
# 63 "d:/marmalade/6.1/s3e/h/s3eExt.h"
extern "C" const char* s3eExtGetErrorString();
# 96 "d:/marmalade/6.1/s3e/h/s3eExt.h"
extern "C" s3eResult s3eExtGet(const char* extension, void* functions, uint32 functionsLen);
# 106 "d:/marmalade/6.1/s3e/h/s3eExt.h"
extern "C" s3eResult s3eExtGetHash(uint32 hash, void* functions, uint32 functionsLen);

static inline s3eBool s3eExtAvailable(const char* extension, int32 len =0)
{
    if (s3eExtGet(extension, __null, len) == S3E_RESULT_SUCCESS)
        return (1);
    else
        return (0);
}
# 27 "d:/marmalade/6.1/s3e/h/s3e.h" 2

# 1 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h" 1
# 38 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
typedef enum s3eKey
{
    s3eKeyFirst = 0,

    s3eKeyEsc = 1,
    s3eKeyTab = 2,
    s3eKeyBackspace = 3,
    s3eKeyEnter = 4,
    s3eKeyLeftShift = 5,
    s3eKeyLeftControl = 6,
    s3eKeyReserved = 7,
    s3eKeySpace = 8,
    s3eKeyLeft = 9,
    s3eKeyUp = 10,
    s3eKeyRight = 11,
    s3eKeyDown = 12,
    s3eKey0 = 13,
    s3eKey1 = 14,
    s3eKey2 = 15,
    s3eKey3 = 16,
    s3eKey4 = 17,
    s3eKey5 = 18,
    s3eKey6 = 19,
    s3eKey7 = 20,
    s3eKey8 = 21,
    s3eKey9 = 22,
    s3eKeyA = 23,
    s3eKeyB = 24,
    s3eKeyC = 25,
    s3eKeyD = 26,
    s3eKeyE = 27,
    s3eKeyF = 28,
    s3eKeyG = 29,
    s3eKeyH = 30,
    s3eKeyI = 31,
    s3eKeyJ = 32,
    s3eKeyK = 33,
    s3eKeyL = 34,
    s3eKeyM = 35,
    s3eKeyN = 36,
    s3eKeyO = 37,
    s3eKeyP = 38,
    s3eKeyQ = 39,
    s3eKeyR = 40,
    s3eKeyS = 41,
    s3eKeyT = 42,
    s3eKeyU = 43,
    s3eKeyV = 44,
    s3eKeyW = 45,
    s3eKeyX = 46,
    s3eKeyY = 47,
    s3eKeyZ = 48,
    s3eKeyF1 = 49,
    s3eKeyF2 = 50,
    s3eKeyF3 = 51,
    s3eKeyF4 = 52,
    s3eKeyF5 = 53,
    s3eKeyF6 = 54,
    s3eKeyF7 = 55,
    s3eKeyF8 = 56,
    s3eKeyF9 = 57,
    s3eKeyF10 = 58,
    s3eKeyNumPad0 = 59,
    s3eKeyNumPad1 = 60,
    s3eKeyNumPad2 = 61,
    s3eKeyNumPad3 = 62,
    s3eKeyNumPad4 = 63,
    s3eKeyNumPad5 = 64,
    s3eKeyNumPad6 = 65,
    s3eKeyNumPad7 = 66,
    s3eKeyNumPad8 = 67,
    s3eKeyNumPad9 = 68,
    s3eKeyNumPadPlus = 69,
    s3eKeyNumPadMinus = 70,
    s3eKeyNumPadEnter = 71,
    s3eKeyRSK = 72,
    s3eKeyLSK = 73,
    s3eKeyLS = 74,
    s3eKeyRS = 75,
    s3eKeyHash = 76,
    s3eKeyStar = 77,


    s3eKeyOk = 78,
    s3eKeyCLR = 79,


    s3eKeyVolUp = 80,
    s3eKeyVolDown = 81,


    s3eKeyCamera = 82,
    s3eKeyMic = 83,
    s3eKeyFn = 84,
    s3eKeySym = 85,


    s3eKeyAccept = 86,
    s3eKeyEnd = 87,
    s3eKeyHomePage = 88,

    s3eKeyButton1 = 89,
    s3eKeyButton2 = 90,
    s3eKeyButton3 = 91,
    s3eKeyButton4 = 92,
    s3eKeyButton5 = 93,
    s3eKeyButton6 = 94,
    s3eKeyButton7 = 95,
    s3eKeyButton8 = 96,

    s3eKeyF11 = 97,
    s3eKeyF12 = 98,
    s3eKeyLeftAlt = 99,

    s3eKeyRightControl = 100,
    s3eKeyRightAlt = 101,
    s3eKeyRightShift = 102,
    s3eKeyBacktick = 103,
    s3eKeyComma = 104,
    s3eKeyPeriod = 105,
    s3eKeySlash = 106,
    s3eKeyBackSlash = 107,
    s3eKeySemicolon = 108,
    s3eKeyApostrophe = 109,
    s3eKeyLeftBracket = 110,
    s3eKeyRightBracket = 111,
    s3eKeyEquals = 112,
    s3eKeyMinus = 113,
    s3eKeyCapsLock = 114,

    s3eKeyNumPadPeriod = 115,
    s3eKeyNumPadSlash = 116,
    s3eKeyNumLock = 117,
    s3eKeyInsert = 118,
    s3eKeyHome = 119,
    s3eKeyPageUp = 120,
    s3eKeyPageDown = 121,
    s3eKeyKbEnd = 122,
    s3eKeyDelete = 123,
    s3eKeyPause = 124,
    s3eKeyAt = 125,
    s3eKeyBack = 126,
    s3eKeyMenu = 127,
    s3eKeySearch = 128,
    s3eKey3DMode = 129,

    s3eKeyAbsGameA = 200,
    s3eKeyAbsGameB = 201,
    s3eKeyAbsGameC = 202,
    s3eKeyAbsGameD = 203,
    s3eKeyAbsUp = 204,
    s3eKeyAbsDown = 205,
    s3eKeyAbsLeft = 206,
    s3eKeyAbsRight = 207,
    s3eKeyAbsOk = 208,
    s3eKeyAbsASK = 209,
    s3eKeyAbsBSK = 210,

    s3eKeyCount = 211
} s3eKey;
# 235 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
typedef enum s3eKeyboardNumpadOrientation
{
    S3E_NUMPAD_ORIENT_NORMAL = 0,
    S3E_NUMPAD_ORIENT_ROT90 = 1,
    S3E_NUMPAD_ORIENT_ROT180 = 2,
    S3E_NUMPAD_ORIENT_ROT270 = 3
} s3eKeyboardNumpadOrientation;






typedef enum s3eKeyboardProperty
{





    S3E_KEYBOARD_HAS_NUMPAD = 0,






    S3E_KEYBOARD_HAS_ALPHA = 1,






    S3E_KEYBOARD_HAS_DIRECTION = 2,






    S3E_KEYBOARD_NUMPAD_ORIENTATION = 3,
# 302 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
    S3E_KEYBOARD_GET_CHAR = 4
} s3eKeyboardProperty;







typedef enum s3eKeyboardError
{
    S3E_KEYBOARD_ERR_NONE = 0,
    S3E_KEYBOARD_ERR_PARAM = 1,
    S3E_KEYBOARD_ERR_TOO_MANY = 2,
    S3E_KEYBOARD_ERR_ALREADY_REG = 3,
    S3E_KEYBOARD_ERR_NOT_FOUND = 4,
    S3E_KEYBOARD_ERR_UNAVAIL = 5,

    S3E_KEYBOARD_ERR_DEVICE = 6
} s3eKeyboardError;






typedef enum s3eKeyboardCallback
{
# 342 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
    S3E_KEYBOARD_KEY_EVENT = 0,
# 357 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
    S3E_KEYBOARD_CHAR_EVENT = 1,

    S3E_KEYBOARD_CALLBACK_MAX
} s3eKeyboardCallback;






typedef struct s3eKeyboardEvent
{

    s3eKey m_Key;

    uint32 m_Pressed;
} s3eKeyboardEvent;






typedef struct s3eKeyboardCharEvent
{

    s3eWChar m_Char;
} s3eKeyboardCharEvent;
# 407 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" int32 s3eKeyboardGetInt(s3eKeyboardProperty property);
# 427 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardSetInt(s3eKeyboardProperty property, int32 value);
# 455 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardRegister(s3eKeyboardCallback cbid, s3eCallback fn, void* userdata);
# 474 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardUnRegister(s3eKeyboardCallback cbid, s3eCallback fn);
# 486 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" s3eKeyboardError s3eKeyboardGetError();
# 500 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" const char* s3eKeyboardGetErrorString();







extern "C" void s3eKeyboardClearState();







extern "C" s3eResult s3eKeyboardUpdate();
# 532 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" int32 s3eKeyboardGetState(s3eKey key);






extern "C" s3eWChar s3eKeyboardGetChar();
# 550 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" s3eKey s3eKeyboardAnyKey();
# 572 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h"
extern "C" s3eResult s3eKeyboardGetDisplayName(char* dst, s3eKey key, s3eBool terminateString =(1));





# 1 "d:/marmalade/6.1/s3e/h/legacy/s3eKeyboard_legacy.h" 1
# 579 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h" 2
# 29 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eLicense.h" 1
# 36 "d:/marmalade/6.1/s3e/h/s3eLicense.h"
typedef enum s3eLicenseStatus
{
    S3E_LICENSE_EXPIRED = 0,
    S3E_LICENSE_DEMO = 0x10,
    S3E_LICENSE_USECOUNT = 0x20,
    S3E_LICENSE_EXPIRYDATE = 0x21,
    S3E_LICENSE_EXPIRYMINSUSE = 0x22,
    S3E_LICENSE_PURCHASE = 0x100,
    S3E_LICENSE_SUBSCRIPTION = 0x200,
    S3E_LICENSE_UPGRADE = 0x300,
    S3E_LICENSE_NONCOMMERCIAL = 0x1000
} s3eLicenseStatus;






typedef enum s3eLicenseError
{
    S3E_LICENSE_ERR_NONE = 0,
    S3E_LICENSE_ERR_PARAM = 1
} s3eLicenseError;






typedef enum s3eLicenseProperty
{
    S3E_LICENSE_USES_LEFT,
    S3E_LICENSE_EXPIRY_DATE,
    S3E_LICENSE_MINS_LEFT,
    S3E_LICENSE_STATUS
} s3eLicenseProperty;




extern "C" int32 s3eLicenseGetInt(s3eLicenseProperty property);
# 88 "d:/marmalade/6.1/s3e/h/s3eLicense.h"
extern "C" s3eLicenseError s3eLicenseGetError();
# 102 "d:/marmalade/6.1/s3e/h/s3eLicense.h"
extern "C" const char* s3eLicenseGetErrorString();
# 111 "d:/marmalade/6.1/s3e/h/s3eLicense.h"
extern "C" s3eResult s3eLicenseBuy();
# 30 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eMemory.h" 1
# 38 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
typedef enum s3eMemoryProperty
{
# 55 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
    S3E_MEMORY_HEAP = 0,





    S3E_MEMORY_SIZE = 1,





    S3E_MEMORY_FREE = 2,





    S3E_MEMORY_USED = 3,






    S3E_MEMORY_LFB = 4,






    S3E_MEMORY_FLAGS = 5
} s3eMemoryProperty;







typedef enum s3eMemoryFlags
{



    S3E_MEMORY_NO_MSG_ON_FAIL = (1 << 0),
# 112 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
    S3E_MEMORY_USE_STACK_ALLOCATOR = (1 << 1),
# 121 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
    S3E_MEMORY_INACTIVE = (1 << 2)
} s3eMemoryFlags;
# 144 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" int32 s3eMemoryGetInt(s3eMemoryProperty property);
# 163 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemorySetInt(s3eMemoryProperty property, int32 value);
# 172 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
typedef enum s3eMemoryError
{
    S3E_MEMORY_ERR_NONE = 0,
    S3E_MEMORY_ERR_PARAM = 1,
    S3E_MEMORY_ERR_UNAVAIL = 5,

    S3E_MEMORY_ERR_INVALID_PTR = 1000,
    S3E_MEMORY_ERR_NO_MEM = 1001,
    S3E_MEMORY_ERR_INVALID_STATE = 1002
} s3eMemoryError;
# 194 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" s3eMemoryError s3eMemoryGetError();
# 208 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" const char* s3eMemoryGetErrorString();
# 229 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" void* s3eMalloc(int size);
# 253 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" void* s3eRealloc(void* item, int newSize);
# 267 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" void s3eFree(void* item);
# 286 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" void* s3eMallocBase(int size);
# 312 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" void* s3eReallocBase(void* item, int newSize);
# 324 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" void s3eFreeBase(void* item);
# 345 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemoryHeapDestroy(int32 heapID, s3eBool failIfNotEmpty);
# 360 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemoryHeapCreate(int32 heapID);
# 369 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" void* s3eMemoryHeapAddress(int32 heapID);



typedef void*(*s3eMallocFn)(int size);
typedef void*(*s3eReallocFn)(void* item, int size);
typedef void (*s3eFreeFn)(void* item);




typedef struct s3eMemoryUsrMgr
{
    s3eMallocFn m_Malloc;
    s3eReallocFn m_Realloc;
    s3eFreeFn m_Free;
} s3eMemoryUsrMgr;
# 407 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemorySetUserMemMgr(s3eMemoryUsrMgr* callbacks);
# 429 "d:/marmalade/6.1/s3e/h/s3eMemory.h"
extern "C" s3eResult s3eMemoryGetUserMemMgr(s3eMemoryUsrMgr* callbacks);
# 31 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3ePointer.h" 1
# 37 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
typedef enum s3ePointerType
{
    S3E_POINTER_TYPE_INVALID = 0,
    S3E_POINTER_TYPE_MOUSE = 1,
    S3E_POINTER_TYPE_STYLUS = 2
} s3ePointerType;







typedef enum s3eStylusType
{
    S3E_STYLUS_TYPE_INVALID = 0,
    S3E_STYLUS_TYPE_STYLUS = 1,
    S3E_STYLUS_TYPE_FINGER = 2
} s3eStylusType;
# 68 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
typedef enum s3ePointerProperty
{



    S3E_POINTER_AVAILABLE = 0,






    S3E_POINTER_HIDE_CURSOR = 1,




    S3E_POINTER_TYPE = 2,




    S3E_POINTER_STYLUS_TYPE = 3,




    S3E_POINTER_MULTI_TOUCH_AVAILABLE = 4

} s3ePointerProperty;
# 111 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
extern "C" int32 s3ePointerGetInt(s3ePointerProperty property);
# 128 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
extern "C" s3eResult s3ePointerSetInt(s3ePointerProperty property, int32 value);
# 137 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
typedef enum s3ePointerCallback
{







    S3E_POINTER_BUTTON_EVENT,
# 155 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
    S3E_POINTER_MOTION_EVENT,
# 166 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
    S3E_POINTER_TOUCH_EVENT,
# 177 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
    S3E_POINTER_TOUCH_MOTION_EVENT,
    S3E_POINTER_CALLBACK_MAX
} s3ePointerCallback;
# 201 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
extern "C" s3eResult s3ePointerRegister(s3ePointerCallback cbid, s3eCallback fn, void* userData);
# 218 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
extern "C" s3eResult s3ePointerUnRegister(s3ePointerCallback cbid, s3eCallback fn);
# 227 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
typedef enum s3ePointerError
{
    S3E_POINTER_ERR_NONE = 0,
    S3E_POINTER_ERR_PARAM = 1,
    S3E_POINTER_ERR_TOO_MANY = 2,
    S3E_POINTER_ERR_ALREADY_REG = 3,
    S3E_POINTER_ERR_NOT_FOUND = 4,
    S3E_POINTER_ERR_UNAVAIL = 5
} s3ePointerError;







extern "C" s3ePointerError s3ePointerGetError();







extern "C" const char* s3ePointerGetErrorString();






typedef enum s3ePointerState
{
    S3E_POINTER_STATE_UP = 0,
    S3E_POINTER_STATE_DOWN = 1,
    S3E_POINTER_STATE_PRESSED = 2,
    S3E_POINTER_STATE_RELEASED = 4,
    S3E_POINTER_STATE_UNKNOWN
} s3ePointerState;






typedef enum s3ePointerButton
{
    S3E_POINTER_BUTTON_SELECT = 0,
    S3E_POINTER_BUTTON_LEFTMOUSE = 0,
    S3E_POINTER_BUTTON_RIGHTMOUSE = 1,
    S3E_POINTER_BUTTON_MIDDLEMOUSE = 2,
    S3E_POINTER_BUTTON_MOUSEWHEELUP = 3,
    S3E_POINTER_BUTTON_MOUSEWHEELDOWN = 4,
    S3E_POINTER_BUTTON_MAX
} s3ePointerButton;




typedef struct s3ePointerEvent
{

    s3ePointerButton m_Button;

    uint32 m_Pressed;

    int32 m_x;

    int32 m_y;
} s3ePointerEvent;




typedef struct s3ePointerMotionEvent
{

    int32 m_x;

    int32 m_y;
} s3ePointerMotionEvent;




typedef struct s3ePointerTouchEvent
{





    uint32 m_TouchID;

    uint32 m_Pressed;

    int32 m_x;

    int32 m_y;
} s3ePointerTouchEvent;




typedef struct s3ePointerTouchMotionEvent
{





    uint32 m_TouchID;

    int32 m_x;

    int32 m_y;
} s3ePointerTouchMotionEvent;






extern "C" s3ePointerState s3ePointerGetState(s3ePointerButton button);






extern "C" int32 s3ePointerGetX();






extern "C" int32 s3ePointerGetY();
# 375 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
extern "C" s3ePointerState s3ePointerGetTouchState(uint32 touchID);
# 387 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
extern "C" int32 s3ePointerGetTouchX(uint32 touchID);
# 399 "d:/marmalade/6.1/s3e/h/s3ePointer.h"
extern "C" int32 s3ePointerGetTouchY(uint32 touchID);







extern "C" s3eResult s3ePointerUpdate();
# 32 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eSecureStorage.h" 1
# 38 "d:/marmalade/6.1/s3e/h/s3eSecureStorage.h"
typedef enum s3eSecureStorageError
{
    S3E_SECURESTORAGE_ERR_NONE = 0,
    S3E_SECURESTORAGE_ERR_PARAM = 1,
    S3E_SECURESTORAGE_ERR_NOT_FOUND = 4,
    S3E_SECURESTORAGE_ERR_DEVICE = 6,
    S3E_SECURESTORAGE_ERR_INSUFF = 1000,
    S3E_SECURESTORAGE_ERR_CORRUPT = 1001
} s3eSecureStorageError;
# 59 "d:/marmalade/6.1/s3e/h/s3eSecureStorage.h"
extern "C" s3eSecureStorageError s3eSecureStorageGetError();
# 72 "d:/marmalade/6.1/s3e/h/s3eSecureStorage.h"
extern "C" const char* s3eSecureStorageGetErrorString();
# 96 "d:/marmalade/6.1/s3e/h/s3eSecureStorage.h"
extern "C" s3eResult s3eSecureStoragePut(void* data, uint16 size);
# 119 "d:/marmalade/6.1/s3e/h/s3eSecureStorage.h"
extern "C" s3eResult s3eSecureStorageGet(void* data, uint16 size);
# 33 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eSound.h" 1
# 46 "d:/marmalade/6.1/s3e/h/s3eSound.h"
typedef enum s3eSoundProperty
{





    S3E_SOUND_VOLUME = 0,
# 66 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_SOUND_OUTPUT_FREQ = 1,







    S3E_SOUND_DEFAULT_FREQ = 2,




    S3E_SOUND_NUM_CHANNELS = 3,





    S3E_SOUND_USED_CHANNELS = 4,




    S3E_SOUND_AVAILABLE = 5,
# 103 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_SOUND_VOLUME_DEFAULT = 6,
# 112 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_SOUND_STEREO_ENABLED = 7
} s3eSoundProperty;
# 140 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" int32 s3eSoundGetInt(s3eSoundProperty property);
# 162 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundSetInt(s3eSoundProperty property, int32 value);
# 171 "d:/marmalade/6.1/s3e/h/s3eSound.h"
typedef enum s3eSoundError
{
    S3E_SOUND_ERR_NONE = 0,
    S3E_SOUND_ERR_PARAM = 1,
    S3E_SOUND_ERR_TOO_MANY = 2,
    S3E_SOUND_ERR_ALREADY_REG = 3,
    S3E_SOUND_ERR_NOT_FOUND = 4,
    S3E_SOUND_ERR_UNAVAIL = 5
} s3eSoundError;
# 192 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eSoundError s3eSoundGetError();
# 205 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" const char* s3eSoundGetErrorString();
# 219 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" int s3eSoundGetFreeChannel();
# 234 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" void s3eSoundPauseAllChannels();
# 248 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" void s3eSoundResumeAllChannels();
# 263 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" void s3eSoundStopAllChannels();






typedef enum s3eSoundChannelProperty
{
# 282 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_CHANNEL_PITCH = 0,
# 291 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_CHANNEL_RATE = 1,







    S3E_CHANNEL_USERVAR = 2,
# 308 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_CHANNEL_VOLUME = 3,





    S3E_CHANNEL_STATUS = 4,





    S3E_CHANNEL_PAUSED = 5
} s3eSoundChannelProperty;
# 342 "d:/marmalade/6.1/s3e/h/s3eSound.h"
typedef enum s3eSoundChannelCallback
{
# 359 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_CHANNEL_END_SAMPLE = 0,
# 405 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_CHANNEL_GEN_AUDIO = 1,
# 419 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_CHANNEL_STOP_AUDIO = 2,
# 443 "d:/marmalade/6.1/s3e/h/s3eSound.h"
    S3E_CHANNEL_GEN_AUDIO_STEREO = 3
} s3eSoundChannelCallback;
# 484 "d:/marmalade/6.1/s3e/h/s3eSound.h"
typedef struct s3eSoundEndSampleInfo
{



    int32 m_Channel;





    int32 m_RepsRemaining;






    int16* m_NewData;





    uint32 m_NumSamples;
} s3eSoundEndSampleInfo;
# 567 "d:/marmalade/6.1/s3e/h/s3eSound.h"
typedef struct s3eSoundGenAudioInfo
{
    int32 m_Channel;

    int16* m_Target;
    uint32 m_NumSamples;
    int32 m_Mix;

    int16* m_OrigStart;
    uint32 m_OrigNumSamples;
    uint32 m_OrigRepeat;

    s3eBool m_EndSample;
    s3eBool m_Stereo;
} s3eSoundGenAudioInfo;
# 609 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelSetInt(int channel, s3eSoundChannelProperty property, int32 value);
# 628 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" int32 s3eSoundChannelGetInt(int channel, s3eSoundChannelProperty property);
# 661 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelPlay(int channel, int16* start, uint32 numSamples, int32 repeat, int32 loopfrom);
# 683 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelStop(int channel);
# 704 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelPause(int channel);
# 725 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelResume(int channel);
# 754 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelRegister(int channel, s3eSoundChannelCallback cbid, s3eCallback func, void* userData);
# 779 "d:/marmalade/6.1/s3e/h/s3eSound.h"
extern "C" s3eResult s3eSoundChannelUnRegister(int channel, s3eSoundChannelCallback cbid);
# 34 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eSocket.h" 1
# 36 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
typedef enum s3eSocketType
{
    S3E_SOCKET_TCP,
    S3E_SOCKET_UDP
} s3eSocketType;

typedef enum s3eNetworkType
{
    S3E_NETWORK_TYPE_NONE = 0,
    S3E_NETWORK_TYPE_UNKNOWN = 1,
    S3E_NETWORK_TYPE_LAN = 2,
    S3E_NETWORK_TYPE_WLAN = 3,
    S3E_NETWORK_TYPE_GPRS = 4,
    S3E_NETWORK_TYPE_UMTS = 5,
    S3E_NETWORK_TYPE_EVDO = 6,
    S3E_NETWORK_TYPE_CDMA2000 = 7,
    S3E_NETWORK_TYPE_HSDPA = 8,
    S3E_NETWORK_TYPE_WIMAX = 9,
    S3E_NETWORK_TYPE_BLUETOOTH = 10,
    S3E_NETWORK_TYPE_EDGE = 11,
    S3E_NETWORK_TYPE_CDMA = 12,
    S3E_NETWORK_TYPE_IDEN = 13,
    S3E_NETWORK_TYPE_LTE = 14,
    S3E_NETWORK_TYPE_EHRPD = 15,
    S3E_NETWORK_TYPE_HSPAPLUS = 16,
} s3eNetworkType;
# 88 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
typedef struct s3eSocket s3eSocket;
# 101 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
typedef uint32 s3eInetIPAddress;
# 114 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
typedef struct s3eInetAddress
{

    char m_Local;

    char m_LocalAddress[128];

    char m_Abstract;

    s3eInetIPAddress m_IPAddress;

    uint16 m_Port;

    char m_String[128];
} s3eInetAddress;
# 137 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
typedef enum s3eSocketProperty
{



    S3E_SOCKET_MAX_SOCKETS,



    S3E_SOCKET_NETWORK_AVAILABLE,



    S3E_SOCKET_NETWORK_TYPE,



    S3E_SOCKET_DOMAINNAME,



    S3E_SOCKET_HOSTNAME,



    S3E_SOCKET_HTTP_PROXY,



    S3E_SOCKET_UDP_AVAILABLE
} s3eSocketProperty;


typedef enum s3eSocketOption
{





    S3E_SOCKET_NODELAY = 1,







    S3E_SOCKET_KEEPALIVE = 2,







    S3E_SOCKET_BROADCAST = 3,
# 204 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
    S3E_SOCKET_ADD_MEMBERSHIP = 4,
# 217 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
    S3E_SOCKET_DROP_MEMBERSHIP = 5

} s3eSocketOption;
# 234 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketGetInt(s3eSocketProperty socketProperty);
# 249 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketSetOpt(s3eSocket* s, s3eSocketOption opt, void* value, int valueLen);
# 264 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketGetOpt(s3eSocket* s, s3eSocketOption opt, void* out, int* outLen);
# 275 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" const char* s3eSocketGetString(s3eSocketProperty socketProperty);
# 284 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
typedef int32 (*s3eSocketCallbackFn)(s3eSocket* s, void* systemData, void* userData);
# 294 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
typedef enum s3eSocketError
{
    S3E_SOCKET_ERR_NONE = 0,
    S3E_SOCKET_ERR_PARAM = 1,
    S3E_SOCKET_ERR_TOO_MANY = 2,
    S3E_SOCKET_ERR_ALREADY_REG = 3,
    S3E_SOCKET_ERR_NOT_FOUND = 4,
    S3E_SOCKET_ERR_UNAVAIL = 5,
    S3E_SOCKET_ERR_UNSUPPORTED = 7,

    S3E_SOCKET_ERR_WOULDBLOCK = 1000,
    S3E_SOCKET_ERR_INPROGRESS = 1001,
    S3E_SOCKET_ERR_ALREADY = 1002,
    S3E_SOCKET_ERR_NOTSOCK = 1003,
    S3E_SOCKET_ERR_MSGSIZE = 1004,
    S3E_SOCKET_ERR_ADDRINUSE = 1005,
    S3E_SOCKET_ERR_NETDOWN = 1006,
    S3E_SOCKET_ERR_CONNRESET = 1007,
    S3E_SOCKET_ERR_ISCONN = 1008,
    S3E_SOCKET_ERR_NOTCONN = 1009,
    S3E_SOCKET_ERR_SHUTDOWN = 1010,
    S3E_SOCKET_ERR_TIMEDOUT = 1011,
    S3E_SOCKET_ERR_CONNREFUSED = 1012,
    S3E_SOCKET_ERR_UNKNOWN_HOST = 1013
} s3eSocketErrors;
# 333 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eSocketErrors s3eSocketGetError();
# 347 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" const char* s3eSocketGetErrorString();
# 360 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eInetAton(s3eInetIPAddress* result, const char* addr);
# 370 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" uint32 s3eInetNtohl(uint32 addr);
# 380 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" uint32 s3eInetHtonl(uint32 addr);
# 390 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" uint16 s3eInetNtohs(uint16 addr);
# 400 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" uint16 s3eInetHtons(uint16 addr);
# 413 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" char* s3eInetNtoa(s3eInetIPAddress addr, char* buf, int len);
# 423 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" const char* s3eInetToString(const s3eInetAddress* s);
# 447 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eInetLookup(const char* hostname, s3eInetAddress* addr, s3eCallback func, void* userData);




extern "C" void s3eInetLookupCancel();
# 469 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eSocket* s3eSocketCreate(s3eSocketType type, uint32 flags =0);
# 483 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketClose(s3eSocket* socket);
# 514 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketBind(s3eSocket* sock, const s3eInetAddress* addr, uint8 reuseAddress);
# 529 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketGetLocalName(s3eSocket* sock, s3eInetAddress* addr);
# 542 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketGetPeerName(s3eSocket* sock, s3eInetAddress* addr);
# 574 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketConnect(s3eSocket* sock, const s3eInetAddress* addr, s3eSocketCallbackFn func, void* userdata);
# 595 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketSend(s3eSocket* sock, const char* buf, uint32 len, int flags);
# 615 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketRecv(s3eSocket* sock, char* buf, uint32 len, int flags);
# 636 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketRecvFrom(s3eSocket* s, char* buf, uint32 len, int flags, s3eInetAddress* from);
# 661 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" int32 s3eSocketSendTo(s3eSocket* s, const char* buf, uint32 len, int flags, const s3eInetAddress* to);
# 681 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketListen(s3eSocket* s, uint16 backlog);
# 702 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eSocket* s3eSocketAccept(s3eSocket* s, s3eInetAddress* addr, s3eSocketCallbackFn callback, void* userdata);
# 716 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketReadable(s3eSocket* s, s3eSocketCallbackFn readable, void* userData);
# 729 "d:/marmalade/6.1/s3e/h/s3eSocket.h"
extern "C" s3eResult s3eSocketWritable(s3eSocket* s, s3eSocketCallbackFn writable, void* data);
# 35 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eSurface.h" 1
# 92 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
typedef enum s3eSurfacePixelType
{
    S3E_SURFACE_PIXEL_TYPE_RGB444 = 0x20 | 0x400 | 0x1,
    S3E_SURFACE_PIXEL_TYPE_RGB555 = 0x20 | 0x400 | 0x3,
    S3E_SURFACE_PIXEL_TYPE_RGB5551 = 0x20 | 0x400 | 0x6,
    S3E_SURFACE_PIXEL_TYPE_RGB565 = 0x20 | 0x400 | 0x2,
    S3E_SURFACE_PIXEL_TYPE_RGB666 = 0x40 | 0x400 | 0x4,
    S3E_SURFACE_PIXEL_TYPE_RGB888 = 0x40 | 0x400 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_RGB888_3B = 0x30 | 0x400 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_XRGB888 = 0x40 | 0x400 | 0x7,

    S3E_SURFACE_PIXEL_TYPE_BGR444 = 0x20 | 0x800 | 0x1,
    S3E_SURFACE_PIXEL_TYPE_BGR555 = 0x20 | 0x800 | 0x3,
    S3E_SURFACE_PIXEL_TYPE_BGR5551 = 0x20 | 0x800 | 0x6,
    S3E_SURFACE_PIXEL_TYPE_BGR565 = 0x20 | 0x800 | 0x2,
    S3E_SURFACE_PIXEL_TYPE_BGR666 = 0x40 | 0x800 | 0x4,
    S3E_SURFACE_PIXEL_TYPE_BGR888 = 0x40 | 0x800 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_BGR888_3B = 0x30 | 0x800 | 0x5,
    S3E_SURFACE_PIXEL_TYPE_XBGR888 = 0x40 | 0x800 | 0x7
} s3eSurfacePixelType;






typedef enum s3eSurfaceBlitDirection
{

    S3E_SURFACE_BLIT_DIR_NORMAL = 0,


    S3E_SURFACE_BLIT_DIR_ROT90 = 1,


    S3E_SURFACE_BLIT_DIR_ROT180 = 2,


    S3E_SURFACE_BLIT_DIR_ROT270 = 3,





    S3E_SURFACE_BLIT_DIR_NATIVE = 4
} s3eSurfaceBlitDirection;






typedef struct s3eSurfaceInfo
{

    uint32 m_Width;

    uint32 m_Height;

    uint32 m_Pitch;

    s3eSurfacePixelType m_PixelType;

    void* m_Data;
} s3eSurfaceInfo;




extern "C" void s3eSurfaceClear(uint8 r, uint8 g, uint8 b);






extern "C" void s3eSurfaceBlank(uint8 bitpattern);







typedef enum s3eSurfaceProperty
{






    S3E_SURFACE_WIDTH = 0,







    S3E_SURFACE_HEIGHT = 1,






    S3E_SURFACE_PITCH = 2,





    S3E_SURFACE_PIXEL_TYPE = 3,


    S3E_SURFACE_DEVICE_WIDTH = 4,


    S3E_SURFACE_DEVICE_HEIGHT = 5,


    S3E_SURFACE_DEVICE_PIXEL_TYPE = 6,





    S3E_SURFACE_DEVICE_PITCH = 7,







    S3E_SURFACE_BLIT_DIRECTION = 8,


    S3E_SURFACE_DISPLAY = 9,





    S3E_SURFACE_NUM_DISPLAYS = 10,
# 249 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_BLIT_DIRECTION = 11,
# 262 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_WIDTH_QUANTISED = 12,
# 275 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_HEIGHT_QUANTISED = 13,
# 291 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
    S3E_SURFACE_DEVICE_ORIENTATION_LOCK = 14
} s3eSurfaceProperty;
# 306 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" int32 s3eSurfaceGetInt(s3eSurfaceProperty property);
# 321 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
 extern "C" s3eResult s3eSurfaceSetInt(s3eSurfaceProperty property, int32 val);
# 332 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
typedef struct s3eSurfaceOrientation
{
    s3eBool m_OrientationChanged;
    uint32 m_Width;
    uint32 m_Height;
    s3eSurfaceBlitDirection m_DeviceBlitDirection;
    uint32 m_Pitch;
} s3eSurfaceOrientation;
# 349 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
typedef enum s3eSurfaceCallback
{
# 362 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
    S3E_SURFACE_COPYUP = 0,
# 375 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
    S3E_SURFACE_SCREENSIZE = 1,

    S3E_SURFACE_CALLBACK_MAX = 3
} s3eSurfaceCallback;
# 403 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
typedef struct s3eSurfaceCopyupInfo
{

    s3eSurfaceInfo m_SrcSurface;

    s3eSurfaceInfo m_DestSurface;

    uint32 m_X;

    uint32 m_Y;

    uint32 m_Width;

    uint32 m_Height;

    s3eSurfaceBlitDirection m_BlitDirection;
} s3eSurfaceCopyupInfo;
# 447 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceRegister(s3eSurfaceCallback cbid, s3eCallback fn, void* userData);
# 466 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceUnRegister(s3eSurfaceCallback cbid, s3eCallback fn);
# 475 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
typedef enum s3eSurfaceError
{
    S3E_SURFACE_ERR_NONE = 0,
    S3E_SURFACE_ERR_PARAM = 1,
    S3E_SURFACE_ERR_TOO_MANY = 2,
    S3E_SURFACE_ERR_ALREADY_REG = 3,
    S3E_SURFACE_ERR_NOT_FOUND = 4,
    S3E_SURFACE_ERR_DEVICE = 6,
    S3E_SURFACE_ERR_MEM = 8
} s3eSurfaceError;
# 497 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" s3eSurfaceError s3eSurfaceGetError();
# 511 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" const char* s3eSurfaceGetErrorString();
# 533 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" void* s3eSurfacePtr();
# 568 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceShow();
# 658 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceSetup(s3eSurfacePixelType pixelType, uint32 pitch =0, void* ptr =__null, s3eSurfaceBlitDirection blitDirection =S3E_SURFACE_BLIT_DIR_NORMAL);
# 686 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" void s3eSurfaceInvalidate(int32 x, int32 y, int32 dx, int32 dy);
# 700 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" uint32 s3eSurfaceConvertRGB(uint8 r, uint8 g, uint8 b);
# 719 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
extern "C" s3eResult s3eSurfaceSetDisplayID(uint32 id);
# 729 "d:/marmalade/6.1/s3e/h/s3eSurface.h"
typedef enum
{
    S3E_SURFACE_ORIENTATION_LOCK_MIN = 0,




    S3E_SURFACE_ORIENTATION_FREE = 0,






    S3E_SURFACE_PORTRAIT = 1,






    S3E_SURFACE_LANDSCAPE = 2,





    S3E_SURFACE_PORTRAIT_FIXED = 3,





    S3E_SURFACE_LANDSCAPE_FIXED = 4,

    S3E_SURFACE_ORIENTATION_LOCK_MAX = 4
} s3eSurfaceOrientationLock;
# 36 "d:/marmalade/6.1/s3e/h/s3e.h" 2

# 1 "d:/marmalade/6.1/s3e/h/s3eThread.h" 1
# 59 "d:/marmalade/6.1/s3e/h/s3eThread.h"
typedef enum s3eThreadError
{
    S3E_THREAD_ERR_NONE = 0,
    S3E_THREAD_ERR_PARAM = 1,
    S3E_THREAD_ERR_TOO_MANY = 2,
    S3E_THREAD_ERR_ALREADY = 3,
    S3E_THREAD_ERR_UNKNOWN = 9,
    S3E_THREAD_ERR_TIMEOUT = 1000,
    S3E_THREAD_ERR_WRONG_THREAD = 1001
} s3eThreadError;


typedef struct _s3eThread s3eThread;


typedef struct _s3eThreadLock s3eThreadLock;


typedef struct _s3eThreadSem s3eThreadSem;
# 94 "d:/marmalade/6.1/s3e/h/s3eThread.h"
typedef void* (*s3eThreadStartFunc)(void*);
typedef void (*s3eThreadCleanupHandler)();

extern "C" {





s3eBool s3eThreadAvailable();
# 117 "d:/marmalade/6.1/s3e/h/s3eThread.h"
const char* s3eThreadGetErrorString();
# 130 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eThreadError s3eThreadGetError();






int s3eThreadCount();
# 151 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eThread* s3eThreadCreate(s3eThreadStartFunc startRoutine, void* arg =__null, s3eThreadCleanupHandler cleanup =__null, int stackSize =0, void* stackPtr =0);




s3eThread* s3eThreadGetCurrent();




void s3eThreadExit(void* retval);
# 170 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadDetach(s3eThread* thread);
# 183 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadJoin(s3eThread* thread, void** result =__null);







s3eResult s3eThreadCancel(s3eThread* thread);
# 205 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eThreadLock* s3eThreadLockCreate();






s3eResult s3eThreadLockDestroy(s3eThreadLock* lock);
# 235 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadLockAcquire(s3eThreadLock* lock, int timeout =-1);
# 248 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadLockRelease(s3eThreadLock* lock);







s3eThreadSem* s3eThreadSemCreate(int initialValue);
# 268 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadSemDestroy(s3eThreadSem* sem);
# 286 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadSemWait(s3eThreadSem* sem, int timeout =-1);
# 301 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadSemPost(s3eThreadSem* sem);
# 314 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadSemGetValue(s3eThreadSem* sem, int* value);
# 333 "d:/marmalade/6.1/s3e/h/s3eThread.h"
s3eResult s3eThreadEnqueueCallback(s3eThread* thread, s3eCallback callback, void* userData);

}
# 38 "d:/marmalade/6.1/s3e/h/s3e.h" 2

# 1 "d:/marmalade/6.1/s3e/h/s3eTimer.h" 1
# 36 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
typedef enum s3eTimerProperty
{
    S3E_TIMER_RESOLUTION
} s3eTimerProperty;
# 48 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
typedef enum s3eTimerError
{
    S3E_TIMER_ERR_NONE = 0,
    S3E_TIMER_ERR_PARAM = 1,
    S3E_TIMER_ERR_TOO_MANY = 2,
    S3E_TIMER_ERR_ALREADY_REG = 3,
    S3E_TIMER_ERR_NOT_FOUND = 4,
    S3E_TIMER_ERR_UNAVAIL = 5
} s3eTimerError;
# 69 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" s3eTimerError s3eTimerGetError();
# 82 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" const char* s3eTimerGetErrorString();
# 98 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" int32 s3eTimerGetInt(s3eTimerProperty property);
# 112 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUST();
# 123 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetUSTNanoseconds();




extern "C" uint64 s3eTimerGetMs();





extern "C" int64 s3eTimerGetUTC();
# 143 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" int64 s3eTimerGetLocaltimeOffset(int64* when =__null);
# 175 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerSetTimer(uint32 ms, s3eCallback fn, void* userData);
# 196 "d:/marmalade/6.1/s3e/h/s3eTimer.h"
extern "C" s3eResult s3eTimerCancelTimer(s3eCallback fn, void* userData);
# 40 "d:/marmalade/6.1/s3e/h/s3e.h" 2

# 1 "d:/marmalade/6.1/s3e/h/s3eVersion.h" 1
# 42 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eVibra.h" 1
# 38 "d:/marmalade/6.1/s3e/h/s3eVibra.h"
typedef enum s3eVibraProperty
{





    S3E_VIBRA_AVAILABLE = 0,







    S3E_VIBRA_ENABLED = 1,





    S3E_VIBRA_THRESHOLD = 2
} s3eVibraProperty;
# 69 "d:/marmalade/6.1/s3e/h/s3eVibra.h"
typedef enum s3eVibraError
{
    S3E_VIBRA_ERR_NONE = 0,
    S3E_VIBRA_ERR_PARAM = 1,
    S3E_VIBRA_ERR_UNAVAIL = 5,
    S3E_VIBRA_ERR_DEVICE = 6,
    S3E_VIBRA_ERR_DISABLED = 1000
} s3eVibraError;
# 91 "d:/marmalade/6.1/s3e/h/s3eVibra.h"
extern "C" int32 s3eVibraGetInt(s3eVibraProperty property);
# 109 "d:/marmalade/6.1/s3e/h/s3eVibra.h"
extern "C" s3eResult s3eVibraSetInt(s3eVibraProperty property, int32 value);
# 122 "d:/marmalade/6.1/s3e/h/s3eVibra.h"
extern "C" s3eVibraError s3eVibraGetError();
# 135 "d:/marmalade/6.1/s3e/h/s3eVibra.h"
extern "C" const char* s3eVibraGetErrorString();
# 151 "d:/marmalade/6.1/s3e/h/s3eVibra.h"
extern "C" s3eResult s3eVibraVibrate(uint8 level, uint32 ms);






extern "C" void s3eVibraStop();
# 43 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eVideo.h" 1
# 80 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
typedef enum s3eVideoCodec
{







    S3E_VIDEO_CODEC_MPEG4 = 1,
# 98 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP = 2,





    S3E_VIDEO_CODEC_JPEG = 3,
# 113 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP_VIDEO_H263 = 4,
# 122 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP_VIDEO_H264 = 5,
# 131 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_3GPP_AUDIO_AMR = 6,







    S3E_VIDEO_CODEC_3GPP_AUDIO_AAC = 7,
# 148 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_MPEG4_VIDEO_MPEG4 = 8,
# 157 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_CODEC_MPEG4_VIDEO_H264 = 9,







    S3E_VIDEO_CODEC_MPEG4_AUDIO_AAC = 10,






    S3E_VIDEO_CODEC_SWF = 11
} s3eVideoCodec;






typedef enum s3eVideoStatus
{




    S3E_VIDEO_STOPPED = 0,




    S3E_VIDEO_PLAYING = 1,




    S3E_VIDEO_PAUSED = 2,
# 205 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_FAILED = 3
} s3eVideoStatus;
# 215 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
typedef enum s3eVideoProperty
{





    S3E_VIDEO_VOLUME = 0,





    S3E_VIDEO_STATUS = 1,





    S3E_VIDEO_POSITION = 2,
# 247 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_VOLUME_DEFAULT = 3,


    S3E_VIDEO_AVAILABLE = 5

} s3eVideoProperty;
# 267 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" int32 s3eVideoGetInt(s3eVideoProperty property);
# 286 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoSetInt(s3eVideoProperty property, int32 value);
# 296 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
typedef enum s3eVideoCallback
{
# 314 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
    S3E_VIDEO_STOP = 2,

    S3E_VIDEO_CALLBACK_MAX
} s3eVideoCallback;
# 339 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoRegister(s3eVideoCallback cbid, s3eCallback fn, void* userData);
# 357 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoUnRegister(s3eVideoCallback cbid, s3eCallback fn);
# 366 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
typedef enum s3eVideoError
{
    S3E_VIDEO_ERR_NONE = 0,
    S3E_VIDEO_ERR_PARAM = 1,
    S3E_VIDEO_ERR_TOO_MANY = 2,
    S3E_VIDEO_ERR_ALREADY_REG = 3,
    S3E_VIDEO_ERR_NOT_FOUND = 4,
    S3E_VIDEO_ERR_UNAVAIL = 5,
    S3E_VIDEO_ERR_DEVICE = 6,
    S3E_VIDEO_ERR_UNSUPPORTED = 7,
    S3E_VIDEO_ERR_MEM = 8,
    S3E_VIDEO_ERR_INVALID_DRIVE = 10,
    S3E_VIDEO_ERR_INVALID_PATH = 11,
    S3E_VIDEO_ERR_FILEFORMAT = 1000,
    S3E_VIDEO_ERR_WRONG_STATE = 1001
} s3eVideoError;
# 394 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eVideoError s3eVideoGetError();
# 408 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" const char* s3eVideoGetErrorString();
# 498 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoPlay(const char* filename, uint32 repeatCount =1, int32 x =0, int32 y =0, int32 width =0, int32 height =0);
# 572 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoPlayFromBuffer(void* data, uint32 len, uint32 repeatCount =1, int32 x =0, int32 y =0, int32 width =0, int32 height =0);
# 598 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoPause();
# 619 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eResult s3eVideoResume();
# 636 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" void s3eVideoStop();
# 648 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eBool s3eVideoIsPlaying();
# 672 "d:/marmalade/6.1/s3e/h/s3eVideo.h"
extern "C" s3eBool s3eVideoIsCodecSupported(s3eVideoCodec codec);







# 1 "d:/marmalade/6.1/s3e/h/legacy/s3eVideo_legacy.h" 1
# 681 "d:/marmalade/6.1/s3e/h/s3eVideo.h" 2
# 44 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eGL.h" 1
# 38 "d:/marmalade/6.1/s3e/h/s3eGL.h"
typedef enum s3eGLError
{
    S3E_GL_ERR_NONE = 0,
    S3E_GL_ERR_PARAM = 1,
    S3E_GL_ERR_TOO_MANY = 2,
    S3E_GL_ERR_ALREADY_REG = 3,
    S3E_GL_ERR_NOT_FOUND = 4,
    S3E_GL_ERR_UNAVAIL = 5,
} s3eGLError;






typedef enum s3eGLProperty
{





    S3E_GL_VERSION = 0,





    S3E_EGL_VERSION = 1,






    S3E_GL_MUST_SUSPEND = 2,

} s3eGLProperty;
# 87 "d:/marmalade/6.1/s3e/h/s3eGL.h"
extern "C" int32 s3eGLGetInt(s3eGLProperty property);
# 97 "d:/marmalade/6.1/s3e/h/s3eGL.h"
typedef enum s3eGLCallback
{
# 110 "d:/marmalade/6.1/s3e/h/s3eGL.h"
    S3E_GL_SUSPEND = 0,
# 122 "d:/marmalade/6.1/s3e/h/s3eGL.h"
    S3E_GL_RESUME = 1,

    S3E_GL_CALLBACK_MAX
} s3eGLCallback;
# 148 "d:/marmalade/6.1/s3e/h/s3eGL.h"
extern "C" s3eResult s3eGLRegister(s3eGLCallback cbid, s3eCallback fn, void* userdata);
# 168 "d:/marmalade/6.1/s3e/h/s3eGL.h"
extern "C" s3eResult s3eGLUnRegister(s3eGLCallback cbid, s3eCallback fn);
# 182 "d:/marmalade/6.1/s3e/h/s3eGL.h"
extern "C" s3eGLError s3eGLGetError();
# 196 "d:/marmalade/6.1/s3e/h/s3eGL.h"
extern "C" const char* s3eGLGetErrorString();
# 208 "d:/marmalade/6.1/s3e/h/s3eGL.h"
extern "C" void* s3eGLGetNativeWindow();
# 45 "d:/marmalade/6.1/s3e/h/s3e.h" 2
# 2 "c:/Users/dreambit/Documents/memorygame/src/main.cpp" 2
# 1 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h" 1
       
# 20 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eSurface.h" 1
# 21 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h" 2
# 1 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h" 1
       
# 21 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h" 1
       
# 16 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eTypes.h" 1
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 1
# 16 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eDebug.h" 1
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eDevice.h" 1
# 18 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwCore.h" 1
# 19 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 2


# 1 "d:/marmalade/6.1/s3e/h/std/stdarg.h" 1
# 15 "d:/marmalade/6.1/s3e/h/std/stdarg.h"
# 1 "d:/marmalade/6.1/s3e/h/std/sys/types.h" 1
# 16 "d:/marmalade/6.1/s3e/h/std/sys/types.h"
# 1 "d:/marmalade/6.1/s3e/h/std/stddef.h" 1
# 15 "d:/marmalade/6.1/s3e/h/std/stddef.h"
typedef signed int ptrdiff_t;


    typedef unsigned int wint_t;
    typedef unsigned long int wctype_t;







typedef unsigned int size_t;
# 17 "d:/marmalade/6.1/s3e/h/std/sys/types.h" 2
# 1 "d:/marmalade/6.1/s3e/h/std/stdint.h" 1
# 19 "d:/marmalade/6.1/s3e/h/std/stdint.h"
typedef signed char int_least8_t;
typedef short int_least16_t;
typedef long int_least32_t;
typedef int64_t int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned long uint_least32_t;
typedef uint64_t uint_least64_t;

typedef signed char int_fast8_t;
typedef short int_fast16_t;
typedef long int_fast32_t;
typedef int64_t int_fast64_t;

typedef unsigned char uint_fast8_t;
typedef unsigned short uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef uint64_t uint_fast64_t;

typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
# 18 "d:/marmalade/6.1/s3e/h/std/sys/types.h" 2
# 1 "d:/marmalade/6.1/s3e/h/std/sys/select.h" 1
# 24 "d:/marmalade/6.1/s3e/h/std/sys/select.h"
struct timeval;

typedef struct fd_set
{
    char fds_bits[256/8];
} fd_set;
# 39 "d:/marmalade/6.1/s3e/h/std/sys/select.h"
extern "C" {

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

}
# 19 "d:/marmalade/6.1/s3e/h/std/sys/types.h" 2



typedef long off_t;

typedef int64_t off64_t;


namespace std
{
typedef ::size_t size_t;
}


typedef uint u_int;
typedef uint8_t u_int8_t;
typedef uint16_t u_int16_t;
typedef uint32_t u_int32_t;
typedef uint64_t u_int64_t;

typedef unsigned short u_short;
typedef unsigned long u_long;
typedef unsigned char u_char;

typedef int ssize_t;
typedef int pid_t;
typedef short uid_t;
typedef short gid_t;
typedef int idtype_t;
typedef int id_t;
typedef uint32 mode_t;
typedef short dev_t;
typedef short ino_t;
typedef int key_t;
typedef void* caddr_t;
# 16 "d:/marmalade/6.1/s3e/h/std/stdarg.h" 2
# 54 "d:/marmalade/6.1/s3e/h/std/stdarg.h"
typedef __builtin_va_list va_list;
# 22 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 2
# 1 "d:/marmalade/6.1/s3e/h/std/stdio.h" 1
# 19 "d:/marmalade/6.1/s3e/h/std/stdio.h"
struct __XXFILE;
typedef struct __XXFILE FILE;

typedef uint32 fpos_t;
# 38 "d:/marmalade/6.1/s3e/h/std/stdio.h"
extern "C" {
# 54 "d:/marmalade/6.1/s3e/h/std/stdio.h"
extern FILE *__aeabi_stdin;
extern FILE *__aeabi_stdout;
extern FILE *__aeabi_stderr;
# 66 "d:/marmalade/6.1/s3e/h/std/stdio.h"
FILE *fopen(const char *path, const char *mode);
int fclose(FILE *fp);
int fcloseall();
int fflush(FILE *stream);

FILE *fopen(const char *path, const char *mode);
FILE *fdopen(int fildes, const char *mode);
FILE *freopen(const char *path, const char *mode, FILE *stream);

size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

int fputc(int c, FILE *stream);
int fputs(const char *s, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
int puts(const char *s);

int fgetc(FILE *stream);
char *fgets(char *s, int size, FILE *stream);
int getc(FILE *stream);
int getchar(void);
char *gets(char *s);
int ungetc(int c, FILE *stream);

int fseek(FILE *stream, long offset, int whence);
long ftell(FILE *stream);
void rewind(FILE *stream);
int fgetpos(FILE *stream, fpos_t *pos);
int fsetpos(FILE *stream, fpos_t *pos);

void flockfile(FILE *filehandle);
int ftrylockfile(FILE *filehandle);
void funlockfile(FILE *filehandle);

int getc_unlocked(FILE *stream);
int getchar_unlocked(void);
int putc_unlocked(int c, FILE *stream);
int putchar_unlocked(int c);

FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);

char *tempnam(const char *dir, const char *pfx);




int printf(const char *format, ...) __attribute__((format(printf, 1, 2)));



int fprintf(FILE *stream, const char* format, ...) __attribute__((format(printf, 2, 3)));



int sprintf(char *str, const char* format, ...) __attribute__((format(printf, 2, 3)));



int snprintf(char *str, size_t size, const char *format, ...) __attribute__((format(printf, 3, 4)));




int scanf(const char *format, ...);



int fscanf(FILE *stream, const char *format, ...);



int sscanf(const char *str, const char *format, ...);

void clearerr(FILE *stream);
int feof(FILE *stream);
int ferror(FILE *stream);
int fileno(FILE *stream);

int remove(const char *pathname);
int rename(const char *oldpath, const char *newpath);

void perror(const char *s);



FILE *tmpfile(void);
char *tmpnam(char *s);

void setbuf(FILE *stream, char *buf);
void setbuffer(FILE *stream, char *buf, size_t size);
void setlinebuf(FILE *stream);
int setvbuf(FILE *stream, char *buf, int mode , size_t size);



int vfprintf(FILE *stream, const char *format, va_list ap);
int vsprintf(char *str, const char *format, va_list ap);
int vsnprintf(char *str, size_t size, const char *format, va_list ap);
int vprintf(const char *format, va_list ap);
int asprintf(char **strp, const char *fmt, ...);
int vasprintf(char **strp, const char *fmt, va_list ap);

int vscanf(const char *format, va_list ap);
int vsscanf(const char *str, const char *format, va_list ap);
int vfscanf(FILE *stream, const char *format, va_list ap);

}
# 23 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 2
# 1 "d:/marmalade/6.1/s3e/h/std/stdlib.h" 1
# 16 "d:/marmalade/6.1/s3e/h/std/stdlib.h"
# 1 "d:/marmalade/6.1/s3e/h/std/malloc.h" 1
# 16 "d:/marmalade/6.1/s3e/h/std/malloc.h"
# 1 "d:/marmalade/6.1/s3e/h/std/alloca.h" 1
# 17 "d:/marmalade/6.1/s3e/h/std/alloca.h"
extern "C" {


    extern void *alloca(size_t __size);
# 35 "d:/marmalade/6.1/s3e/h/std/alloca.h"
}
# 17 "d:/marmalade/6.1/s3e/h/std/malloc.h" 2

extern "C" {

void *calloc(size_t nmemb, size_t size);
void *malloc(size_t size);
void free(void *ptr);
void *realloc(void *ptr, size_t size);

}
# 17 "d:/marmalade/6.1/s3e/h/std/stdlib.h" 2
# 28 "d:/marmalade/6.1/s3e/h/std/stdlib.h"
extern "C" {

double atof(const char* string);
int atoi(const char *nptr);
long atol(const char *nptr);
int64_t atoll(const char *nptr);
int64_t atoq(const char *nptr);
int abs(int j);
long int labs(long int j);
int64_t llabs(int64_t j);
void qsort(void *base, size_t nmemb, size_t size, int(*compar)(const void *, const void *));
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
void abort(void);
int putenv(char *string);
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
int unsetenv(const char *name);
void exit(int status) __attribute__ ((noreturn));
void _exit(int status) __attribute__ ((noreturn));
void _Exit(int status) __attribute__ ((noreturn));
unsigned long int strtoul(const char *nptr, char **endptr, int base);
uint64_t strtoull(const char *nptr, char **endptr, int base);
long int strtol(const char *nptr, char **endptr, int base);
int64_t strtoll(const char *nptr, char **endptr, int base);
double strtod(const char *nptr, char **endptr);
float strtof(const char *nptr, char **endptr);
long double strtold(const char *nptr, char **endptr);
int atexit(void (*function)(void));
int system(const char *command);
int posix_memalign(void **memptr, size_t alignment, size_t size);
char *mktemp(char *templ);
int mkstemp(char *templ);



int rand(void);
void srand(unsigned int seed);

long int random(void);
void srandom(unsigned int seed);

size_t __ctype_get_mb_cur_max();


int mblen(const char *s, size_t n);
int mbtowc(wchar_t *pwc, const char *s, size_t n);
int wctomb(char *s, wchar_t wc);
size_t mbstowcs(wchar_t *dest, const char *src, size_t n);
size_t wcstombs(char *dest, const wchar_t *src, size_t n);

typedef struct
{
    int quot;
    int rem;
} div_t;

typedef struct
{
    int quot;
    int rem;
} ldiv_t;

typedef struct
{
    int64_t quot;
    int64_t rem;
} lldiv_t;

div_t div(int numerator, int denominator);
ldiv_t ldiv(long numerator, long denominator);
lldiv_t lldiv(int64_t numerator, int64_t denominator);
# 112 "d:/marmalade/6.1/s3e/h/std/stdlib.h"
}
# 24 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 2
# 51 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
typedef void(*IwAssertTextCallback)(char* pBuffer);

extern "C" {

typedef s3eErrorShowResult(*IwAssertCallback)(const char* channel, const char* pExpr, const char* pFilename, int32 line, const char* message);
typedef s3eErrorShowResult(*IwErrorCallback)(const char* message);
# 65 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceIsChannelOn(const char* channel, s3eBool default_on);
# 91 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
 s3eBool IwDebugTraceChannelSwitch(const char* channel, s3eBool new_state);
# 101 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
 void IwDebugTraceLinePrintf(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;






 void IwDebugTraceLineVPrintf(const char* fmt, va_list args);


 void IwDebugAssertSetUID(uint32 n);







 s3eBool IwDebugAssertIsChannelOn(const char* channel);







 void IwDebugClearConfigCache();
# 141 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
 void IwDebugAssertSetMessage(const char* fmt, ...)

__attribute__((format(printf, 1, 2)))

;
# 168 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
 s3eErrorShowResult IwDebugAssertShow(const char* pExpr, const char* pFilename, int32 line, uint8 ignorable);






 IwAssertTextCallback IwAssertRegisterTextCallback(IwAssertTextCallback fn);






 IwAssertCallback IwAssertRegisterCallback(IwAssertCallback fn);
# 192 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
 s3eErrorShowResult IwDebugErrorShow(const char* Args, ...)

__attribute__((format(printf, 1, 2)))

;






 IwErrorCallback IwDebugErrorRegisterCallback(IwErrorCallback fn);

}
# 582 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
template <class _To, class _From>
_To IwSafeCast(_From from)
{
# 595 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h"
    return static_cast <_To> (from);
}
# 18 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h" 2
# 1 "d:/marmalade/6.1/s3e/h/s3eFile.h" 1
# 19 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h" 2

class CIwManaged;
class CIwTextParserITX;
# 39 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
typedef void(*IwSerialiseUserCallback)();





struct IwSerialiseContext
{
    bool read;
    uint32 base;
    s3eFile* handle;
    char filename[160];
    uint32 bytesRead;
    uint32 callbackPeriod;
    uint8 buffer[8];
    int32 headBit;
    uint32 version;
    uint16 versionUser;
    uint16 pad;
    IwSerialiseUserCallback callback;
};
extern IwSerialiseContext g_IwSerialiseContext;
extern int g_IwSerialiseContextValid;
# 76 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
enum IwSerialiseMode
{
    IW_SERIALISE_WRITE = 0,
    IW_SERIALISE_READ = 1
};
# 89 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsReading() {return g_IwSerialiseContext.read == true;}
# 98 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline bool IwSerialiseIsWriting() {return g_IwSerialiseContext.read == false;}
# 109 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseSetUserVersion(uint16 v) {g_IwSerialiseContext.versionUser = v;}
# 118 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline uint16 IwSerialiseGetUserVersion() {return g_IwSerialiseContext.versionUser;}







static inline bool IwIsSerialiseOpen(){return (g_IwSerialiseContextValid > 0);}
# 135 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpen(const char* filename, IwSerialiseMode mode, bool ram=false);
# 145 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseOpen(const char* filename, bool read, bool ram=false)
{
    IwSerialiseOpen(filename, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE, ram);
}






bool IwSerialiseExists(const char* filename, bool ram=false);







bool IwSerialiseEOF();
# 173 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseOpenFromMemory(void* pBuffer, int size, IwSerialiseMode mode);







static inline void IwSerialiseOpenFromMemory(void* pBuffer, int size, bool read)
{
    IwSerialiseOpenFromMemory(pBuffer, size, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}






void IwSerialiseClose();






void IwSerialiseResetCallbackCount();






void IwSerialiseSetCallbackPeriod(uint32 p);






void IwSerialiseSetCallback(IwSerialiseUserCallback cb);
# 221 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void _SerialiseScalarType(IwSerialiseContext& c, void* var, int itemSize, int numItems)
{

    if (c.read == true)
        s3eFileRead(var, itemSize, numItems, c.handle);
    else
        s3eFileWrite(var, itemSize, numItems, c.handle);
# 249 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
}
# 260 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseDouble(double& var, int n=1, int numBits=sizeof(double)*8, int stride=sizeof(double));
# 271 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFloat(float& var, int n=1, int numBits=sizeof(float)*8, int stride=sizeof(float));
# 282 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt64(uint64& var, int n=1, int numBits=sizeof(uint64)*8, int stride=sizeof(uint64));
# 293 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt64(int64& var, int n=1, int numBits=sizeof(int64)*8-1, int stride=sizeof(int64));
# 305 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt32(uint32& var, int n=1, int numBits=sizeof(uint32)*8, int stride=sizeof(uint32));
# 316 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt32(int32& var, int n=1, int numBits=sizeof(int32)*8-1, int stride=sizeof(int32));
# 327 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt16(uint16& var, int n=1, int numBits=sizeof(uint16)*8, int stride=sizeof(uint16));
# 338 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt16(int16& var, int n=1, int numBits=sizeof(int16)*8-1, int stride=sizeof(int16));
# 349 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseUInt8(uint8& var, int n=1, int numBits=sizeof(uint8)*8, int stride=sizeof(uint8));
# 360 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseInt8(int8& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(int8));
# 371 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseChar(char& var, int n=1, int numBits=sizeof(int8)*8-1, int stride=sizeof(char));
# 382 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseBool(bool& var, int n=1, int numBits=1, int stride=sizeof(bool));
# 392 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseEnum(void* pVar);





template <class T, bool SGN>
void _IwSerialiseBitDepthRequired(T& var, int n, int stride, void(*CB1)(T&, int, int, int))
{

    uint32 mb;
    if (g_IwSerialiseContext.read == false)
    {
        T* pVal = &var;
        uint32 t = n;
        mb = 1;
        while(t-- && (mb < sizeof(T)*8))
        {
            T v = *pVal;
            pVal += stride / sizeof(T);
            if (SGN)
            {
                if (v & (1ul << ((sizeof(T)*8) - 1)))
                    v = ~v;
            }
            while((v >= ((T)1 << mb)) && (mb < sizeof(T)*8))
                mb++;
        }
    }

    IwSerialiseUInt32(mb, 1, 6);
    (CB1)(var, n, mb, stride);



}
# 440 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseCharBitDepthRequired(char& var, int n=1, int stride=sizeof(char))
{
    _IwSerialiseBitDepthRequired<char, true>(var, n, stride, IwSerialiseChar);
}
# 456 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt8BitDepthRequired(int8& var, int n=1, int stride=sizeof(int8))
{
    _IwSerialiseBitDepthRequired<int8, true>(var, n, stride, IwSerialiseInt8);
}
# 472 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt8BitDepthRequired(uint8& var, int n=1, int stride=sizeof(uint8))
{
    _IwSerialiseBitDepthRequired<uint8, false>(var, n, stride, IwSerialiseUInt8);
}
# 488 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt16BitDepthRequired(int16& var, int n=1, int stride=sizeof(int16))
{
    _IwSerialiseBitDepthRequired<int16, true>(var, n, stride, IwSerialiseInt16);
}
# 504 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt16BitDepthRequired(uint16& var, int n=1, int stride=sizeof(uint16))
{
    _IwSerialiseBitDepthRequired<uint16, false>(var, n, stride, IwSerialiseUInt16);
}
# 520 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseInt32BitDepthRequired(int32& var, int n=1, int stride=sizeof(int32))
{
    _IwSerialiseBitDepthRequired<int32, true>(var, n, stride, IwSerialiseInt32);
}
# 536 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseUInt32BitDepthRequired(uint32& var, int n=1, int stride=sizeof(uint32))
{
    _IwSerialiseBitDepthRequired<uint32, false>(var, n, stride, IwSerialiseUInt32);
}
# 591 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseMappedData(const uint16* pMap, void* _pData, int numStructs, int stride);
# 602 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseString(char* text, int maxLen=0);
# 615 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseManagedHash(void* pptr);






void IwSerialiseManagedObject(CIwManaged*& pObj);
# 633 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, IwSerialiseMode mode);
# 642 "d:/marmalade/6.1/modules/iwutil/h/IwSerialise.h"
static inline void IwSerialiseFile(CIwTextParserITX* pParser, char const* filename, void* pptr, bool read)
{
    IwSerialiseFile(pParser, filename, pptr, read ? IW_SERIALISE_READ : IW_SERIALISE_WRITE);
}
# 22 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwMath.h" 1
# 16 "d:/marmalade/6.1/modules/iwutil/h/IwMath.h"
# 1 "d:/marmalade/6.1/s3e/h/std/float.h" 1
# 31 "d:/marmalade/6.1/s3e/h/std/float.h"
  extern "C" {
# 109 "d:/marmalade/6.1/s3e/h/std/float.h"
extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}
# 150 "d:/marmalade/6.1/s3e/h/std/float.h"
    }
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwMath.h" 2
# 87 "d:/marmalade/6.1/modules/iwutil/h/IwMath.h"
static inline int32 IwRoundFraction(double aValue)
{
    double lPositive = (aValue < 0.0f) ? -aValue : aValue;
    double lDecimal = lPositive - (double) ((int32) lPositive);
    int32 lRetVal;

    if (aValue < 0.0f)
    {
        if (lDecimal >= 0.5f)
        {
            lRetVal = ((int32) aValue) - 1;
        }
        else
        {
            lRetVal = (int32) aValue;
        }
    }
    else
    {
        if (lDecimal >= 0.5f)
        {
            lRetVal = ((int32) aValue) + 1;
        }
        else
        {
            lRetVal = (int32) aValue;
        }
    }
    return lRetVal;
}







static inline uint8 iwlzc(uint32 a)
{
    uint8 r=0;
    if ((a >> 16) == 0) {r+=16; a<<=16;}
    if ((a >> 24) == 0) {r+=8; a<<=8;}
    if ((a >> 28) == 0) {r+=4; a<<=4;}
    if ((a >> 30) == 0) {r+=2; a<<=2;}
    if ((a >> 31) == 0) {r+=1;}
    return r;
}






static inline uint8 iwlog2(uint32 a)
{
    return (uint8)(31-iwlzc(a));
}
# 158 "d:/marmalade/6.1/modules/iwutil/h/IwMath.h"
static inline uint32 clz(uint32 a)
{

    int32 r=0;
    if ((a >> 16) == 0) {r+=16; a<<=16;}
    if ((a >> 24) == 0) {r+=8; a<<=8;}
    if ((a >> 28) == 0) {r+=4; a<<=4;}
    if ((a >> 30) == 0) {r+=2; a<<=2;}
    if ((a >> 31) == 0) {r+=1;}
    return r;
}
# 23 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h" 2

# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h" 1
       
# 18 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwDebug.h" 1
# 19 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwDivide.h" 1
# 78 "d:/marmalade/6.1/modules/iwutil/h/IwDivide.h"
static inline uint64 i3d_uldiv_split(uint32 toplo, uint32 tophi, uint32 bottom)
{
    unsigned accumhi = 0;
    unsigned accumlo = 0;


    int i=31;




    if(tophi & 0xffff0000)
        i -= 16;
    if(tophi==0)
        i=0;

    for (; i>=0; i--)
    {
        accumhi = accumhi << 1;

        if ((tophi>>(i)) >= (bottom))
        {
            accumhi++;


            tophi = tophi - (bottom<<i);
        }
    }
# 125 "d:/marmalade/6.1/modules/iwutil/h/IwDivide.h"
    if (tophi==0) goto fast_bit32;

    accumlo = accumlo << 1; if ((toplo>>31)+(tophi<<(32-31)) >= (bottom) || (tophi>>31)!=0) { accumlo++; if ((bottom<<31) > toplo) tophi--; toplo = toplo - (bottom<<31); tophi = tophi - (bottom>>(32-31)); if (!tophi) goto fast_bit31; }
    accumlo = accumlo << 1; if ((toplo>>30)+(tophi<<(32-30)) >= (bottom) || (tophi>>30)!=0) { accumlo++; if ((bottom<<30) > toplo) tophi--; toplo = toplo - (bottom<<30); tophi = tophi - (bottom>>(32-30)); if (!tophi) goto fast_bit30; }
    accumlo = accumlo << 1; if ((toplo>>29)+(tophi<<(32-29)) >= (bottom) || (tophi>>29)!=0) { accumlo++; if ((bottom<<29) > toplo) tophi--; toplo = toplo - (bottom<<29); tophi = tophi - (bottom>>(32-29)); if (!tophi) goto fast_bit29; }
    accumlo = accumlo << 1; if ((toplo>>28)+(tophi<<(32-28)) >= (bottom) || (tophi>>28)!=0) { accumlo++; if ((bottom<<28) > toplo) tophi--; toplo = toplo - (bottom<<28); tophi = tophi - (bottom>>(32-28)); if (!tophi) goto fast_bit28; }
    accumlo = accumlo << 1; if ((toplo>>27)+(tophi<<(32-27)) >= (bottom) || (tophi>>27)!=0) { accumlo++; if ((bottom<<27) > toplo) tophi--; toplo = toplo - (bottom<<27); tophi = tophi - (bottom>>(32-27)); if (!tophi) goto fast_bit27; }
    accumlo = accumlo << 1; if ((toplo>>26)+(tophi<<(32-26)) >= (bottom) || (tophi>>26)!=0) { accumlo++; if ((bottom<<26) > toplo) tophi--; toplo = toplo - (bottom<<26); tophi = tophi - (bottom>>(32-26)); if (!tophi) goto fast_bit26; }
    accumlo = accumlo << 1; if ((toplo>>25)+(tophi<<(32-25)) >= (bottom) || (tophi>>25)!=0) { accumlo++; if ((bottom<<25) > toplo) tophi--; toplo = toplo - (bottom<<25); tophi = tophi - (bottom>>(32-25)); if (!tophi) goto fast_bit25; }
    accumlo = accumlo << 1; if ((toplo>>24)+(tophi<<(32-24)) >= (bottom) || (tophi>>24)!=0) { accumlo++; if ((bottom<<24) > toplo) tophi--; toplo = toplo - (bottom<<24); tophi = tophi - (bottom>>(32-24)); if (!tophi) goto fast_bit24; }
    accumlo = accumlo << 1; if ((toplo>>23)+(tophi<<(32-23)) >= (bottom) || (tophi>>23)!=0) { accumlo++; if ((bottom<<23) > toplo) tophi--; toplo = toplo - (bottom<<23); tophi = tophi - (bottom>>(32-23)); if (!tophi) goto fast_bit23; }
    accumlo = accumlo << 1; if ((toplo>>22)+(tophi<<(32-22)) >= (bottom) || (tophi>>22)!=0) { accumlo++; if ((bottom<<22) > toplo) tophi--; toplo = toplo - (bottom<<22); tophi = tophi - (bottom>>(32-22)); if (!tophi) goto fast_bit22; }
    accumlo = accumlo << 1; if ((toplo>>21)+(tophi<<(32-21)) >= (bottom) || (tophi>>21)!=0) { accumlo++; if ((bottom<<21) > toplo) tophi--; toplo = toplo - (bottom<<21); tophi = tophi - (bottom>>(32-21)); if (!tophi) goto fast_bit21; }
    accumlo = accumlo << 1; if ((toplo>>20)+(tophi<<(32-20)) >= (bottom) || (tophi>>20)!=0) { accumlo++; if ((bottom<<20) > toplo) tophi--; toplo = toplo - (bottom<<20); tophi = tophi - (bottom>>(32-20)); if (!tophi) goto fast_bit20; }
    accumlo = accumlo << 1; if ((toplo>>19)+(tophi<<(32-19)) >= (bottom) || (tophi>>19)!=0) { accumlo++; if ((bottom<<19) > toplo) tophi--; toplo = toplo - (bottom<<19); tophi = tophi - (bottom>>(32-19)); if (!tophi) goto fast_bit19; }
    accumlo = accumlo << 1; if ((toplo>>18)+(tophi<<(32-18)) >= (bottom) || (tophi>>18)!=0) { accumlo++; if ((bottom<<18) > toplo) tophi--; toplo = toplo - (bottom<<18); tophi = tophi - (bottom>>(32-18)); if (!tophi) goto fast_bit18; }
    accumlo = accumlo << 1; if ((toplo>>17)+(tophi<<(32-17)) >= (bottom) || (tophi>>17)!=0) { accumlo++; if ((bottom<<17) > toplo) tophi--; toplo = toplo - (bottom<<17); tophi = tophi - (bottom>>(32-17)); if (!tophi) goto fast_bit17; }
    accumlo = accumlo << 1; if ((toplo>>16)+(tophi<<(32-16)) >= (bottom) || (tophi>>16)!=0) { accumlo++; if ((bottom<<16) > toplo) tophi--; toplo = toplo - (bottom<<16); tophi = tophi - (bottom>>(32-16)); if (!tophi) goto fast_bit16; }
    accumlo = accumlo << 1; if ((toplo>>15)+(tophi<<(32-15)) >= (bottom) || (tophi>>15)!=0) { accumlo++; if ((bottom<<15) > toplo) tophi--; toplo = toplo - (bottom<<15); tophi = tophi - (bottom>>(32-15)); if (!tophi) goto fast_bit15; }
    accumlo = accumlo << 1; if ((toplo>>14)+(tophi<<(32-14)) >= (bottom) || (tophi>>14)!=0) { accumlo++; if ((bottom<<14) > toplo) tophi--; toplo = toplo - (bottom<<14); tophi = tophi - (bottom>>(32-14)); if (!tophi) goto fast_bit14; }
    accumlo = accumlo << 1; if ((toplo>>13)+(tophi<<(32-13)) >= (bottom) || (tophi>>13)!=0) { accumlo++; if ((bottom<<13) > toplo) tophi--; toplo = toplo - (bottom<<13); tophi = tophi - (bottom>>(32-13)); if (!tophi) goto fast_bit13; }
    accumlo = accumlo << 1; if ((toplo>>12)+(tophi<<(32-12)) >= (bottom) || (tophi>>12)!=0) { accumlo++; if ((bottom<<12) > toplo) tophi--; toplo = toplo - (bottom<<12); tophi = tophi - (bottom>>(32-12)); if (!tophi) goto fast_bit12; }
    accumlo = accumlo << 1; if ((toplo>>11)+(tophi<<(32-11)) >= (bottom) || (tophi>>11)!=0) { accumlo++; if ((bottom<<11) > toplo) tophi--; toplo = toplo - (bottom<<11); tophi = tophi - (bottom>>(32-11)); if (!tophi) goto fast_bit11; }
    accumlo = accumlo << 1; if ((toplo>>10)+(tophi<<(32-10)) >= (bottom) || (tophi>>10)!=0) { accumlo++; if ((bottom<<10) > toplo) tophi--; toplo = toplo - (bottom<<10); tophi = tophi - (bottom>>(32-10)); if (!tophi) goto fast_bit10; }
    accumlo = accumlo << 1; if ((toplo>>9)+(tophi<<(32-9)) >= (bottom) || (tophi>>9)!=0) { accumlo++; if ((bottom<<9) > toplo) tophi--; toplo = toplo - (bottom<<9); tophi = tophi - (bottom>>(32-9)); if (!tophi) goto fast_bit9; }
    accumlo = accumlo << 1; if ((toplo>>8)+(tophi<<(32-8)) >= (bottom) || (tophi>>8)!=0) { accumlo++; if ((bottom<<8) > toplo) tophi--; toplo = toplo - (bottom<<8); tophi = tophi - (bottom>>(32-8)); if (!tophi) goto fast_bit8; }
    accumlo = accumlo << 1; if ((toplo>>7)+(tophi<<(32-7)) >= (bottom) || (tophi>>7)!=0) { accumlo++; if ((bottom<<7) > toplo) tophi--; toplo = toplo - (bottom<<7); tophi = tophi - (bottom>>(32-7)); if (!tophi) goto fast_bit7; }
    accumlo = accumlo << 1; if ((toplo>>6)+(tophi<<(32-6)) >= (bottom) || (tophi>>6)!=0) { accumlo++; if ((bottom<<6) > toplo) tophi--; toplo = toplo - (bottom<<6); tophi = tophi - (bottom>>(32-6)); if (!tophi) goto fast_bit6; }
    accumlo = accumlo << 1; if ((toplo>>5)+(tophi<<(32-5)) >= (bottom) || (tophi>>5)!=0) { accumlo++; if ((bottom<<5) > toplo) tophi--; toplo = toplo - (bottom<<5); tophi = tophi - (bottom>>(32-5)); if (!tophi) goto fast_bit5; }
    accumlo = accumlo << 1; if ((toplo>>4)+(tophi<<(32-4)) >= (bottom) || (tophi>>4)!=0) { accumlo++; if ((bottom<<4) > toplo) tophi--; toplo = toplo - (bottom<<4); tophi = tophi - (bottom>>(32-4)); if (!tophi) goto fast_bit4; }
    accumlo = accumlo << 1; if ((toplo>>3)+(tophi<<(32-3)) >= (bottom) || (tophi>>3)!=0) { accumlo++; if ((bottom<<3) > toplo) tophi--; toplo = toplo - (bottom<<3); tophi = tophi - (bottom>>(32-3)); if (!tophi) goto fast_bit3; }
    accumlo = accumlo << 1; if ((toplo>>2)+(tophi<<(32-2)) >= (bottom) || (tophi>>2)!=0) { accumlo++; if ((bottom<<2) > toplo) tophi--; toplo = toplo - (bottom<<2); tophi = tophi - (bottom>>(32-2)); if (!tophi) goto fast_bit2; }
    accumlo = accumlo << 1; if ((toplo>>1)+(tophi<<(32-1)) >= (bottom) || (tophi>>1)!=0) { accumlo++; if ((bottom<<1) > toplo) tophi--; toplo = toplo - (bottom<<1); tophi = tophi - (bottom>>(32-1)); if (!tophi) goto fast_bit1; }
    accumlo = accumlo << 1; if ((toplo>>0) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<0); }

    return (uint64)accumlo | ((uint64)accumhi)<<32;

fast_bit32:
    accumlo = accumlo << 1; if ((toplo>>31) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<31); } fast_bit31:
    accumlo = accumlo << 1; if ((toplo>>30) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<30); } fast_bit30:
    accumlo = accumlo << 1; if ((toplo>>29) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<29); } fast_bit29:
    accumlo = accumlo << 1; if ((toplo>>28) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<28); } fast_bit28:
    accumlo = accumlo << 1; if ((toplo>>27) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<27); } fast_bit27:
    accumlo = accumlo << 1; if ((toplo>>26) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<26); } fast_bit26:
    accumlo = accumlo << 1; if ((toplo>>25) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<25); } fast_bit25:
    accumlo = accumlo << 1; if ((toplo>>24) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<24); } fast_bit24:
    accumlo = accumlo << 1; if ((toplo>>23) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<23); } fast_bit23:
    accumlo = accumlo << 1; if ((toplo>>22) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<22); } fast_bit22:
    accumlo = accumlo << 1; if ((toplo>>21) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<21); } fast_bit21:
    accumlo = accumlo << 1; if ((toplo>>20) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<20); } fast_bit20:
    accumlo = accumlo << 1; if ((toplo>>19) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<19); } fast_bit19:
    accumlo = accumlo << 1; if ((toplo>>18) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<18); } fast_bit18:
    accumlo = accumlo << 1; if ((toplo>>17) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<17); } fast_bit17:
    accumlo = accumlo << 1; if ((toplo>>16) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<16); } fast_bit16:
    accumlo = accumlo << 1; if ((toplo>>15) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<15); } fast_bit15:
    accumlo = accumlo << 1; if ((toplo>>14) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<14); } fast_bit14:
    accumlo = accumlo << 1; if ((toplo>>13) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<13); } fast_bit13:
    accumlo = accumlo << 1; if ((toplo>>12) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<12); } fast_bit12:
    accumlo = accumlo << 1; if ((toplo>>11) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<11); } fast_bit11:
    accumlo = accumlo << 1; if ((toplo>>10) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<10); } fast_bit10:
    accumlo = accumlo << 1; if ((toplo>>9) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<9); } fast_bit9:
    accumlo = accumlo << 1; if ((toplo>>8) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<8); } fast_bit8:
    accumlo = accumlo << 1; if ((toplo>>7) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<7); } fast_bit7:
    accumlo = accumlo << 1; if ((toplo>>6) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<6); } fast_bit6:
    accumlo = accumlo << 1; if ((toplo>>5) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<5); } fast_bit5:
    accumlo = accumlo << 1; if ((toplo>>4) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<4); } fast_bit4:
    accumlo = accumlo << 1; if ((toplo>>3) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<3); } fast_bit3:
    accumlo = accumlo << 1; if ((toplo>>2) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<2); } fast_bit2:
    accumlo = accumlo << 1; if ((toplo>>1) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<1); } fast_bit1:
    accumlo = accumlo << 1; if ((toplo>>0) >= (bottom)) { accumlo++; toplo = toplo - (bottom<<0); }
# 224 "d:/marmalade/6.1/modules/iwutil/h/IwDivide.h"
    return (uint64)accumlo | ((uint64)accumhi)<<32;
}

static inline uint64 i3d_ldiv_split(uint32 toplo, int32 tophi, int32 bottom)
{
    if(tophi<0) {
        if(bottom>0)
            return -(int64)i3d_uldiv_split(toplo, -tophi, bottom);
        else
            return i3d_uldiv_split(toplo, -tophi, -bottom);
    }
    else {
        if(bottom<0)
            return i3d_uldiv_split(toplo, tophi, -bottom);
        else
            return i3d_uldiv_split(toplo, tophi, bottom);
    }
}

static inline uint64 i3d_uldiv(uint64 udividend, uint32 udivisor)
{
    return i3d_uldiv_split((uint32)(udividend&0xffffffff), (uint32)(udividend>>32), udivisor);
}





static inline int64 i3d_ldiv(int64 dividend,
                    int32 divisor)
{
    if(dividend<0) {
        if(divisor>0)
            return -(int64)i3d_uldiv(-dividend,divisor);
        else
            return i3d_uldiv(-dividend,-divisor);
    }
    else {
        if(divisor<0)
            return -(int64)i3d_uldiv(dividend,-divisor);
        else
            return i3d_uldiv(dividend,divisor);
    }
}
# 293 "d:/marmalade/6.1/modules/iwutil/h/IwDivide.h"
static inline int32 i3d_lmod(int64 dividend, int32 divisor)
{
        return (int32)(dividend - (((int64)(((int64)(dividend))/((int32)(divisor)))) * divisor));
}
# 20 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwRuntime.h" 1
       
# 30 "d:/marmalade/6.1/modules/iwutil/h/IwRuntime.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eTimer.h" 1
# 31 "d:/marmalade/6.1/modules/iwutil/h/IwRuntime.h" 2

extern "C" {
# 41 "d:/marmalade/6.1/modules/iwutil/h/IwRuntime.h"
typedef struct _IwCallStack
{
    const char** m_Stack;
    const char** m_StackPtr;

} IwCallStack;

void IwCallStackLeave(void* pObj);
void IwCallStackSetStackSizeLimit(uint32 limit);
void IwCallStackSetStackAddress(uint32 addr);
void IwCallStackPrintStack(char* pBuffer);
IwCallStack* IwCallStackGet();







void IwCallStackInit();
void IwCallStackTerm();
# 75 "d:/marmalade/6.1/modules/iwutil/h/IwRuntime.h"
    void IwCallStackSetCallStackTracing(bool bOnOrOff);



void IwProfileStartProfile(const char* name);
void IwProfileStopProfile();
void IwProfileIncrementFrameCounter();
void IwProfileReset();

}
# 214 "d:/marmalade/6.1/modules/iwutil/h/IwRuntime.h"
class CIwProfileNode
{
public:
    CIwProfileNode(const char* name, CIwProfileNode* parent);
    ~CIwProfileNode();

    CIwProfileNode* GetSubNode(const char* name);

    CIwProfileNode* GetParent() {return m_Parent;}
    CIwProfileNode* GetSibling() {return m_Sibling;}
    CIwProfileNode* GetChild() {return m_Child;}

    void Reset();
    void Call();
    bool Return();
    void NewFrame();

    const char* GetName() {return m_Name;}
    long GetTotalCalls() {return m_TotalCalls;}
    float GetTotalTime() {return m_TotalTime;}
    float GetLastTime() {return m_LastTime;}

    long GetLastFrameCalls(){ return m_LastFrameCalls; }
    float GetLastFrameTime() { return m_LastFrameTime; }
    float GetFrameTimeAvg() { return m_FrameWeightedAvg; }

    bool IsRemainingTimeNode() { return m_IsOtherTimeNode; }

protected:
    const char* m_Name;
    long m_TotalCalls;
    float m_TotalTime;
    float m_LastTime;
    float m_WeightedAvg;

    long m_FrameCalls;
    float m_FrameTime;
    float m_FrameWeightedAvg;

    long m_LastFrameCalls;
    float m_LastFrameTime;

    int32 m_StartTime;
    long m_RecursionCounter;

    bool m_IsOtherTimeNode;

    CIwProfileNode* m_Parent;
    CIwProfileNode* m_Child;
    CIwProfileNode* m_Sibling;
};




class CIwProfileIterator
{
public:

    void First();
    void Next();
    bool IsDone();

    void EnterChild(long index);
    void EnterParent();


    const char* GetCurrentName() {return m_CurrentChild->GetName();}
    long GetCurrentTotalCalls() {return m_CurrentChild->GetTotalCalls();}
    float GetCurrentTotalTime() {return m_CurrentChild->GetTotalTime();}
    float GetCurrentLastTime() {return m_CurrentChild->GetLastTime();}
    float GetCurrentLastFrameTime() {return m_CurrentChild->GetLastFrameTime();}
    long GetCurrentLastFrameCalls() {return m_CurrentChild->GetLastFrameCalls();}
    float GetCurrentFrameTimeAvg() {return m_CurrentChild->GetFrameTimeAvg();}
    bool IsCurrentRemainingTimeNode() {return m_CurrentChild->IsRemainingTimeNode();}




    const char* GetCurrentParentName() {return m_CurrentParent->GetName();}
    long GetCurrentParentTotalCalls() {return m_CurrentParent->GetTotalCalls();}
    float GetCurrentParentTotalTime() {return m_CurrentParent->GetTotalTime();}


protected:
    CIwProfileNode* m_CurrentParent;
    CIwProfileNode* m_CurrentChild;

    CIwProfileIterator(CIwProfileNode* start);
    friend class CIwProfileManager;
};




class CIwProfileManager
{
public:
    CIwProfileManager(uint32 maxNodes=200);
    ~CIwProfileManager();

    inline void SetActive(bool active) {m_Active = active;}
    void StartProfile(const char* name);
    void StopProfile();

    void Reset();
    void IncrementFrameCounter();
    inline long GetFrameCountSinceReset() {return m_FrameCounter;}
    float GetTimeSinceReset();

    inline CIwProfileIterator* GetIterator() {return new CIwProfileIterator(&m_Root);}
    inline void ReleaseIterator(CIwProfileIterator* iterator ) {delete iterator;}


    static CIwProfileManager& Get();

    static CIwProfileManager* g_Singleton;

    CIwProfileNode* AllocNode(const char* name, CIwProfileNode* parent);

private:
    bool m_Active;
    CIwProfileNode m_Root;
    CIwProfileNode* m_CurrentNode;
    long m_FrameCounter;
    int64 m_ResetTime;
    uint32* m_Memory;
    uint32* m_MemoryCursor;
    int32 m_FreeNodes;
};




class CIwProfileSample
{
public:
    CIwProfileSample(const char* name) {IwProfileStartProfile(name);}
    ~CIwProfileSample() {IwProfileStopProfile();}
};
# 22 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h" 2
# 49 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
void IwGeomInit();






void IwGeomTerminate();
# 161 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
typedef int32 iwfixed;




typedef uint32 iwufixed;




typedef int16 iwsfixed;




typedef uint16 iwusfixed;




typedef int32 iwqfixed;
# 191 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
typedef int32 iwangle;




typedef int32 iwqangle;
# 227 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_FROM_FIXED(iwfixed a)
{
    ((void)0);
    return (iwsfixed)a;
}
# 271 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_FROM_FLOAT(float a)
{




    return (iwfixed)(a * (float)(1 << 12));
}
# 290 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_FROM_FLOAT_CAST(float a)
{




    return (iwsfixed)a;
}

static inline iwfixed IW_FIXED_FROM_FLOAT_CAST(float a)
{




    return (iwfixed)a;
}
# 365 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwangle IW_ANGLE_DIFFERENCE(iwangle x, iwangle y)
{
    iwangle z = ((iwangle)((x - y) & (((iwangle)(1 << 12)) - 1)));

    if (z <= ((iwangle)(1 << (12 - 1))))
        return z;
    else
        return z - ((iwangle)(1 << 12));
}
# 387 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL(iwfixed a, iwfixed b)
{




    return (a * b) >> 12;
}
# 405 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL_SAFE(iwfixed a, iwfixed b)
{
    int64 res = (((int64)a * b) >> 12);
    ((void)0);
    return (iwfixed)res;
}
# 422 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwsfixed IW_SFIXED_MUL(iwfixed a, iwfixed b)
{
    return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(a, b));
}
# 436 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwqfixed IW_QFIXED_MUL(iwqfixed a, iwqfixed b)
{




    return (a * b) >> 30;
}
# 454 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwqfixed IW_QFIXED_MUL_SAFE(iwqfixed a, iwqfixed b)
{
    int64 res = (((int64)a * b) >> 30);
    ((void)0);
    return (iwfixed)res;
}
# 470 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL3(iwfixed a, iwfixed b, iwfixed c, iwfixed d, iwfixed e, iwfixed f)
{
# 485 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e) + (c * f)) >> 12;

}
# 499 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL3_SAFE(iwfixed a, iwfixed b, iwfixed c, iwfixed d, iwfixed e, iwfixed f)
{
    int64 res = ((((int64)a * d) + ((int64)b * e) + ((int64)c * f)) >> 12);
    ((void)0);
    return (iwfixed)res;
}
# 516 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL2(iwfixed a, iwfixed b, iwfixed d, iwfixed e)
{
# 527 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e)) >> 12;

}
# 542 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_MUL2_SAFE(iwfixed a, iwfixed b, iwfixed d, iwfixed e)
{
    int64 res = ((((int64)a * d) + ((int64)b * e)) >> 12);
    ((void)0);
    return (iwfixed)res;
}
# 562 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_DIV(iwfixed a, iwfixed b)
{
    if (!(b & ((1 << 12) - 1)))
    {
        return (iwfixed)(((int32)(a))/((int32)(b >> 12)));
    }
    else
    {




        return (iwfixed)(((int32)(a << 12))/((int32)(b)));
    }
}
# 593 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline iwfixed IW_FIXED_DIV_SAFE(iwfixed a, iwfixed b)
{
    if ((a>>19) == (a>>31) || !(b & ((1 << 12) - 1))) return IW_FIXED_DIV(a, b);
    int64 result = ((int64)a << 12);
    result = ((int64)(((int64)(result))/((int32)(b))));
    ((void)0);
    return (iwfixed)result;
}


extern "C" {
# 613 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
iwfixed IwGeomSin(iwangle x);






iwfixed IwGeomCos(iwangle x);






iwqfixed IwGeomQSin(iwqangle x);






iwqfixed IwGeomQCos(iwqangle x);






iwfixed IwGeomTan(iwangle x);






iwfixed IwGeomACos(iwfixed v);






iwqfixed IwGeomQACos(iwqfixed v);






iwfixed IwGeomASin(iwfixed v);






iwqfixed IwGeomQASin(iwqfixed v);






iwqfixed IwGeomQATan2(iwqfixed u, iwqfixed v);
# 687 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
iwangle IwGeomAtan2(int y, int x);
# 703 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
extern double cos(double);
extern double acos(double);
extern double sin(double);
extern double asin(double);
extern double sqrt(double);
extern double tan(double);
extern double atan2(double,double);
# 720 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
}
# 731 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MULCHECK(const int32 a, const int32 b)
{






    return a*b;
}
# 752 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL64_SHIFT(int32 a, int32 b, int32 shift)
{







    return (int32)(((int64)a * b) >> shift);
}
# 774 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL64_3_SHIFT(int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 shift)
{







    return (int32) ((((int64)a * d) + ((int64)b * e) + ((int64)c * f)) >> shift);
}
# 795 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL_3_SHIFT(int32 a, int32 b, int32 c, int32 d, int32 e, int32 f, int32 shift)
{
# 810 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e) + (c * f)) >> shift;

}
# 825 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
static inline int32 IW_MUL_2_SHIFT(int32 a, int32 b, int32 d, int32 e, int32 shift)
{
# 836 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h"
    return ((a * d) + (b * e)) >> shift;

}




# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomLegacy.h" 1
       
# 844 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h" 1
       
# 38 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
iwfixed IW_GEOM_SQRT(iwfixed a);






iwqfixed IW_GEOM_QSQRT(iwqfixed a);
# 54 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
int32 IW_GEOM_SQRT2(int32 a);
# 79 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
extern iwfixed g_SqrtTable [];


void IwSqrtInit();
# 93 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_SQRT_FAST(iwfixed x){
    uint32 m = clz(x);

    if (m <= (32 - 12 + 1)) {
        m = ((32 - 12 + 1) - m + 1) & (~1);




        int32 totalshift = (0>>1) + 12 - (m>>1);

        if (((x<<1)>>m)&1){
            if (totalshift > 0)
                return g_SqrtTable[(x>>m)+1]>>totalshift;
            else
                return g_SqrtTable[(x>>m)+1]<<(-totalshift);
        } else {
            if (totalshift > 0)
                return g_SqrtTable[x>>m]>>totalshift;
            else
                return g_SqrtTable[x>>m]<<(-totalshift);
        }
    } else {
        m = (m - (32 - 12 + 1) - 1) & (~1);




        return g_SqrtTable[x<<m]>>((0 + m)>>1)>>12;
    }
}
# 133 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_SQRT2_FAST(iwfixed x){
    uint32 m = clz(x);

    if (m <= (32 - 12 + 1)) {
        m = ((32 - 12 + 1) - m + 1) & (~1);




        int32 totalshift = (0>>1) + (12>>1) - (m>>1);

        if (((x<<1)>>m)&1){
            if (totalshift > 0)
                return g_SqrtTable[(x>>m)+1]>>totalshift;
            else
                return g_SqrtTable[(x>>m)+1]<<(-totalshift);
        } else {
            if (totalshift > 0)
                return g_SqrtTable[x>>m]>>totalshift;
            else
                return g_SqrtTable[x>>m]<<(-totalshift);
        }
    } else {
        m = (m - (32 - 12 + 1) - 1) & (~1);




        return g_SqrtTable[x<<m]>>((0 + m + 12)>>1);
    }
}
# 190 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
void IwInverseSqrtInit();






extern iwfixed g_InverseSqrtTable[];
# 209 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_INVERSE_SQRT(iwfixed x)
{
    uint32 m = clz(x);







    if (m <= (32 - 12 + 1)){
        m = ((32 - 12 + 1) - m + 1)>>1;





        return (g_InverseSqrtTable[x>>(m<<1)]<<(6>>1))>>m;
    } else {
        m = (m - (32 - 12 + 1))>>1;





        return g_InverseSqrtTable[x<<(m<<1)]<<((6>>1) - m);
    }
}
# 250 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSqrt.h"
static inline iwfixed IW_GEOM_INVERSE_SQRT2(iwfixed x){
    uint32 m = clz(x);







    if (m <= (32 - 12 + 1)){
        m = ((32 - 12 + 1) - m + 1)>>1;





        return (g_InverseSqrtTable[x>>(m<<1)]<<((6 + 12)>>1))>>m;
    } else {
        m = (m - (32 - 12 + 1))>>1;





        return g_InverseSqrtTable[x<<(m<<1)]<<(((6 + 12)>>1) - m);
    }
}
# 845 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomCore.h" 2
# 25 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h" 2
# 41 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
typedef uint16 IwPixel;
# 80 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
class CIwColour
{
public:




    inline void Serialise()
    {
        IwSerialiseUInt8(r);
        IwSerialiseUInt8(g);
        IwSerialiseUInt8(b);
        IwSerialiseUInt8(a);
    }
# 102 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
    void Set(uint32 rgba)
    {






        *(uint32*)this = rgba;

    }
# 124 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
    inline void Set(uint8 _r, uint8 _g, uint8 _b, uint8 _a)
    {
        r = _r;
        g = _g;
        b = _b;
        a = _a;
    }
# 141 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
    inline void Set(uint8 _r, uint8 _g, uint8 _b)
    {
        r = _r;
        g = _g;
        b = _b;
        a = 0xff;
    }
# 156 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
    inline void Set(CIwColour other) { *(uint32*)this = *(uint32*)&other; }







    inline uint32 Get() const
    {






        return *(uint32*)this;

    }
# 183 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
    inline void SetOpaque(uint32 rgb)
    {
        Set(rgb | (uint32)0xff << 24);
    }
# 195 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
    inline void SetGrey(uint8 g) { SetOpaque(g | g << 8 | g << 16); }
# 205 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
    CIwColour operator= (uint32 rgba)
    {
        Set(rgba);
        return *this;
    }






    bool operator == (uint32 rgba) const
    {
        return Get() == rgba;
    }






    bool operator == (const CIwColour& other) const
    {
        return *(uint32*)this == *(uint32*)&other;
    }






    bool operator != (uint32 rgba) const
    {
        return Get() != rgba;
    }






    bool operator != (const CIwColour& other) const
    {
        return *(uint32*)this != *(uint32*)&other;
    }







    CIwColour operator *= (const CIwColour& other)
    {
        (*this).r = ((*this).r * (other).r) >> (7); (*this).g = ((*this).g * (other).g) >> (7); (*this).b = ((*this).b * (other).b) >> (7); (*this).a = ((*this).a * (other).a) >> (7);
        return *this;
    }






    CIwColour operator * (iwfixed other)
    {
        CIwColour ret;
        ret.r = (uint8)((((0xff) < (IW_FIXED_MUL(other, r))) ? (0xff) : (IW_FIXED_MUL(other, r))));
        ret.g = (uint8)((((0xff) < (IW_FIXED_MUL(other, g))) ? (0xff) : (IW_FIXED_MUL(other, g))));
        ret.b = (uint8)((((0xff) < (IW_FIXED_MUL(other, b))) ? (0xff) : (IW_FIXED_MUL(other, b))));
        ret.a = (uint8)((((0xff) < (IW_FIXED_MUL(other, a))) ? (0xff) : (IW_FIXED_MUL(other, a))));
        return ret;
    }






    CIwColour operator + (CIwColour other)
    {
        CIwColour ret;
        ret.r = (((0xff) < (r + other.r)) ? (0xff) : (r + other.r));
        ret.g = (((0xff) < (g + other.g)) ? (0xff) : (g + other.g));
        ret.b = (((0xff) < (b + other.b)) ? (0xff) : (b + other.b));
        ret.a = (((0xff) < (a + other.a)) ? (0xff) : (a + other.a));
        return ret;
    }






    CIwColour operator += (const CIwColour& other)
    {
        r = (((0xff) < (r + other.r)) ? (0xff) : (r + other.r));
        g = (((0xff) < (g + other.g)) ? (0xff) : (g + other.g));
        b = (((0xff) < (b + other.b)) ? (0xff) : (b + other.b));
        a = (((0xff) < (a + other.a)) ? (0xff) : (a + other.a));
        return *this;
    }






    CIwColour operator -= (const CIwColour& other)
    {
        r = (((0x00) > (r - other.r)) ? (0x00) : (r - other.r));
        g = (((0x00) > (g - other.g)) ? (0x00) : (g - other.g));
        b = (((0x00) > (b - other.b)) ? (0x00) : (b - other.b));
        a = (((0x00) > (a - other.a)) ? (0x00) : (a - other.a));
        return *this;
    }







            uint8 r;
            uint8 g;
            uint8 b;
            uint8 a;





}

__attribute__ ((aligned (4)))

;






typedef enum IwGxColourFixed
{
    IW_GX_COLOUR_BLACK,
    IW_GX_COLOUR_WHITE,
    IW_GX_COLOUR_GREY,
    IW_GX_COLOUR_RED,
    IW_GX_COLOUR_GREEN,
    IW_GX_COLOUR_BLUE,
    IW_GX_COLOUR_MAGENTA,
    IW_GX_COLOUR_CYAN,
    IW_GX_COLOUR_YELLOW,
    IW_GX_COLOUR_MAX,
} IwGxColourFixed;





extern CIwColour g_IwGxColours[];
# 374 "d:/marmalade/6.1/modules/iwgx/h/IwColour.h"
static inline const CIwColour& IwGxGetColFixed(IwGxColourFixed colID)
{
    ((void)0);
    return g_IwGxColours[colID];
}
# 22 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 1
       
# 22 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h"
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec.h"
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec2
{
public:
    int16 x;
    int16 y;


    static CIwSVec2 g_Zero;


    static CIwSVec2 g_AxisX;


    static CIwSVec2 g_AxisY;




    CIwSVec2() {};






    CIwSVec2(int16 _x, int16 _y) : x(_x), y(_y) {};

    explicit CIwSVec2(const CIwVec2& v);
    explicit CIwSVec2(const CIwFVec2& v);
    CIwSVec2 operator = (const CIwVec2& v);
    CIwSVec2 operator = (const CIwFVec2& v);
# 90 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 140 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    void NormaliseSlow();
# 150 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    void Normalise();





    CIwSVec2 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec2 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 190 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec2 const & v) const {return *this * v;}
# 219 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    CIwSVec2& operator = (CIwSVec2 const & v);






    CIwSVec2 operator + (CIwSVec2 const & v) const;






    CIwSVec2 & operator += (CIwSVec2 const & v);






    CIwSVec2 operator - (CIwSVec2 const & v) const;






    CIwSVec2 & operator -= (CIwSVec2 const & v);






    int32 operator * (CIwSVec2 const & v) const;







    bool operator == (CIwSVec2 const & v) const;






    bool operator != (CIwSVec2 const & v) const;
# 282 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    CIwSVec2 operator - () const;






    CIwSVec2 operator * (iwfixed l) const;







    CIwSVec2 & operator *= (iwfixed l);






    CIwSVec2 operator / (const iwfixed s) const;






    CIwSVec2 operator >> (const int s) const;







    CIwSVec2 operator >>= (const int s);






    CIwSVec2 operator << (const int s) const;







    CIwSVec2 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec2& CIwSVec2::operator = (CIwSVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator + (CIwSVec2 const & v) const
{





    return CIwSVec2(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        );
}




inline CIwSVec2 & CIwSVec2::operator += (CIwSVec2 const & v)
{





    x += v.x;
    y += v.y;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator - (CIwSVec2 const & v) const
{





    return CIwSVec2(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        );
}




inline CIwSVec2 & CIwSVec2::operator -= (CIwSVec2 const & v)
{





    x -= v.x;
    y -= v.y;
    return *this;
}




inline int32 CIwSVec2::operator * (CIwSVec2 const & v) const
{
# 442 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        0) >> 12;
}




inline bool CIwSVec2::operator == (CIwSVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwSVec2::operator != (CIwSVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwSVec2 CIwSVec2::operator * (iwfixed l) const
{
# 483 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    return CIwSVec2(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        );
}




inline CIwSVec2 & CIwSVec2::operator *= (iwfixed l)
{
# 502 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    return *this;
}




inline CIwSVec2 CIwSVec2::operator - () const
{
    return CIwSVec2(
        (int16)-x
        , (int16)-y
        );
}




inline CIwSVec2 CIwSVec2::operator / (const iwfixed s) const
{
    return CIwSVec2(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        );
}




inline CIwSVec2 CIwSVec2::operator >> (const int s) const
{
    return CIwSVec2(
        (int16)(x >> s)
        , (int16)(y >> s)
        );
}

inline CIwSVec2 CIwSVec2::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    return *this;
}




inline CIwSVec2 CIwSVec2::operator << (const int s) const
{





    return CIwSVec2(
        (int16)(x << s)
        , (int16)(y << s)
        );
}

inline CIwSVec2 CIwSVec2::operator <<= (const int s)
{





    x <<= s;
    y <<= s;
    return *this;
}


inline int16 & CIwSVec2::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int16 CIwSVec2::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwSVec2 operator * (iwfixed l, const CIwSVec2& v)
{
    return v * l;
}





# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec2
{
public:
    int32 x;
    int32 y;


    static CIwVec2 g_Zero;


    static CIwVec2 g_AxisX;


    static CIwVec2 g_AxisY;




    CIwVec2() {};






    CIwVec2(int32 _x, int32 _y) : x(_x), y(_y) {};

    explicit CIwVec2(const CIwSVec2& v);
    explicit CIwVec2(const CIwFVec2& v);
    CIwVec2 operator = (const CIwSVec2& v);
    CIwVec2 operator = (const CIwFVec2& v);
# 90 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 140 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    void NormaliseSlow();
# 150 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    void Normalise();





    CIwVec2 GetNormalised() const;







    void NormaliseSafe();





    CIwVec2 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 190 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec2 const & v) const {return *this * v;}
# 219 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    CIwVec2& operator = (CIwVec2 const & v);






    CIwVec2 operator + (CIwVec2 const & v) const;






    CIwVec2 & operator += (CIwVec2 const & v);






    CIwVec2 operator - (CIwVec2 const & v) const;






    CIwVec2 & operator -= (CIwVec2 const & v);






    int32 operator * (CIwVec2 const & v) const;







    bool operator == (CIwVec2 const & v) const;






    bool operator != (CIwVec2 const & v) const;
# 282 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    CIwVec2 operator - () const;






    CIwVec2 operator * (iwfixed l) const;







    CIwVec2 & operator *= (iwfixed l);






    CIwVec2 operator / (const iwfixed s) const;






    CIwVec2 operator >> (const int s) const;







    CIwVec2 operator >>= (const int s);






    CIwVec2 operator << (const int s) const;







    CIwVec2 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec2& CIwVec2::operator = (CIwVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwVec2 CIwVec2::operator + (CIwVec2 const & v) const
{





    return CIwVec2(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        );
}




inline CIwVec2 & CIwVec2::operator += (CIwVec2 const & v)
{





    x += v.x;
    y += v.y;
    return *this;
}




inline CIwVec2 CIwVec2::operator - (CIwVec2 const & v) const
{





    return CIwVec2(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        );
}




inline CIwVec2 & CIwVec2::operator -= (CIwVec2 const & v)
{





    x -= v.x;
    y -= v.y;
    return *this;
}




inline int32 CIwVec2::operator * (CIwVec2 const & v) const
{
# 442 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        0) >> 12;
}




inline bool CIwVec2::operator == (CIwVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwVec2::operator != (CIwVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwVec2 CIwVec2::operator * (iwfixed l) const
{
# 483 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    return CIwVec2(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        );
}




inline CIwVec2 & CIwVec2::operator *= (iwfixed l)
{
# 502 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h"
    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    return *this;
}




inline CIwVec2 CIwVec2::operator - () const
{
    return CIwVec2(
        (int32)-x
        , (int32)-y
        );
}




inline CIwVec2 CIwVec2::operator / (const iwfixed s) const
{
    return CIwVec2(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        );
}




inline CIwVec2 CIwVec2::operator >> (const int s) const
{
    return CIwVec2(
        (int32)(x >> s)
        , (int32)(y >> s)
        );
}

inline CIwVec2 CIwVec2::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    return *this;
}




inline CIwVec2 CIwVec2::operator << (const int s) const
{





    return CIwVec2(
        (int32)(x << s)
        , (int32)(y << s)
        );
}

inline CIwVec2 CIwVec2::operator <<= (const int s)
{





    x <<= s;
    y <<= s;
    return *this;
}


inline int32 & CIwVec2::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int32 CIwVec2::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwVec2 operator * (iwfixed l, const CIwVec2& v)
{
    return v * l;
}







inline CIwVec2::CIwVec2(const CIwSVec2& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
}

inline CIwVec2 CIwVec2::operator = (const CIwSVec2& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    return *this;
}


inline bool operator == (const CIwVec2& v1, const CIwSVec2& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        true);
}


inline CIwVec2 operator + (const CIwVec2& v1, const CIwSVec2& v2)
{
    return CIwVec2(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        );
}


inline CIwVec2 operator - (const CIwVec2& v1, const CIwSVec2& v2)
{
    return CIwVec2(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        );
}




inline CIwVec2 operator += (CIwVec2& v1, const CIwSVec2& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    return v1;
}




inline CIwVec2 operator -= (CIwVec2& v1, const CIwSVec2& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    return v1;
}




inline int32 operator * (const CIwVec2& v1, const CIwSVec2& v2)
{
    return v1 * CIwVec2(v2);
}






# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec2
{
public:
    float x;
    float y;


    static CIwFVec2 g_Zero;


    static CIwFVec2 g_AxisX;


    static CIwFVec2 g_AxisY;




    CIwFVec2() {};






    CIwFVec2(float _x, float _y) : x(_x), y(_y) {};

    explicit CIwFVec2(const CIwSVec2& v);
    explicit CIwFVec2(const CIwVec2& v);
    CIwFVec2 operator = (const CIwSVec2& v);
    CIwFVec2 operator = (const CIwVec2& v);
# 90 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y);
    }
# 117 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h"
    void Normalise();






    CIwFVec2 GetNormalised() const;







    bool IsNormalised() const;
# 145 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec2 const & v) const {return *this * v;}
# 174 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h"
    CIwFVec2& operator = (CIwFVec2 const & v);






    CIwFVec2 operator + (CIwFVec2 const & v) const;






    CIwFVec2 & operator += (CIwFVec2 const & v);






    CIwFVec2 operator - (CIwFVec2 const & v) const;






    CIwFVec2 & operator -= (CIwFVec2 const & v);






    float operator * (CIwFVec2 const & v) const;







    bool operator == (CIwFVec2 const & v) const;






    bool operator != (CIwFVec2 const & v) const;
# 237 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h"
    CIwFVec2 operator - () const;






    CIwFVec2 operator * (float l) const;







    CIwFVec2 & operator *= (float l);






    CIwFVec2 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec2& CIwFVec2::operator = (CIwFVec2 const & v)
{
    x = v.x;
    y = v.y;
    return *this;
}




inline CIwFVec2 CIwFVec2::operator + (CIwFVec2 const & v) const
{
    return CIwFVec2(
        (float)(x + v.x)
        , (float)(y + v.y)
        );
}




inline CIwFVec2 & CIwFVec2::operator += (CIwFVec2 const & v)
{
    x += v.x;
    y += v.y;
    return *this;
}




inline CIwFVec2 CIwFVec2::operator - (CIwFVec2 const & v) const
{
    return CIwFVec2(
        (float)(x - v.x)
        , (float)(y - v.y)
        );
}




inline CIwFVec2 & CIwFVec2::operator -= (CIwFVec2 const & v)
{
    x -= v.x;
    y -= v.y;
    return *this;
}




inline float CIwFVec2::operator * (CIwFVec2 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        0);
}




inline bool CIwFVec2::operator == (CIwFVec2 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        true);
}




inline bool CIwFVec2::operator != (CIwFVec2 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        false);
}




inline CIwFVec2 CIwFVec2::operator * (float l) const
{
    return CIwFVec2(
        (float)(x * l)
        , (float)(y * l)
        );
}




inline CIwFVec2 & CIwFVec2::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    return *this;
}




inline CIwFVec2 CIwFVec2::operator - () const
{
    return CIwFVec2(
        (float)-x
        , (float)-y
        );
}




inline CIwFVec2 CIwFVec2::operator / (const float s) const
{
    return CIwFVec2(
        (float)(x / s)
        , (float)(y / s)
        );
}


inline float & CIwFVec2::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline float CIwFVec2::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwFVec2 operator * (float l, const CIwFVec2& v)
{
    return v * l;
}







inline CIwFVec2::CIwFVec2(const CIwSVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
}

inline CIwFVec2 CIwFVec2::operator = (const CIwSVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec2 operator + (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return CIwFVec2(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        );
}


inline CIwFVec2 operator - (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return CIwFVec2(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator += (CIwFVec2& v1, const CIwSVec2& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline CIwFVec2 operator -= (CIwFVec2& v1, const CIwSVec2& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec2& v1, const CIwSVec2& v2)
{
    return v1 * CIwFVec2(v2);
}
# 514 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec2.h"
inline CIwFVec2::CIwFVec2(const CIwVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
}




inline CIwFVec2 CIwFVec2::operator = (const CIwVec2& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec2& v1, const CIwVec2& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec2 operator + (const CIwFVec2& v1, const CIwVec2& v2)
{
    return CIwFVec2(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator - (const CIwFVec2& v1, const CIwVec2& v2)
{
    return CIwFVec2(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        );
}




inline CIwFVec2 operator += (CIwFVec2& v1, const CIwVec2& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline CIwFVec2 operator -= (CIwFVec2& v1, const CIwVec2& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec2& v1, const CIwVec2& v2)
{
    return v1 * CIwFVec2(v2);
}
# 678 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec2.h" 2

inline CIwVec2::CIwVec2(const CIwFVec2& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
}




inline CIwVec2 CIwVec2::operator = (const CIwFVec2& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    return *this;
}




inline bool operator == (const CIwVec2& v1, const CIwFVec2& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        true);
}




inline CIwFVec2 operator + (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        );
}




inline CIwFVec2 operator - (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        );
}




inline CIwVec2 operator += (CIwVec2& v1, const CIwFVec2& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    return v1;
}




inline CIwVec2 operator -= (CIwVec2& v1, const CIwFVec2& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    return v1;
}




inline float operator * (const CIwVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(v1) * v2;
}
# 603 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h" 2

inline CIwSVec2::CIwSVec2(const CIwVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
}

inline CIwSVec2 CIwSVec2::operator = (const CIwVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    return *this;
}


inline bool operator == (const CIwSVec2& v1, const CIwVec2& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        true);
}


inline CIwVec2 operator + (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        );
}


inline CIwVec2 operator - (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        );
}




inline CIwSVec2 operator += (CIwSVec2& v1, const CIwVec2& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    return v1;
}




inline CIwSVec2 operator -= (CIwSVec2& v1, const CIwVec2& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    return v1;
}




inline int32 operator * (const CIwSVec2& v1, const CIwVec2& v2)
{
    return CIwVec2(v1) * v2;
}
# 679 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec2.h"
inline CIwSVec2::CIwSVec2(const CIwFVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
}




inline CIwSVec2 CIwSVec2::operator = (const CIwFVec2& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    return *this;
}




inline bool operator == (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        true);
}




inline CIwFVec2 operator + (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        );
}




inline CIwFVec2 operator - (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        );
}




inline CIwSVec2 operator += (CIwSVec2& v1, const CIwFVec2& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    return v1;
}




inline CIwSVec2 operator -= (CIwSVec2& v1, const CIwFVec2& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    return v1;
}




inline float operator * (const CIwSVec2& v1, const CIwFVec2& v2)
{
    return CIwFVec2(v1) * v2;
}
# 34 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec3
{
public:
    int16 x;
    int16 y;
    int16 z;


    static CIwSVec3 g_Zero;


    static CIwSVec3 g_AxisX;


    static CIwSVec3 g_AxisY;


    static CIwSVec3 g_AxisZ;




    CIwSVec3() {};
# 79 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3(int16 _x, int16 _y, int16 _z) : x(_x), y(_y), z(_z) {};

    explicit CIwSVec3(const CIwVec3& v);
    explicit CIwSVec3(const CIwFVec3& v);
    CIwSVec3 operator = (const CIwVec3& v);
    CIwSVec3 operator = (const CIwFVec3& v);
# 97 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 147 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    void NormaliseSlow();
# 157 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    void Normalise();





    CIwSVec3 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec3 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 197 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec3 const & v) const {return *this * v;}






    inline CIwSVec3 Cross(CIwSVec3 const & v) const {return *this ^ v;}
# 234 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3& operator = (CIwSVec3 const & v);






    CIwSVec3 operator + (CIwSVec3 const & v) const;






    CIwSVec3 & operator += (CIwSVec3 const & v);






    CIwSVec3 operator - (CIwSVec3 const & v) const;






    CIwSVec3 & operator -= (CIwSVec3 const & v);






    int32 operator * (CIwSVec3 const & v) const;






    CIwSVec3 operator ^ (CIwSVec3 const & v) const;






    bool operator == (CIwSVec3 const & v) const;






    bool operator != (CIwSVec3 const & v) const;
# 303 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    CIwSVec3 operator - () const;






    CIwSVec3 operator * (iwfixed l) const;







    CIwSVec3 & operator *= (iwfixed l);






    CIwSVec3 operator / (const iwfixed s) const;






    CIwSVec3 operator >> (const int s) const;







    CIwSVec3 operator >>= (const int s);






    CIwSVec3 operator << (const int s) const;







    CIwSVec3 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec3& CIwSVec3::operator = (CIwSVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator + (CIwSVec3 const & v) const
{






    return CIwSVec3(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        , (int16)(z + v.z)
        );
}




inline CIwSVec3 & CIwSVec3::operator += (CIwSVec3 const & v)
{






    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator - (CIwSVec3 const & v) const
{






    return CIwSVec3(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        , (int16)(z - v.z)
        );
}




inline CIwSVec3 & CIwSVec3::operator -= (CIwSVec3 const & v)
{






    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline int32 CIwSVec3::operator * (CIwSVec3 const & v) const
{
# 473 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        0) >> 12;
}



inline CIwSVec3 CIwSVec3::operator ^ (CIwSVec3 const & v) const
{

    int chk = ((((x) > 0) ? (x) : -(x)) | (((y) > 0) ? (y) : -(y)) | (((z) > 0) ? (z) : -(z)) | (((v.x) > 0) ? (v.x) : -(v.x)) | (((v.y) > 0) ? (v.y) : -(v.y)) | (((v.z) > 0) ? (v.z) : -(v.z)));
    if (chk > (1<<15))
    {
# 497 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
        return CIwSVec3( (int16)(((int64)y*v.z + (int64)z*-v.y)>>12),
                        (int16)(((int64)z*v.x + (int64)x*-v.z)>>12),
                        (int16)(((int64)x*v.y + (int64)y*-v.x)>>12) );
    }
    else
    {
# 520 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
        return CIwSVec3( (int16)(((int32)y*v.z + (int32)z*-v.y)>>12),
                        (int16)(((int32)z*v.x + (int32)x*-v.z)>>12),
                        (int16)(((int32)x*v.y + (int32)y*-v.x)>>12) );
    }
}




inline bool CIwSVec3::operator == (CIwSVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwSVec3::operator != (CIwSVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwSVec3 CIwSVec3::operator * (iwfixed l) const
{
# 564 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    return CIwSVec3(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        , (int16)IW_FIXED_MUL(z,l)
        );
}




inline CIwSVec3 & CIwSVec3::operator *= (iwfixed l)
{
# 585 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h"
    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    z = (int16)IW_FIXED_MUL(z,l);
    return *this;
}




inline CIwSVec3 CIwSVec3::operator - () const
{
    return CIwSVec3(
        (int16)-x
        , (int16)-y
        , (int16)-z
        );
}




inline CIwSVec3 CIwSVec3::operator / (const iwfixed s) const
{
    return CIwSVec3(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        , (int16)(IW_FIXED_DIV(z, s))
        );
}




inline CIwSVec3 CIwSVec3::operator >> (const int s) const
{
    return CIwSVec3(
        (int16)(x >> s)
        , (int16)(y >> s)
        , (int16)(z >> s)
        );
}

inline CIwSVec3 CIwSVec3::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    return *this;
}




inline CIwSVec3 CIwSVec3::operator << (const int s) const
{






    return CIwSVec3(
        (int16)(x << s)
        , (int16)(y << s)
        , (int16)(z << s)
        );
}

inline CIwSVec3 CIwSVec3::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;
    return *this;
}


inline int16 & CIwSVec3::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int16 CIwSVec3::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwSVec3 operator * (iwfixed l, const CIwSVec3& v)
{
    return v * l;
}





# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec3
{
public:
    int32 x;
    int32 y;
    int32 z;


    static CIwVec3 g_Zero;


    static CIwVec3 g_AxisX;


    static CIwVec3 g_AxisY;


    static CIwVec3 g_AxisZ;




    CIwVec3() {};
# 79 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3(int32 _x, int32 _y, int32 _z) : x(_x), y(_y), z(_z) {};

    explicit CIwVec3(const CIwSVec3& v);
    explicit CIwVec3(const CIwFVec3& v);
    CIwVec3 operator = (const CIwSVec3& v);
    CIwVec3 operator = (const CIwFVec3& v);
# 97 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 147 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    void NormaliseSlow();
# 157 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    void Normalise();





    CIwVec3 GetNormalised() const;







    void NormaliseSafe();





    CIwVec3 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 197 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec3 const & v) const {return *this * v;}






    inline CIwVec3 Cross(CIwVec3 const & v) const {return *this ^ v;}
# 234 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3& operator = (CIwVec3 const & v);






    CIwVec3 operator + (CIwVec3 const & v) const;






    CIwVec3 & operator += (CIwVec3 const & v);






    CIwVec3 operator - (CIwVec3 const & v) const;






    CIwVec3 & operator -= (CIwVec3 const & v);






    int32 operator * (CIwVec3 const & v) const;






    CIwVec3 operator ^ (CIwVec3 const & v) const;






    bool operator == (CIwVec3 const & v) const;






    bool operator != (CIwVec3 const & v) const;
# 303 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    CIwVec3 operator - () const;






    CIwVec3 operator * (iwfixed l) const;







    CIwVec3 & operator *= (iwfixed l);






    CIwVec3 operator / (const iwfixed s) const;






    CIwVec3 operator >> (const int s) const;







    CIwVec3 operator >>= (const int s);






    CIwVec3 operator << (const int s) const;







    CIwVec3 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec3& CIwVec3::operator = (CIwVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwVec3 CIwVec3::operator + (CIwVec3 const & v) const
{






    return CIwVec3(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        , (int32)(z + v.z)
        );
}




inline CIwVec3 & CIwVec3::operator += (CIwVec3 const & v)
{






    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwVec3 CIwVec3::operator - (CIwVec3 const & v) const
{






    return CIwVec3(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        , (int32)(z - v.z)
        );
}




inline CIwVec3 & CIwVec3::operator -= (CIwVec3 const & v)
{






    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline int32 CIwVec3::operator * (CIwVec3 const & v) const
{
# 473 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        0) >> 12;
}



inline CIwVec3 CIwVec3::operator ^ (CIwVec3 const & v) const
{

    int chk = ((((x) > 0) ? (x) : -(x)) | (((y) > 0) ? (y) : -(y)) | (((z) > 0) ? (z) : -(z)) | (((v.x) > 0) ? (v.x) : -(v.x)) | (((v.y) > 0) ? (v.y) : -(v.y)) | (((v.z) > 0) ? (v.z) : -(v.z)));
    if (chk > (1<<15))
    {
# 497 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
        return CIwVec3( (int32)(((int64)y*v.z + (int64)z*-v.y)>>12),
                        (int32)(((int64)z*v.x + (int64)x*-v.z)>>12),
                        (int32)(((int64)x*v.y + (int64)y*-v.x)>>12) );
    }
    else
    {
# 520 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
        return CIwVec3( (int32)(((int32)y*v.z + (int32)z*-v.y)>>12),
                        (int32)(((int32)z*v.x + (int32)x*-v.z)>>12),
                        (int32)(((int32)x*v.y + (int32)y*-v.x)>>12) );
    }
}




inline bool CIwVec3::operator == (CIwVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwVec3::operator != (CIwVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwVec3 CIwVec3::operator * (iwfixed l) const
{
# 564 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    return CIwVec3(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        , (int32)IW_FIXED_MUL(z,l)
        );
}




inline CIwVec3 & CIwVec3::operator *= (iwfixed l)
{
# 585 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h"
    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    z = (int32)IW_FIXED_MUL(z,l);
    return *this;
}




inline CIwVec3 CIwVec3::operator - () const
{
    return CIwVec3(
        (int32)-x
        , (int32)-y
        , (int32)-z
        );
}




inline CIwVec3 CIwVec3::operator / (const iwfixed s) const
{
    return CIwVec3(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        , (int32)(IW_FIXED_DIV(z, s))
        );
}




inline CIwVec3 CIwVec3::operator >> (const int s) const
{
    return CIwVec3(
        (int32)(x >> s)
        , (int32)(y >> s)
        , (int32)(z >> s)
        );
}

inline CIwVec3 CIwVec3::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    return *this;
}




inline CIwVec3 CIwVec3::operator << (const int s) const
{






    return CIwVec3(
        (int32)(x << s)
        , (int32)(y << s)
        , (int32)(z << s)
        );
}

inline CIwVec3 CIwVec3::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;
    return *this;
}


inline int32 & CIwVec3::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int32 CIwVec3::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwVec3 operator * (iwfixed l, const CIwVec3& v)
{
    return v * l;
}







inline CIwVec3::CIwVec3(const CIwSVec3& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
}

inline CIwVec3 CIwVec3::operator = (const CIwSVec3& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    return *this;
}


inline bool operator == (const CIwVec3& v1, const CIwSVec3& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        v1.z == (int32)v2.z &&
        true);
}


inline CIwVec3 operator + (const CIwVec3& v1, const CIwSVec3& v2)
{
    return CIwVec3(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        , v1.z + (int32)v2.z
        );
}


inline CIwVec3 operator - (const CIwVec3& v1, const CIwSVec3& v2)
{
    return CIwVec3(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        , v1.z - (int32)v2.z
        );
}




inline CIwVec3 operator += (CIwVec3& v1, const CIwSVec3& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    v1.z += (int32)v2.z;
    return v1;
}




inline CIwVec3 operator -= (CIwVec3& v1, const CIwSVec3& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    v1.z -= (int32)v2.z;
    return v1;
}




inline int32 operator * (const CIwVec3& v1, const CIwSVec3& v2)
{
    return v1 * CIwVec3(v2);
}




inline CIwVec3 operator ^ (const CIwVec3& v1, const CIwSVec3& v2)
{
    return v1 ^ CIwVec3(v2);
}





# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec3
{
public:
    float x;
    float y;
    float z;


    static CIwFVec3 g_Zero;


    static CIwFVec3 g_AxisX;


    static CIwFVec3 g_AxisY;


    static CIwFVec3 g_AxisZ;




    CIwFVec3() {};
# 79 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3(float _x, float _y, float _z) : x(_x), y(_y), z(_z) {};

    explicit CIwFVec3(const CIwSVec3& v);
    explicit CIwFVec3(const CIwVec3& v);
    CIwFVec3 operator = (const CIwSVec3& v);
    CIwFVec3 operator = (const CIwVec3& v);
# 97 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y+ z*z);
    }
# 124 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h"
    void Normalise();






    CIwFVec3 GetNormalised() const;







    bool IsNormalised() const;
# 152 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec3 const & v) const {return *this * v;}






    inline CIwFVec3 Cross(CIwFVec3 const & v) const {return *this ^ v;}
# 189 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3& operator = (CIwFVec3 const & v);






    CIwFVec3 operator + (CIwFVec3 const & v) const;






    CIwFVec3 & operator += (CIwFVec3 const & v);






    CIwFVec3 operator - (CIwFVec3 const & v) const;






    CIwFVec3 & operator -= (CIwFVec3 const & v);






    float operator * (CIwFVec3 const & v) const;






    CIwFVec3 operator ^ (CIwFVec3 const & v) const;






    bool operator == (CIwFVec3 const & v) const;






    bool operator != (CIwFVec3 const & v) const;
# 258 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec3.h"
    CIwFVec3 operator - () const;






    CIwFVec3 operator * (float l) const;







    CIwFVec3 & operator *= (float l);






    CIwFVec3 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec3& CIwFVec3::operator = (CIwFVec3 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    return *this;
}




inline CIwFVec3 CIwFVec3::operator + (CIwFVec3 const & v) const
{
    return CIwFVec3(
        (float)(x + v.x)
        , (float)(y + v.y)
        , (float)(z + v.z)
        );
}




inline CIwFVec3 & CIwFVec3::operator += (CIwFVec3 const & v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    return *this;
}




inline CIwFVec3 CIwFVec3::operator - (CIwFVec3 const & v) const
{
    return CIwFVec3(
        (float)(x - v.x)
        , (float)(y - v.y)
        , (float)(z - v.z)
        );
}




inline CIwFVec3 & CIwFVec3::operator -= (CIwFVec3 const & v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    return *this;
}




inline float CIwFVec3::operator * (CIwFVec3 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        (float)z * v.z +
        0);
}



inline CIwFVec3 CIwFVec3::operator ^ (CIwFVec3 const & v) const
{
    return CIwFVec3((y * v.z - z * v.y),
                (z * v.x - x * v.z),
                (x * v.y - y * v.x));
}




inline bool CIwFVec3::operator == (CIwFVec3 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        true);
}




inline bool CIwFVec3::operator != (CIwFVec3 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        false);
}




inline CIwFVec3 CIwFVec3::operator * (float l) const
{
    return CIwFVec3(
        (float)(x * l)
        , (float)(y * l)
        , (float)(z * l)
        );
}




inline CIwFVec3 & CIwFVec3::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    z = (float)(z * l);
    return *this;
}




inline CIwFVec3 CIwFVec3::operator - () const
{
    return CIwFVec3(
        (float)-x
        , (float)-y
        , (float)-z
        );
}




inline CIwFVec3 CIwFVec3::operator / (const float s) const
{
    return CIwFVec3(
        (float)(x / s)
        , (float)(y / s)
        , (float)(z / s)
        );
}


inline float & CIwFVec3::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline float CIwFVec3::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwFVec3 operator * (float l, const CIwFVec3& v)
{
    return v * l;
}







inline CIwFVec3::CIwFVec3(const CIwSVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
}

inline CIwFVec3 CIwFVec3::operator = (const CIwSVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec3 operator + (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return CIwFVec3(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        );
}


inline CIwFVec3 operator - (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return CIwFVec3(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator += (CIwFVec3& v1, const CIwSVec3& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline CIwFVec3 operator -= (CIwFVec3& v1, const CIwSVec3& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return v1 * CIwFVec3(v2);
}




inline CIwFVec3 operator ^ (const CIwFVec3& v1, const CIwSVec3& v2)
{
    return v1 ^ CIwFVec3(v2);
}







inline CIwFVec3::CIwFVec3(const CIwVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
}




inline CIwFVec3 CIwFVec3::operator = (const CIwVec3& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec3& v1, const CIwVec3& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec3 operator + (const CIwFVec3& v1, const CIwVec3& v2)
{
    return CIwFVec3(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator - (const CIwFVec3& v1, const CIwVec3& v2)
{
    return CIwFVec3(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        );
}




inline CIwFVec3 operator += (CIwFVec3& v1, const CIwVec3& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline CIwFVec3 operator -= (CIwFVec3& v1, const CIwVec3& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec3& v1, const CIwVec3& v2)
{
    return v1 * CIwFVec3(v2);
}




inline CIwFVec3 operator ^ (const CIwFVec3& v1, const CIwVec3& v2)
{
    return v1 ^ CIwFVec3(v2);
}
# 786 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec3.h" 2

inline CIwVec3::CIwVec3(const CIwFVec3& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
}




inline CIwVec3 CIwVec3::operator = (const CIwFVec3& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    return *this;
}




inline bool operator == (const CIwVec3& v1, const CIwFVec3& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        true);
}




inline CIwFVec3 operator + (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        );
}




inline CIwFVec3 operator - (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        );
}




inline CIwVec3 operator += (CIwVec3& v1, const CIwFVec3& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    v1.z += IW_FIXED_FROM_FLOAT(v2.z);
    return v1;
}




inline CIwVec3 operator -= (CIwVec3& v1, const CIwFVec3& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    v1.z -= IW_FIXED_FROM_FLOAT(v2.z);
    return v1;
}




inline float operator * (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) * v2;
}




inline CIwFVec3 operator ^ (const CIwVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) ^ v2;
}
# 697 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec3.h" 2

inline CIwSVec3::CIwSVec3(const CIwVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
}

inline CIwSVec3 CIwSVec3::operator = (const CIwVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    return *this;
}


inline bool operator == (const CIwSVec3& v1, const CIwVec3& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        (int32)v1.z == v2.z &&
        true);
}


inline CIwVec3 operator + (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        , (int32)v1.z + v2.z
        );
}


inline CIwVec3 operator - (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        , (int32)v1.z - v2.z
        );
}




inline CIwSVec3 operator += (CIwSVec3& v1, const CIwVec3& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    v1.z += IW_SFIXED_FROM_FIXED(v2.z);
    return v1;
}




inline CIwSVec3 operator -= (CIwSVec3& v1, const CIwVec3& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    v1.z -= IW_SFIXED_FROM_FIXED(v2.z);
    return v1;
}




inline int32 operator * (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(v1) * v2;
}




inline CIwVec3 operator ^ (const CIwSVec3& v1, const CIwVec3& v2)
{
    return CIwVec3(v1) ^ v2;
}







inline CIwSVec3::CIwSVec3(const CIwFVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
}




inline CIwSVec3 CIwSVec3::operator = (const CIwFVec3& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    return *this;
}




inline bool operator == (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        true);
}




inline CIwFVec3 operator + (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        );
}




inline CIwFVec3 operator - (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        );
}




inline CIwSVec3 operator += (CIwSVec3& v1, const CIwFVec3& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    return v1;
}




inline CIwSVec3 operator -= (CIwSVec3& v1, const CIwFVec3& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    return v1;
}




inline float operator * (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) * v2;
}




inline CIwFVec3 operator ^ (const CIwSVec3& v1, const CIwFVec3& v2)
{
    return CIwFVec3(v1) ^ v2;
}
# 35 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwSVec4
{
public:
    int16 x;
    int16 y;
    int16 z;
    int16 w;


    static CIwSVec4 g_Zero;


    static CIwSVec4 g_AxisX;


    static CIwSVec4 g_AxisY;


    static CIwSVec4 g_AxisZ;


    static CIwSVec4 g_AxisW;




    CIwSVec4() {};
# 86 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4(int16 _x, int16 _y, int16 _z, int16 _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwSVec4(const CIwVec4& v);
    explicit CIwSVec4(const CIwFVec4& v);
    CIwSVec4 operator = (const CIwVec4& v);
    CIwSVec4 operator = (const CIwFVec4& v);
# 104 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z+ w*w) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 154 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    void NormaliseSlow();
# 164 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    void Normalise();





    CIwSVec4 GetNormalised() const;







    void NormaliseSafe();





    CIwSVec4 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 204 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwSVec4 const & v) const {return *this * v;}
# 233 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4& operator = (CIwSVec4 const & v);






    CIwSVec4 operator + (CIwSVec4 const & v) const;






    CIwSVec4 & operator += (CIwSVec4 const & v);






    CIwSVec4 operator - (CIwSVec4 const & v) const;






    CIwSVec4 & operator -= (CIwSVec4 const & v);






    int32 operator * (CIwSVec4 const & v) const;







    bool operator == (CIwSVec4 const & v) const;






    bool operator != (CIwSVec4 const & v) const;
# 296 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    CIwSVec4 operator - () const;






    CIwSVec4 operator * (iwfixed l) const;







    CIwSVec4 & operator *= (iwfixed l);






    CIwSVec4 operator / (const iwfixed s) const;






    CIwSVec4 operator >> (const int s) const;







    CIwSVec4 operator >>= (const int s);






    CIwSVec4 operator << (const int s) const;







    CIwSVec4 operator <<= (const int s);






    int16 & operator [] (const int n);






    int16 operator [] (const int n) const;




};




inline CIwSVec4& CIwSVec4::operator = (CIwSVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator + (CIwSVec4 const & v) const
{







    return CIwSVec4(
        (int16)(x + v.x)
        , (int16)(y + v.y)
        , (int16)(z + v.z)
        , (int16)(w + v.w)
        );
}




inline CIwSVec4 & CIwSVec4::operator += (CIwSVec4 const & v)
{







    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator - (CIwSVec4 const & v) const
{







    return CIwSVec4(
        (int16)(x - v.x)
        , (int16)(y - v.y)
        , (int16)(z - v.z)
        , (int16)(w - v.w)
        );
}




inline CIwSVec4 & CIwSVec4::operator -= (CIwSVec4 const & v)
{







    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline int32 CIwSVec4::operator * (CIwSVec4 const & v) const
{
# 476 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        (int32)w * v.w +
        0) >> 12;
}




inline bool CIwSVec4::operator == (CIwSVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwSVec4::operator != (CIwSVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwSVec4 CIwSVec4::operator * (iwfixed l) const
{
# 525 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    return CIwSVec4(
          (int16)IW_FIXED_MUL(x,l)
        , (int16)IW_FIXED_MUL(y,l)
        , (int16)IW_FIXED_MUL(z,l)
        , (int16)IW_FIXED_MUL(w,l)
        );
}




inline CIwSVec4 & CIwSVec4::operator *= (iwfixed l)
{
# 548 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
    x = (int16)IW_FIXED_MUL(x,l);
    y = (int16)IW_FIXED_MUL(y,l);
    z = (int16)IW_FIXED_MUL(z,l);
    w = (int16)IW_FIXED_MUL(w,l);
    return *this;
}




inline CIwSVec4 CIwSVec4::operator - () const
{
    return CIwSVec4(
        (int16)-x
        , (int16)-y
        , (int16)-z
        , (int16)-w
        );
}




inline CIwSVec4 CIwSVec4::operator / (const iwfixed s) const
{
    return CIwSVec4(
        (int16)(IW_FIXED_DIV(x, s))
        , (int16)(IW_FIXED_DIV(y, s))
        , (int16)(IW_FIXED_DIV(z, s))
        , (int16)(IW_FIXED_DIV(w, s))
        );
}




inline CIwSVec4 CIwSVec4::operator >> (const int s) const
{
    return CIwSVec4(
        (int16)(x >> s)
        , (int16)(y >> s)
        , (int16)(z >> s)
        , (int16)(w >> s)
        );
}

inline CIwSVec4 CIwSVec4::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    w >>= s;
    return *this;
}




inline CIwSVec4 CIwSVec4::operator << (const int s) const
{







    return CIwSVec4(
        (int16)(x << s)
        , (int16)(y << s)
        , (int16)(z << s)
        , (int16)(w << s)
        );
}

inline CIwSVec4 CIwSVec4::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;



    w <<= s;
    return *this;
}


inline int16 & CIwSVec4::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int16 CIwSVec4::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwSVec4 operator * (iwfixed l, const CIwSVec4& v)
{
    return v * l;
}





# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwVec4
{
public:
    int32 x;
    int32 y;
    int32 z;
    int32 w;


    static CIwVec4 g_Zero;


    static CIwVec4 g_AxisX;


    static CIwVec4 g_AxisY;


    static CIwVec4 g_AxisZ;


    static CIwVec4 g_AxisW;




    CIwVec4() {};
# 86 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4(int32 _x, int32 _y, int32 _z, int32 _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwVec4(const CIwSVec4& v);
    explicit CIwVec4(const CIwFVec4& v);
    CIwVec4 operator = (const CIwSVec4& v);
    CIwVec4 operator = (const CIwFVec4& v);
# 104 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    int32 GetLength() const;





    inline int32 GetLengthSquared() const
    {





        return (x*x + y*y+ z*z+ w*w) >> 12;
    }






    int32 GetLengthSafe() const;






    int32 GetLengthSquaredSafe() const;





    int32 GetLengthSquaredUnshifted() const;
# 154 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    void NormaliseSlow();
# 164 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    void Normalise();





    CIwVec4 GetNormalised() const;







    void NormaliseSafe();





    CIwVec4 GetNormalisedSafe() const;






    bool IsNormalised() const;
# 204 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline int32 Dot(CIwVec4 const & v) const {return *this * v;}
# 233 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4& operator = (CIwVec4 const & v);






    CIwVec4 operator + (CIwVec4 const & v) const;






    CIwVec4 & operator += (CIwVec4 const & v);






    CIwVec4 operator - (CIwVec4 const & v) const;






    CIwVec4 & operator -= (CIwVec4 const & v);






    int32 operator * (CIwVec4 const & v) const;







    bool operator == (CIwVec4 const & v) const;






    bool operator != (CIwVec4 const & v) const;
# 296 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    CIwVec4 operator - () const;






    CIwVec4 operator * (iwfixed l) const;







    CIwVec4 & operator *= (iwfixed l);






    CIwVec4 operator / (const iwfixed s) const;






    CIwVec4 operator >> (const int s) const;







    CIwVec4 operator >>= (const int s);






    CIwVec4 operator << (const int s) const;







    CIwVec4 operator <<= (const int s);






    int32 & operator [] (const int n);






    int32 operator [] (const int n) const;




};




inline CIwVec4& CIwVec4::operator = (CIwVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwVec4 CIwVec4::operator + (CIwVec4 const & v) const
{







    return CIwVec4(
        (int32)(x + v.x)
        , (int32)(y + v.y)
        , (int32)(z + v.z)
        , (int32)(w + v.w)
        );
}




inline CIwVec4 & CIwVec4::operator += (CIwVec4 const & v)
{







    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwVec4 CIwVec4::operator - (CIwVec4 const & v) const
{







    return CIwVec4(
        (int32)(x - v.x)
        , (int32)(y - v.y)
        , (int32)(z - v.z)
        , (int32)(w - v.w)
        );
}




inline CIwVec4 & CIwVec4::operator -= (CIwVec4 const & v)
{







    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline int32 CIwVec4::operator * (CIwVec4 const & v) const
{
# 476 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    return (
        (int32)x * v.x +
        (int32)y * v.y +
        (int32)z * v.z +
        (int32)w * v.w +
        0) >> 12;
}




inline bool CIwVec4::operator == (CIwVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwVec4::operator != (CIwVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwVec4 CIwVec4::operator * (iwfixed l) const
{
# 525 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    return CIwVec4(
          (int32)IW_FIXED_MUL(x,l)
        , (int32)IW_FIXED_MUL(y,l)
        , (int32)IW_FIXED_MUL(z,l)
        , (int32)IW_FIXED_MUL(w,l)
        );
}




inline CIwVec4 & CIwVec4::operator *= (iwfixed l)
{
# 548 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h"
    x = (int32)IW_FIXED_MUL(x,l);
    y = (int32)IW_FIXED_MUL(y,l);
    z = (int32)IW_FIXED_MUL(z,l);
    w = (int32)IW_FIXED_MUL(w,l);
    return *this;
}




inline CIwVec4 CIwVec4::operator - () const
{
    return CIwVec4(
        (int32)-x
        , (int32)-y
        , (int32)-z
        , (int32)-w
        );
}




inline CIwVec4 CIwVec4::operator / (const iwfixed s) const
{
    return CIwVec4(
        (int32)(IW_FIXED_DIV(x, s))
        , (int32)(IW_FIXED_DIV(y, s))
        , (int32)(IW_FIXED_DIV(z, s))
        , (int32)(IW_FIXED_DIV(w, s))
        );
}




inline CIwVec4 CIwVec4::operator >> (const int s) const
{
    return CIwVec4(
        (int32)(x >> s)
        , (int32)(y >> s)
        , (int32)(z >> s)
        , (int32)(w >> s)
        );
}

inline CIwVec4 CIwVec4::operator >>= (const int s)
{
    x >>= s;
    y >>= s;
    z >>= s;
    w >>= s;
    return *this;
}




inline CIwVec4 CIwVec4::operator << (const int s) const
{







    return CIwVec4(
        (int32)(x << s)
        , (int32)(y << s)
        , (int32)(z << s)
        , (int32)(w << s)
        );
}

inline CIwVec4 CIwVec4::operator <<= (const int s)
{





    x <<= s;
    y <<= s;



    z <<= s;



    w <<= s;
    return *this;
}


inline int32 & CIwVec4::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline int32 CIwVec4::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwVec4 operator * (iwfixed l, const CIwVec4& v)
{
    return v * l;
}







inline CIwVec4::CIwVec4(const CIwSVec4& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    w = (int32)v.w;
}

inline CIwVec4 CIwVec4::operator = (const CIwSVec4& v)
{
    x = (int32)v.x;
    y = (int32)v.y;
    z = (int32)v.z;
    w = (int32)v.w;
    return *this;
}


inline bool operator == (const CIwVec4& v1, const CIwSVec4& v2)
{
    return (
        v1.x == (int32)v2.x &&
        v1.y == (int32)v2.y &&
        v1.z == (int32)v2.z &&
        v1.w == (int32)v2.w &&
        true);
}


inline CIwVec4 operator + (const CIwVec4& v1, const CIwSVec4& v2)
{
    return CIwVec4(
        v1.x + (int32)v2.x
        , v1.y + (int32)v2.y
        , v1.z + (int32)v2.z
        , v1.w + (int32)v2.w
        );
}


inline CIwVec4 operator - (const CIwVec4& v1, const CIwSVec4& v2)
{
    return CIwVec4(
        v1.x - (int32)v2.x
        , v1.y - (int32)v2.y
        , v1.z - (int32)v2.z
        , v1.w - (int32)v2.w
        );
}




inline CIwVec4 operator += (CIwVec4& v1, const CIwSVec4& v2)
{
    v1.x += (int32)v2.x;
    v1.y += (int32)v2.y;
    v1.z += (int32)v2.z;
    v1.w += (int32)v2.w;
    return v1;
}




inline CIwVec4 operator -= (CIwVec4& v1, const CIwSVec4& v2)
{
    v1.x -= (int32)v2.x;
    v1.y -= (int32)v2.y;
    v1.z -= (int32)v2.z;
    v1.w -= (int32)v2.w;
    return v1;
}




inline int32 operator * (const CIwVec4& v1, const CIwSVec4& v2)
{
    return v1 * CIwVec4(v2);
}






# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
class CIwFVec2;
class CIwFVec3;
class CIwFVec4;
class CIwSVec2;
class CIwSVec3;
class CIwSVec4;
class CIwVec2;
class CIwVec3;
class CIwVec4;





class CIwFVec4
{
public:
    float x;
    float y;
    float z;
    float w;


    static CIwFVec4 g_Zero;


    static CIwFVec4 g_AxisX;


    static CIwFVec4 g_AxisY;


    static CIwFVec4 g_AxisZ;


    static CIwFVec4 g_AxisW;




    CIwFVec4() {};
# 86 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) {};

    explicit CIwFVec4(const CIwSVec4& v);
    explicit CIwFVec4(const CIwVec4& v);
    CIwFVec4 operator = (const CIwSVec4& v);
    CIwFVec4 operator = (const CIwVec4& v);
# 104 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
    float GetLength() const;





    inline float GetLengthSquared() const
    {

        return (x*x + y*y+ z*z+ w*w);
    }
# 131 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
    void Normalise();






    CIwFVec4 GetNormalised() const;







    bool IsNormalised() const;
# 159 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
    void Serialise(void);





    bool IsZero() const;






    inline float Dot(CIwFVec4 const & v) const {return *this * v;}
# 188 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4& operator = (CIwFVec4 const & v);






    CIwFVec4 operator + (CIwFVec4 const & v) const;






    CIwFVec4 & operator += (CIwFVec4 const & v);






    CIwFVec4 operator - (CIwFVec4 const & v) const;






    CIwFVec4 & operator -= (CIwFVec4 const & v);






    float operator * (CIwFVec4 const & v) const;







    bool operator == (CIwFVec4 const & v) const;






    bool operator != (CIwFVec4 const & v) const;
# 251 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
    CIwFVec4 operator - () const;






    CIwFVec4 operator * (float l) const;







    CIwFVec4 & operator *= (float l);






    CIwFVec4 operator / (const float s) const;







    float & operator [] (const int n);






    float operator [] (const int n) const;




};




inline CIwFVec4& CIwFVec4::operator = (CIwFVec4 const & v)
{
    x = v.x;
    y = v.y;
    z = v.z;
    w = v.w;
    return *this;
}




inline CIwFVec4 CIwFVec4::operator + (CIwFVec4 const & v) const
{
    return CIwFVec4(
        (float)(x + v.x)
        , (float)(y + v.y)
        , (float)(z + v.z)
        , (float)(w + v.w)
        );
}




inline CIwFVec4 & CIwFVec4::operator += (CIwFVec4 const & v)
{
    x += v.x;
    y += v.y;
    z += v.z;
    w += v.w;
    return *this;
}




inline CIwFVec4 CIwFVec4::operator - (CIwFVec4 const & v) const
{
    return CIwFVec4(
        (float)(x - v.x)
        , (float)(y - v.y)
        , (float)(z - v.z)
        , (float)(w - v.w)
        );
}




inline CIwFVec4 & CIwFVec4::operator -= (CIwFVec4 const & v)
{
    x -= v.x;
    y -= v.y;
    z -= v.z;
    w -= v.w;
    return *this;
}




inline float CIwFVec4::operator * (CIwFVec4 const & v) const
{

    return (
        (float)x * v.x +
        (float)y * v.y +
        (float)z * v.z +
        (float)w * v.w +
        0);
}




inline bool CIwFVec4::operator == (CIwFVec4 const & v) const
{
    return (
        v.x == x &&
        v.y == y &&
        v.z == z &&
        v.w == w &&
        true);
}




inline bool CIwFVec4::operator != (CIwFVec4 const & v) const
{
    return (
        v.x != x ||
        v.y != y ||
        v.z != z ||
        v.w != w ||
        false);
}




inline CIwFVec4 CIwFVec4::operator * (float l) const
{
    return CIwFVec4(
        (float)(x * l)
        , (float)(y * l)
        , (float)(z * l)
        , (float)(w * l)
        );
}




inline CIwFVec4 & CIwFVec4::operator *= (float l)
{
    x = (float)(x * l);
    y = (float)(y * l);
    z = (float)(z * l);
    w = (float)(w * l);
    return *this;
}




inline CIwFVec4 CIwFVec4::operator - () const
{
    return CIwFVec4(
        (float)-x
        , (float)-y
        , (float)-z
        , (float)-w
        );
}




inline CIwFVec4 CIwFVec4::operator / (const float s) const
{
    return CIwFVec4(
        (float)(x / s)
        , (float)(y / s)
        , (float)(z / s)
        , (float)(w / s)
        );
}


inline float & CIwFVec4::operator [] (const int n)
{
    ((void)0);
    return (&x)[n];
}


inline float CIwFVec4::operator [] (const int n) const
{
    ((void)0);
    return (&x)[n];
}





inline CIwFVec4 operator * (float l, const CIwFVec4& v)
{
    return v * l;
}







inline CIwFVec4::CIwFVec4(const CIwSVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
}

inline CIwFVec4 CIwFVec4::operator = (const CIwSVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
    return *this;
}


inline bool operator == (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        v1.w == ((float)(v2.w) / (float)(1 << 12)) &&
        true);
}


inline CIwFVec4 operator + (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return CIwFVec4(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        , v1.w + ((float)(v2.w) / (float)(1 << 12))
        );
}


inline CIwFVec4 operator - (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return CIwFVec4(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        , v1.w - ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator += (CIwFVec4& v1, const CIwSVec4& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    v1.w += ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline CIwFVec4 operator -= (CIwFVec4& v1, const CIwSVec4& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    v1.w -= ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec4& v1, const CIwSVec4& v2)
{
    return v1 * CIwFVec4(v2);
}
# 566 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFVec4.h"
inline CIwFVec4::CIwFVec4(const CIwVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
}




inline CIwFVec4 CIwFVec4::operator = (const CIwVec4& v)
{
    x = ((float)(v.x) / (float)(1 << 12));
    y = ((float)(v.y) / (float)(1 << 12));
    z = ((float)(v.z) / (float)(1 << 12));
    w = ((float)(v.w) / (float)(1 << 12));
    return *this;
}




inline bool operator == (const CIwFVec4& v1, const CIwVec4& v2)
{
    return (
        v1.x == ((float)(v2.x) / (float)(1 << 12)) &&
        v1.y == ((float)(v2.y) / (float)(1 << 12)) &&
        v1.z == ((float)(v2.z) / (float)(1 << 12)) &&
        v1.w == ((float)(v2.w) / (float)(1 << 12)) &&
        true);
}




inline CIwFVec4 operator + (const CIwFVec4& v1, const CIwVec4& v2)
{
    return CIwFVec4(
        v1.x + ((float)(v2.x) / (float)(1 << 12))
        , v1.y + ((float)(v2.y) / (float)(1 << 12))
        , v1.z + ((float)(v2.z) / (float)(1 << 12))
        , v1.w + ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator - (const CIwFVec4& v1, const CIwVec4& v2)
{
    return CIwFVec4(
        v1.x - ((float)(v2.x) / (float)(1 << 12))
        , v1.y - ((float)(v2.y) / (float)(1 << 12))
        , v1.z - ((float)(v2.z) / (float)(1 << 12))
        , v1.w - ((float)(v2.w) / (float)(1 << 12))
        );
}




inline CIwFVec4 operator += (CIwFVec4& v1, const CIwVec4& v2)
{
    v1.x += ((float)(v2.x) / (float)(1 << 12));
    v1.y += ((float)(v2.y) / (float)(1 << 12));
    v1.z += ((float)(v2.z) / (float)(1 << 12));
    v1.w += ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline CIwFVec4 operator -= (CIwFVec4& v1, const CIwVec4& v2)
{
    v1.x -= ((float)(v2.x) / (float)(1 << 12));
    v1.y -= ((float)(v2.y) / (float)(1 << 12));
    v1.z -= ((float)(v2.z) / (float)(1 << 12));
    v1.w -= ((float)(v2.w) / (float)(1 << 12));
    return v1;
}




inline float operator * (const CIwFVec4& v1, const CIwVec4& v2)
{
    return v1 * CIwFVec4(v2);
}
# 760 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec4.h" 2

inline CIwVec4::CIwVec4(const CIwFVec4& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    w = IW_FIXED_FROM_FLOAT(v.w);
}




inline CIwVec4 CIwVec4::operator = (const CIwFVec4& v)
{
    x = IW_FIXED_FROM_FLOAT(v.x);
    y = IW_FIXED_FROM_FLOAT(v.y);
    z = IW_FIXED_FROM_FLOAT(v.z);
    w = IW_FIXED_FROM_FLOAT(v.w);
    return *this;
}




inline bool operator == (const CIwVec4& v1, const CIwFVec4& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        ((float)(v1.w) / (float)(1 << 12)) == v2.w &&
        true);
}




inline CIwFVec4 operator + (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        , ((float)(v1.w) / (float)(1 << 12)) + v2.w
        );
}




inline CIwFVec4 operator - (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        , ((float)(v1.w) / (float)(1 << 12)) - v2.w
        );
}




inline CIwVec4 operator += (CIwVec4& v1, const CIwFVec4& v2)
{
    v1.x += IW_FIXED_FROM_FLOAT(v2.x);
    v1.y += IW_FIXED_FROM_FLOAT(v2.y);
    v1.z += IW_FIXED_FROM_FLOAT(v2.z);
    v1.w += IW_FIXED_FROM_FLOAT(v2.w);
    return v1;
}




inline CIwVec4 operator -= (CIwVec4& v1, const CIwFVec4& v2)
{
    v1.x -= IW_FIXED_FROM_FLOAT(v2.x);
    v1.y -= IW_FIXED_FROM_FLOAT(v2.y);
    v1.z -= IW_FIXED_FROM_FLOAT(v2.z);
    v1.w -= IW_FIXED_FROM_FLOAT(v2.w);
    return v1;
}




inline float operator * (const CIwVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(v1) * v2;
}
# 671 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h" 2

inline CIwSVec4::CIwSVec4(const CIwVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    w = IW_SFIXED_FROM_FIXED(v.w);
}

inline CIwSVec4 CIwSVec4::operator = (const CIwVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(v.x);
    y = IW_SFIXED_FROM_FIXED(v.y);
    z = IW_SFIXED_FROM_FIXED(v.z);
    w = IW_SFIXED_FROM_FIXED(v.w);
    return *this;
}


inline bool operator == (const CIwSVec4& v1, const CIwVec4& v2)
{
    return (
        (int32)v1.x == v2.x &&
        (int32)v1.y == v2.y &&
        (int32)v1.z == v2.z &&
        (int32)v1.w == v2.w &&
        true);
}


inline CIwVec4 operator + (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(
        (int32)v1.x + v2.x
        , (int32)v1.y + v2.y
        , (int32)v1.z + v2.z
        , (int32)v1.w + v2.w
        );
}


inline CIwVec4 operator - (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(
        (int32)v1.x - v2.x
        , (int32)v1.y - v2.y
        , (int32)v1.z - v2.z
        , (int32)v1.w - v2.w
        );
}




inline CIwSVec4 operator += (CIwSVec4& v1, const CIwVec4& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(v2.x);
    v1.y += IW_SFIXED_FROM_FIXED(v2.y);
    v1.z += IW_SFIXED_FROM_FIXED(v2.z);
    v1.w += IW_SFIXED_FROM_FIXED(v2.w);
    return v1;
}




inline CIwSVec4 operator -= (CIwSVec4& v1, const CIwVec4& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(v2.x);
    v1.y -= IW_SFIXED_FROM_FIXED(v2.y);
    v1.z -= IW_SFIXED_FROM_FIXED(v2.z);
    v1.w -= IW_SFIXED_FROM_FIXED(v2.w);
    return v1;
}




inline int32 operator * (const CIwSVec4& v1, const CIwVec4& v2)
{
    return CIwVec4(v1) * v2;
}
# 761 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSVec4.h"
inline CIwSVec4::CIwSVec4(const CIwFVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    w = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.w));
}




inline CIwSVec4 CIwSVec4::operator = (const CIwFVec4& v)
{
    x = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.x));
    y = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.y));
    z = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.z));
    w = IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v.w));
    return *this;
}




inline bool operator == (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return (
        ((float)(v1.x) / (float)(1 << 12)) == v2.x &&
        ((float)(v1.y) / (float)(1 << 12)) == v2.y &&
        ((float)(v1.z) / (float)(1 << 12)) == v2.z &&
        ((float)(v1.w) / (float)(1 << 12)) == v2.w &&
        true);
}




inline CIwFVec4 operator + (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) + v2.x
        , ((float)(v1.y) / (float)(1 << 12)) + v2.y
        , ((float)(v1.z) / (float)(1 << 12)) + v2.z
        , ((float)(v1.w) / (float)(1 << 12)) + v2.w
        );
}




inline CIwFVec4 operator - (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(
        ((float)(v1.x) / (float)(1 << 12)) - v2.x
        , ((float)(v1.y) / (float)(1 << 12)) - v2.y
        , ((float)(v1.z) / (float)(1 << 12)) - v2.z
        , ((float)(v1.w) / (float)(1 << 12)) - v2.w
        );
}




inline CIwSVec4 operator += (CIwSVec4& v1, const CIwFVec4& v2)
{
    v1.x += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    v1.w += IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.w));
    return v1;
}




inline CIwSVec4 operator -= (CIwSVec4& v1, const CIwFVec4& v2)
{
    v1.x -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.x));
    v1.y -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.y));
    v1.z -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.z));
    v1.w -= IW_SFIXED_FROM_FIXED(IW_FIXED_FROM_FLOAT(v2.w));
    return v1;
}




inline float operator * (const CIwSVec4& v1, const CIwFVec4& v2)
{
    return CIwFVec4(v1) * v2;
}
# 36 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomVec.h" 2
# 23 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h" 1
       
# 35 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
class CIwFMat;
# 63 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
class CIwMat
{
public:



    iwfixed m[3][3];



    CIwVec3 t;




    static CIwMat g_Identity;




    CIwMat() {};





    explicit CIwMat(iwfixed f)
    {
        m[0][0] = m[1][1] = m[2][2] = f;
        m[0][1] = m[0][2] = m[1][0] = m[1][2] = m[2][0] = m[2][1] = 0;
        t.x = t.y = t.z = 0;
    }






    explicit CIwMat(const CIwFMat & M);





    inline CIwFMat ConvertToCIwFMat();
# 116 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    CIwMat(CIwMat const & R, CIwVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }







    CIwMat(CIwMat const & R, CIwSVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }






    void Serialise();





    void Normalise()
    {
        CIwVec3* pVecX = (CIwVec3*)&m[0][0];
        CIwVec3* pVecY = (CIwVec3*)&m[1][0];
        CIwVec3* pVecZ = (CIwVec3*)&m[2][0];

        pVecZ->Normalise();




        pVecX->Normalise();

        *pVecY = *pVecZ ^ *pVecX;
# 183 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
        ((void)0);



        pVecY->Normalise();

        *pVecX = *pVecY ^ *pVecZ;
    }




    void Transpose();





    CIwVec3 const & GetTrans() const
    {
        return t;
    }






    CIwMat & SetTrans(CIwVec3 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat & SetTrans(CIwSVec3 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat & operator += (CIwVec3 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat & operator += (CIwSVec3 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat operator + (CIwVec3 const & V) const
    {
        return CIwMat(*this, t+V);
    }






    CIwMat operator + (CIwSVec3 const & V) const
    {
        return CIwMat(*this, t+V);
    }







    CIwMat& operator <<= (int32 s)
    {
        m[0][0] <<= s; m[0][1] <<= s; m[0][2] <<= s;
        m[1][0] <<= s; m[1][1] <<= s; m[1][2] <<= s;
        m[2][0] <<= s; m[2][1] <<= s; m[2][2] <<= s;
        t.x <<= s, t.y <<= s, t.z <<= s;
        return *this;
    }






    CIwMat& operator >>= (int32 s)
    {
        m[0][0] >>= s; m[0][1] >>= s; m[0][2] >>= s;
        m[1][0] >>= s; m[1][1] >>= s; m[1][2] >>= s;
        m[2][0] >>= s; m[2][1] >>= s; m[2][2] >>= s;
        t.x >>= s, t.y >>= s, t.z >>= s;
        return *this;
    }





    CIwVec3 ColumnX() const
    {
        return CIwVec3(m[0][0], m[1][0], m[2][0]);
    }




    CIwVec3 ColumnY() const
    {
        return CIwVec3(m[0][1], m[1][1], m[2][1]);
    }




    CIwVec3 ColumnZ() const
    {
        return CIwVec3(m[0][2], m[1][2], m[2][2]);
    }







    CIwVec3 RowX() const
    {
        return CIwVec3(m[0][0], m[0][1], m[0][2]);
    }







    CIwVec3 RowY() const
    {
        return CIwVec3(m[1][0], m[1][1], m[1][2]);
    }







    CIwVec3 RowZ() const
    {
        return CIwVec3(m[2][0], m[2][1], m[2][2]);
    }







    CIwVec3 RotateVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwSVec3 RotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z))
        );
    }







    CIwVec3 RotateVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwVec3 TransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }
# 424 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVec(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }
# 441 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVecShift(CIwSVec3 const &V, int32 shift) const
    {
        int32 lDotShift = 12 - shift;
        return CIwVec3(
        IW_MUL_3_SHIFT(m[0][0] >> shift, m[1][0] >> shift, m[2][0] >> shift, V.x, V.y, V.z, lDotShift) + t.x,
        IW_MUL_3_SHIFT(m[0][1] >> shift, m[1][1] >> shift, m[2][1] >> shift, V.x, V.y, V.z, lDotShift) + t.y,
        IW_MUL_3_SHIFT(m[0][2] >> shift, m[1][2] >> shift, m[2][2] >> shift, V.x, V.y, V.z, lDotShift) + t.z
        );
    }
# 459 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransformVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }






    CIwVec3 TransformVecSafe(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[1][0], m[2][0], V.x, V.y, V.z) + t.x,
        IW_FIXED_MUL3_SAFE(m[0][1], m[1][1], m[2][1], V.x, V.y, V.z) + t.y,
        IW_FIXED_MUL3_SAFE(m[0][2], m[1][2], m[2][2], V.x, V.y, V.z) + t.z
        );
    }







    CIwVec3 TransposeRotateVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z),
        IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z)
        );
    }







    CIwSVec3 TransposeRotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z))
        );
    }







    CIwVec3 TransposeRotateVecSafe(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_MUL3_SAFE(m[0][0], m[0][1], m[0][2], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[1][0], m[1][1], m[1][2], V.x, V.y, V.z),
        IW_FIXED_MUL3_SAFE(m[2][0], m[2][1], m[2][2], V.x, V.y, V.z)
        );
    }
# 534 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    CIwVec3 TransposeTransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
            IW_FIXED_MUL3(m[0][0], m[0][1], m[0][2], V.x-t.x, V.y-t.y, V.z-t.z),
            IW_FIXED_MUL3(m[1][0], m[1][1], m[1][2], V.x-t.x, V.y-t.y, V.z-t.z),
            IW_FIXED_MUL3(m[2][0], m[2][1], m[2][2], V.x-t.x, V.y-t.y, V.z-t.z)
            );
    }
# 551 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    iwfixed TransformVecX(CIwVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],V.x,V.y,V.z)) + (t.x)); }
    iwfixed TransformVecY(CIwVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],V.x,V.y,V.z)) + (t.y)); }
    iwfixed TransformVecZ(CIwVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],V.x,V.y,V.z)) + (t.z)); }
    iwfixed TransformVecZ(CIwSVec3 const &V) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],V.x,V.y,V.z)) + (t.z)); }
    iwfixed TransformVecX(iwsfixed x, iwsfixed y, iwsfixed z) const { return ((IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],x,y,z)) + (t.x)); }
    iwfixed TransformVecY(iwsfixed x, iwsfixed y, iwsfixed z) const { return ((IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],x,y,z)) + (t.y)); }
    iwfixed TransformVecZ(iwsfixed x, iwsfixed y, iwsfixed z) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],x,y,z)) + (t.z)); }
    iwfixed TransformVecX(iwfixed x, iwfixed y, iwfixed z) const { return ((IW_FIXED_MUL3(m[0][0],m[1][0],m[2][0],x,y,z)) + (t.x)); }
    iwfixed TransformVecY(iwfixed x, iwfixed y, iwfixed z) const { return ((IW_FIXED_MUL3(m[0][1],m[1][1],m[2][1],x,y,z)) + (t.y)); }
    iwfixed TransformVecZ(iwfixed x, iwfixed y, iwfixed z) const { return ((IW_FIXED_MUL3(m[0][2],m[1][2],m[2][2],x,y,z)) + (t.z)); }







    inline iwfixed RotateVecX(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y) + IW_FIXED_MUL(m[2][0], V.z);
    }





    inline iwfixed RotateVecY(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y) + IW_FIXED_MUL(m[2][1], V.z);
    }





    inline iwfixed RotateVecZ(const CIwVec3& V) const
    {
            return IW_FIXED_MUL(m[0][2], V.x) + IW_FIXED_MUL(m[1][2], V.y) + IW_FIXED_MUL(m[2][2], V.z);
    }







    inline iwsfixed RotateVecX(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y) + IW_FIXED_MUL(m[2][0], V.z));
    }





    inline iwsfixed RotateVecY(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y) + IW_FIXED_MUL(m[2][1], V.z));
    }





    inline iwsfixed RotateVecZ(const CIwSVec3& V) const
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][2], V.x) + IW_FIXED_MUL(m[1][2], V.y) + IW_FIXED_MUL(m[2][2], V.z));
    }





    CIwMat GetTranspose() const
    {
        CIwMat N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[2][0] = m[0][2];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];
        N.m[2][1] = m[1][2];
        N.m[0][2] = m[2][0];
        N.m[1][2] = m[2][1];
        N.m[2][2] = m[2][2];


        N.t = CIwVec3(0, 0, 0);
        return N;
    }
# 650 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    inline void SetRotX(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[0][2] = m[1][0] = m[2][0] = 0;
        m[0][0] = (1 << 12);
        m[1][1] = m[2][2] = IwGeomCos(r);
        m[1][2] = -(m[2][1] = IwGeomSin(r));
    }







    inline void SetRotY(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[1][2] = m[1][0] = m[2][1] = 0;
        m[1][1] = (1 << 12);
        m[0][0] = m[2][2] = IwGeomCos(r);
        m[2][0] = -(m[0][2] = IwGeomSin(r));
    }







    inline void SetRotZ(iwangle r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][2] = m[1][2] = m[2][0] = m[2][1] = 0;
        m[2][2] = (1 << 12);
        m[0][0] = m[1][1] = IwGeomCos(r);
        m[0][1] = -(m[1][0] = IwGeomSin(r));
    }


    inline void PreRotateX(iwangle r)
    {
        CIwMat rx;
        rx.SetRotX(r, true, true);
        PreRotate(rx);
    }
    inline void PreRotateY(iwangle r)
    {
        CIwMat ry;
        ry.SetRotY(r, true, true);
        PreRotate(ry);
    }
    inline void PreRotateZ(iwangle r)
    {
        CIwMat rz;
        rz.SetRotZ(r, true, true);
        PreRotate(rz);
    }
    inline void PostRotateX(iwangle r)
    {
        CIwMat rx;
        rx.SetRotX(r, true, true);
        PostRotate(rx);
    }
    inline void PostRotateY(iwangle r)
    {
        CIwMat ry;
        ry.SetRotY(r, true, true);
        PostRotate(ry);
    }
    inline void PostRotateZ(iwangle r)
    {
        CIwMat rz;
        rz.SetRotZ(r, true, true);
        PostRotate(rz);
    }







    void SetAxisAngle(CIwVec3 axis, iwangle angle);






    void LookAt(const CIwVec3& from, const CIwVec3& to, const CIwVec3& up)
    {

        CIwVec3 vx, vy, vz;

        vz = (to - from).GetNormalised();
        vx = (up ^ vz);
        if (vx.IsZero())
            vx.x = (1 << 12);
        else
            vx.Normalise();
        vy = (vz ^ vx);
        m[0][0] = vx.x; m[0][1] = vx.y; m[0][2] = vx.z;
        m[1][0] = vy.x; m[1][1] = vy.y; m[1][2] = vy.z;
        m[2][0] = vz.x; m[2][1] = vz.y; m[2][2] = vz.z;
    }







    CIwMat operator * (CIwMat const & M) const
    {
        CIwMat N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwMat & PreMult(CIwMat const & M)
    {
        return (*this = M * (*this));
    }




    CIwMat & PreMultiply(CIwMat const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwMat & PostMult(CIwMat const & M)
    {
        return (*this = (*this) * M);
    }




    CIwMat & PostMultiply(CIwMat const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwMat& operator *= (CIwMat const & M)
    {
        return PostMult(M);
    }







    CIwMat& PostRotate(CIwMat const& M)
    {
        CIwMat N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        CopyRot(N);

        return *this;
    }






    CIwMat PreRotate(CIwMat const& M)
    {
        CIwMat t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwMat& ScaleRot(iwfixed v)
    {
        for (int i=0; i<3; i++)
            for (int j=0; j<3; j++)
                m[i][j] = IW_FIXED_MUL(m[i][j],v);
        return *this;
    }






    CIwMat& ScaleTrans(iwfixed v)
    {
        t *= v;
        return *this;
    }





    CIwMat& Scale(iwfixed v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwMat& operator *= (const iwfixed v)
    {
        Scale(v);
        return *this;
    }
# 933 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    void InterpRot(CIwMat const & m0, CIwMat const & m1, iwfixed fraction);


    void InterpolateRot(CIwMat const & m0, CIwMat const & m1, iwfixed fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 952 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
    void InterpTrans(CIwMat const & m0, CIwMat const & m1, iwfixed fraction);


    void InterpolatePos(CIwMat const & m0, CIwMat const & m1, iwfixed fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwMat& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[0][2] = m0.m[0][2];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
        m[1][2] = m0.m[1][2];
        m[2][0] = m0.m[2][0];
        m[2][1] = m0.m[2][1];
        m[2][2] = m0.m[2][2];
    }





    void CopyTrans(const CIwMat& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwMat const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[0][2] == m0.m[0][2] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1] &&
        m[1][2] == m0.m[1][2] &&
        m[2][0] == m0.m[2][0] &&
        m[2][1] == m0.m[2][1] &&
        m[2][2] == m0.m[2][2];
    }






    bool IsTransSame(CIwMat const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwMat const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwMat const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity() const
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity() const
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity() const
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero() const
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[0][2] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0 &&
        m[1][2] == 0 &&
        m[2][0] == 0 &&
        m[2][1] == 0 &&
        m[2][2] == 0;
    }


    bool IsTransZero() const
    {
        return t.x == 0 &&
        t.y == 0 &&
        t.z == 0;
    }


    bool IsZero() const
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }
# 1121 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
private:


    static inline iwfixed FindComponentFromBA(const CIwMat& A, const CIwMat& B, const int i, const int j)
    {
# 1143 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
        return (B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j] + B.m[i][2]*A.m[2][j]) >> 12;
    }



};
# 1157 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h"
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h" 1
       
# 35 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
class CIwMat;
# 63 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
class CIwFMat
{
public:



    float m[3][3];



    CIwFVec3 t;




    static CIwFMat g_Identity;




    CIwFMat() {};





    explicit CIwFMat(float f)
    {
        m[0][0] = m[1][1] = m[2][2] = f;
        m[0][1] = m[0][2] = m[1][0] = m[1][2] = m[2][0] = m[2][1] = 0;
        t.x = t.y = t.z = 0;
    }






    explicit CIwFMat(const CIwMat & M);





    inline CIwMat ConvertToCIwMat();
# 116 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
    CIwFMat(CIwFMat const & R, CIwFVec3 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[2][0] = R.m[2][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        m[2][1] = R.m[2][1];
        m[0][2] = R.m[0][2];
        m[1][2] = R.m[1][2];
        m[2][2] = R.m[2][2];
        t = T;
    }







    void Serialise();





    void Normalise()
    {
        CIwFVec3* pVecX = (CIwFVec3*)&m[0][0];
        CIwFVec3* pVecY = (CIwFVec3*)&m[1][0];
        CIwFVec3* pVecZ = (CIwFVec3*)&m[2][0];

        pVecZ->Normalise();


        *pVecY = *pVecZ ^ *pVecX;
# 160 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
        ((void)0);



        pVecY->Normalise();

        *pVecX = *pVecY ^ *pVecZ;
    }




    void Transpose();





    CIwFVec3 const & GetTrans() const
    {
        return t;
    }






    CIwFMat & SetTrans(CIwFVec3 const & v)
    {
        t = v;
        return *this;
    }







    CIwFMat & operator += (CIwFVec3 const & V)
    {
        t += V;
        return *this;
    }







    CIwFMat operator + (CIwFVec3 const & V) const
    {
        return CIwFMat(*this, t+V);
    }
# 225 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
    CIwFVec3 ColumnX() const
    {
        return CIwFVec3(m[0][0], m[1][0], m[2][0]);
    }




    CIwFVec3 ColumnY() const
    {
        return CIwFVec3(m[0][1], m[1][1], m[2][1]);
    }




    CIwFVec3 ColumnZ() const
    {
        return CIwFVec3(m[0][2], m[1][2], m[2][2]);
    }







    CIwFVec3 RowX() const
    {
        return CIwFVec3(m[0][0], m[0][1], m[0][2]);
    }







    CIwFVec3 RowY() const
    {
        return CIwFVec3(m[1][0], m[1][1], m[1][2]);
    }







    CIwFVec3 RowZ() const
    {
        return CIwFVec3(m[2][0], m[2][1], m[2][2]);
    }






    CIwFVec3 RotateVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)),
        ((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)),
        ((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))
        );
    }

    CIwSVec3 RotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))
        );
    }







    CIwFVec3 TransformVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z)) + t.x,
        ((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z)) + t.y,
        ((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z)) + t.z
        );
    }

    CIwVec3 TransformVec(CIwVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z) + t.x),
        IW_FIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z) + t.y),
        IW_FIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z) + t.z)
        );
    }

    CIwVec3 TransformVec(CIwSVec3 const &V) const
    {
        return CIwVec3(
        IW_FIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z) + t.x),
        IW_FIXED_FROM_FLOAT_CAST((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z) + t.y),
        IW_FIXED_FROM_FLOAT_CAST((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z) + t.z)
        );
    }






    CIwFVec3 TransposeRotateVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
        ((m[0][0] * V.x) + (m[0][1] * V.y) + (m[0][2] * V.z)),
        ((m[1][0] * V.x) + (m[1][1] * V.y) + (m[1][2] * V.z)),
        ((m[2][0] * V.x) + (m[2][1] * V.y) + (m[2][2] * V.z))
        );
    }

    CIwSVec3 TransposeRotateVec(CIwSVec3 const &V) const
    {
        return CIwSVec3(
        IW_SFIXED_FROM_FLOAT_CAST((m[0][0] * V.x) + (m[0][1] * V.y) + (m[0][2] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[1][0] * V.x) + (m[1][1] * V.y) + (m[1][2] * V.z)),
        IW_SFIXED_FROM_FLOAT_CAST((m[2][0] * V.x) + (m[2][1] * V.y) + (m[2][2] * V.z))
        );
    }
# 366 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
    CIwFVec3 TransposeTransformVec(CIwFVec3 const &V) const
    {
        return CIwFVec3(
            ((m[0][0] * (V.x-t.x)) + (m[0][1] * (V.y-t.y)) + (m[0][2] * (V.z-t.z))),
            ((m[1][0] * (V.x-t.x)) + (m[1][1] * (V.y-t.y)) + (m[1][2] * (V.z-t.z))),
            ((m[2][0] * (V.x-t.x)) + (m[2][1] * (V.y-t.y)) + (m[2][2] * (V.z-t.z)))
            );
    }


    float TransformVecX(CIwFVec3 const &V) const { return (((m[0][0] * V.x) + (m[1][0] * V.y) + (m[2][0] * V.z))) + t.x; }
    float TransformVecY(CIwFVec3 const &V) const { return (((m[0][1] * V.x) + (m[1][1] * V.y) + (m[2][1] * V.z))) + t.y; }
    float TransformVecZ(CIwFVec3 const &V) const { return (((m[0][2] * V.x) + (m[1][2] * V.y) + (m[2][2] * V.z))) + t.z; }
    float TransformVecX(float x, float y, float z) const { return (((m[0][0] * x) + (m[1][0] * y) + (m[2][0] * z))) + t.x; }
    float TransformVecY(float x, float y, float z) const { return (((m[0][1] * x) + (m[1][1] * y) + (m[2][1] * z))) + t.y; }
    float TransformVecZ(float x, float y, float z) const { return (((m[0][2] * x) + (m[1][2] * y) + (m[2][2] * z))) + t.z; }







    inline float RotateVecX(const CIwFVec3& V) const
    {
            return m[0][0] * V.x + m[1][0] * V.y + m[2][0] * V.z;
    }





    inline float RotateVecY(const CIwFVec3& V) const
    {
            return m[0][1] * V.x + m[1][1] * V.y + m[2][1] * V.z;
    }





    inline float RotateVecZ(const CIwFVec3& V) const
    {
            return m[0][2] * V.x + m[1][2] * V.y + m[2][2] * V.z;
    }







    CIwFMat GetTranspose() const
    {
        CIwFMat N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[2][0] = m[0][2];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];
        N.m[2][1] = m[1][2];
        N.m[0][2] = m[2][0];
        N.m[1][2] = m[2][1];
        N.m[2][2] = m[2][2];


        N.t = CIwFVec3(0, 0, 0);
        return N;
    }
# 444 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
    inline void SetRotX(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[0][2] = m[1][0] = m[2][0] = 0;
        m[0][0] = 1.0f;
        m[1][1] = m[2][2] = (float)cos(r);
        m[1][2] = -(m[2][1] = (float)sin(r));
    }







    inline void SetRotY(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][1] = m[1][2] = m[1][0] = m[2][1] = 0;
        m[1][1] = 1.0f;
        m[0][0] = m[2][2] = (float)cos(r);
        m[2][0] = -(m[0][2] = (float)sin(r));
    }







    inline void SetRotZ(float r = 0, bool resetTrans = true, bool setZeros = true)
    {
        if (resetTrans) t.x = t.y = t.z = 0;
        if (setZeros) m[0][2] = m[1][2] = m[2][0] = m[2][1] = 0;
        m[2][2] = 1.0f;
        m[0][0] = m[1][1] = (float)cos(r);
        m[0][1] = -(m[1][0] = (float)sin(r));
    }


    inline void PreRotateX(float r)
    {
        CIwFMat rx;
        rx.SetRotX(r, true, true);
        PreRotate(rx);
    }
    inline void PreRotateY(float r)
    {
        CIwFMat ry;
        ry.SetRotY(r, true, true);
        PreRotate(ry);
    }
    inline void PreRotateZ(float r)
    {
        CIwFMat rz;
        rz.SetRotZ(r, true, true);
        PreRotate(rz);
    }
    inline void PostRotateX(float r)
    {
        CIwFMat rx;
        rx.SetRotX(r, true, true);
        PostRotate(rx);
    }
    inline void PostRotateY(float r)
    {
        CIwFMat ry;
        ry.SetRotY(r, true, true);
        PostRotate(ry);
    }
    inline void PostRotateZ(float r)
    {
        CIwFMat rz;
        rz.SetRotZ(r, true, true);
        PostRotate(rz);
    }







    void SetAxisAngle(CIwFVec3 axis, float angle);






    void LookAt(const CIwFVec3& from, const CIwFVec3& to, const CIwFVec3& up)
    {

        CIwFVec3 vx, vy, vz;

        vz = (to - from).GetNormalised();
        vx = (up ^ vz);
        if (vx.IsZero())
            vx.x = 1.0f;
        else
            vx.Normalise();
        vy = (vz ^ vx);
        m[0][0] = vx.x; m[0][1] = vx.y; m[0][2] = vx.z;
        m[1][0] = vy.x; m[1][1] = vy.y; m[1][2] = vy.z;
        m[2][0] = vz.x; m[2][1] = vz.y; m[2][2] = vz.z;
    }







    CIwFMat operator * (CIwFMat const & M) const
    {
        CIwFMat N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwFMat & PreMult(CIwFMat const & M)
    {
        return (*this = M * (*this));
    }




    CIwFMat & PreMultiply(CIwFMat const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwFMat & PostMult(CIwFMat const & M)
    {
        return (*this = (*this) * M);
    }




    CIwFMat & PostMultiply(CIwFMat const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwFMat& operator *= (CIwFMat const & M)
    {
        return PostMult(M);
    }







    CIwFMat& PostRotate(CIwFMat const& M)
    {
        CIwFMat N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);
        N.m[0][2] = FindComponentFromBA(M,*this,0,2);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);
        N.m[1][2] = FindComponentFromBA(M,*this,1,2);

        N.m[2][0] = FindComponentFromBA(M,*this,2,0);
        N.m[2][1] = FindComponentFromBA(M,*this,2,1);
        N.m[2][2] = FindComponentFromBA(M,*this,2,2);

        CopyRot(N);

        return *this;
    }






    CIwFMat PreRotate(CIwFMat const& M)
    {
        CIwFMat t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwFMat& ScaleRot(float v)
    {
        for (int i=0; i<3; i++)
            for (int j=0; j<3; j++)
                m[i][j] = (m[i][j]*v);
        return *this;
    }






    CIwFMat& ScaleTrans(float v)
    {
        t *= v;
        return *this;
    }





    CIwFMat& Scale(float v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwFMat& operator *= (const float v)
    {
        Scale(v);
        return *this;
    }
# 727 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
    void InterpRot(CIwFMat const & m0, CIwFMat const & m1, float fraction);


    void InterpolateRot(CIwFMat const & m0, CIwFMat const & m1, float fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 746 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
    void InterpTrans(CIwFMat const & m0, CIwFMat const & m1, float fraction);


    void InterpolatePos(CIwFMat const & m0, CIwFMat const & m1, float fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwFMat& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[0][2] = m0.m[0][2];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
        m[1][2] = m0.m[1][2];
        m[2][0] = m0.m[2][0];
        m[2][1] = m0.m[2][1];
        m[2][2] = m0.m[2][2];
    }





    void CopyTrans(const CIwFMat& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwFMat const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[0][2] == m0.m[0][2] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1] &&
        m[1][2] == m0.m[1][2] &&
        m[2][0] == m0.m[2][0] &&
        m[2][1] == m0.m[2][1] &&
        m[2][2] == m0.m[2][2];
    }






    bool IsTransSame(CIwFMat const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwFMat const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwFMat const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity() const
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity() const
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity() const
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero() const
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[0][2] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0 &&
        m[1][2] == 0 &&
        m[2][0] == 0 &&
        m[2][1] == 0 &&
        m[2][2] == 0;
    }


    bool IsTransZero() const
    {
        return t.x == 0 &&
        t.y == 0 &&
        t.z == 0;
    }


    bool IsZero() const
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }
# 975 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
private:


    static inline float FindComponentFromBA(const CIwFMat& A, const CIwFMat& B, const int i, const int j)
    {
        return B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j] + B.m[i][2]*A.m[2][j];

    }



};
# 998 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat.h"
inline CIwMat CIwFMat::ConvertToCIwMat()
    {
        return CIwMat(*this);
    }
# 1158 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat.h" 2


inline CIwFMat CIwMat::ConvertToCIwFMat()
    {
        return CIwFMat(*this);
    }
# 24 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h" 1
       
# 35 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
class CIwFMat2D;
# 63 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
class CIwMat2D
{
public:



    iwfixed m[2][2];



    CIwVec2 t;




    static CIwMat2D g_Identity;




    CIwMat2D() {};





    explicit CIwMat2D(iwfixed f)
    {
        m[0][0] = m[1][1] = f;
        m[0][1] = m[1][0] = 0;
        t.x = t.y = 0;
    }






    explicit CIwMat2D(const CIwFMat2D & M);





    inline CIwFMat2D ConvertToCIwFMat2D();
# 116 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    CIwMat2D(CIwMat2D const & R, CIwVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }







    CIwMat2D(CIwMat2D const & R, CIwSVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }






    void Serialise();





    void Normalise()
    {
        CIwVec2* pVecX = (CIwVec2*)&m[0][0];
        CIwVec2* pVecY = (CIwVec2*)&m[1][0];

        pVecX->Normalise();

        *pVecY = CIwVec2(-pVecX->y, pVecX->x);
    }




    void Transpose();





    CIwVec2 const & GetTrans() const
    {
        return t;
    }






    CIwMat2D & SetTrans(CIwVec2 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat2D & SetTrans(CIwSVec2 const & v)
    {
        t = v;
        return *this;
    }






    CIwMat2D & operator += (CIwVec2 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat2D & operator += (CIwSVec2 const & V)
    {
        t += V;
        return *this;
    }






    CIwMat2D operator + (CIwVec2 const & V) const
    {
        return CIwMat2D(*this, t+V);
    }






    CIwMat2D operator + (CIwSVec2 const & V) const
    {
        return CIwMat2D(*this, t+V);
    }







    CIwMat2D& operator <<= (int32 s)
    {
        m[0][0] <<= s; m[0][1] <<= s;
        m[1][0] <<= s; m[1][1] <<= s;
        t.x <<= s, t.y <<= s;
        return *this;
    }






    CIwMat2D& operator >>= (int32 s)
    {
        m[0][0] >>= s; m[0][1] >>= s;
        m[1][0] >>= s; m[1][1] >>= s;
        t.x >>= s, t.y >>= s;
        return *this;
    }





    CIwVec2 ColumnX() const
    {
        return CIwVec2(m[0][0], m[1][0]);
    }




    CIwVec2 ColumnY() const
    {
        return CIwVec2(m[0][1], m[1][1]);
    }







    CIwVec2 RowX() const
    {
        return CIwVec2(m[0][0], m[0][1]);
    }







    CIwVec2 RowY() const
    {
        return CIwVec2(m[1][0], m[1][1]);
    }







    CIwVec2 RotateVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y),
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y)
        );
    }







    CIwSVec2 RotateVec(CIwSVec2 const &V) const
    {
        return CIwSVec2(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y))
        );
    }







    CIwVec2 RotateVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y),
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y)
        );
    }







    CIwVec2 TransformVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }
# 368 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVec(CIwSVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }
# 384 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVecShift(CIwSVec2 const &V, int32 shift) const
    {
        int32 lDotShift = 12 - shift;
        return CIwVec2(
        IW_MUL_2_SHIFT(m[0][0] >> shift, m[1][0] >> shift, V.x, V.y, lDotShift) + t.x,
        IW_MUL_2_SHIFT(m[0][1] >> shift, m[1][1] >> shift, V.x, V.y, lDotShift) + t.y
        );
    }
# 401 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransformVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }






    CIwVec2 TransformVecSafe(CIwSVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[1][0], V.x, V.y) + t.x,
        IW_FIXED_MUL2_SAFE(m[0][1], m[1][1], V.x, V.y) + t.y
        );
    }







    CIwVec2 TransposeRotateVec(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2(m[0][0], m[0][1], V.x, V.y),
        IW_FIXED_MUL2(m[1][0], m[1][1], V.x, V.y)
        );
    }







    CIwSVec2 TransposeRotateVec(CIwSVec2 const &V) const
    {
        return CIwSVec2(
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[0][0], m[0][1], V.x, V.y)),
        IW_SFIXED_FROM_FIXED(IW_FIXED_MUL2(m[1][0], m[1][1], V.x, V.y))
        );
    }







    CIwVec2 TransposeRotateVecSafe(CIwVec2 const &V) const
    {
        return CIwVec2(
        IW_FIXED_MUL2_SAFE(m[0][0], m[0][1], V.x, V.y),
        IW_FIXED_MUL2_SAFE(m[1][0], m[1][1], V.x, V.y)
        );
    }
# 471 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    CIwVec2 TransposeTransformVec(CIwVec2 const &V) const
    {
        return CIwVec2(
            IW_FIXED_MUL2(m[0][0], m[0][1], V.x-t.x, V.y-t.y),
            IW_FIXED_MUL2(m[1][0], m[1][1], V.x-t.x, V.y-t.y)
            );
    }
# 487 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    iwfixed TransformVecX(CIwVec2 const &V) const { return ((IW_FIXED_MUL2(m[0][0],m[1][0],V.x,V.y)) + (t.x)); }
    iwfixed TransformVecY(CIwVec2 const &V) const { return ((IW_FIXED_MUL2(m[0][1],m[1][1],V.x,V.y)) + (t.y)); }
    iwfixed TransformVecX(iwsfixed x, iwsfixed y) const { return ((IW_FIXED_MUL2(m[0][0],m[1][0],x,y)) + (t.x)); }
    iwfixed TransformVecY(iwsfixed x, iwsfixed y) const { return ((IW_FIXED_MUL2(m[0][1],m[1][1],x,y)) + (t.y)); }
    iwfixed TransformVecX(iwfixed x, iwfixed y) const { return ((IW_FIXED_MUL2(m[0][0],m[1][0],x,y)) + (t.x)); }
    iwfixed TransformVecY(iwfixed x, iwfixed y) const { return ((IW_FIXED_MUL2(m[0][1],m[1][1],x,y)) + (t.y)); }







    inline iwfixed RotateVecX(const CIwVec2& V)
    {
            return IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y);
    }





    inline iwfixed RotateVecY(const CIwVec2& V)
    {
            return IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y);
    }






    inline iwsfixed RotateVecX(const CIwSVec2& V)
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][0], V.x) + IW_FIXED_MUL(m[1][0], V.y));
    }





    inline iwsfixed RotateVecY(const CIwSVec2& V)
    {
            return IW_SFIXED_FROM_FIXED(IW_FIXED_MUL(m[0][1], V.x) + IW_FIXED_MUL(m[1][1], V.y));
    }





    CIwMat2D GetTranspose() const
    {
        CIwMat2D N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];


        N.t = CIwVec2(0, 0);
        return N;
    }







    inline void SetRot(iwangle r = 0, bool resetTrans = true)
    {
        if (resetTrans) t.x = t.y = 0;
        m[0][0] = m[1][1] = IwGeomCos(-r);
        m[0][1] = -(m[1][0] = IwGeomSin(-r));
    }






    inline void SetRot(iwangle r, const CIwVec2& centre)
    {
        m[0][0] = m[1][1] = IwGeomCos(-r);
        m[0][1] = -(m[1][0] = IwGeomSin(-r));
        t = centre - RotateVec(centre);
    }


    inline void PreRotate(iwangle r)
    {
        CIwMat2D rz;
        rz.SetRot(r, true);
        PreRotate(rz);
    }
    inline void PostRotate(iwangle r)
    {
        CIwMat2D rz;
        rz.SetRot(r, true);
        PostRotate(rz);
    }







    CIwMat2D operator * (CIwMat2D const & M) const
    {
        CIwMat2D N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwMat2D & PreMult(CIwMat2D const & M)
    {
        return (*this = M * (*this));
    }




    CIwMat2D & PreMultiply(CIwMat2D const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwMat2D & PostMult(CIwMat2D const & M)
    {
        return (*this = (*this) * M);
    }




    CIwMat2D & PostMultiply(CIwMat2D const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwMat2D& operator *= (CIwMat2D const & M)
    {
        return PostMult(M);
    }







    CIwMat2D& PostRotate(CIwMat2D const& M)
    {
        CIwMat2D N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        CopyRot(N);

        return *this;
    }






    CIwMat2D PreRotate(CIwMat2D const& M)
    {
        CIwMat2D t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwMat2D& ScaleRot(iwfixed v)
    {
        for (int i=0; i<2; i++)
            for (int j=0; j<2; j++)
                m[i][j] = IW_FIXED_MUL(m[i][j],v);
        return *this;
    }






    CIwMat2D& ScaleTrans(iwfixed v)
    {
        t *= v;
        return *this;
    }





    CIwMat2D& Scale(iwfixed v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwMat2D& operator *= (const iwfixed v)
    {
        Scale(v);
        return *this;
    }
# 753 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    void InterpRot(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction);


    void InterpolateRot(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 772 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
    void InterpTrans(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction);


    void InterpolatePos(CIwMat2D const & m0, CIwMat2D const & m1, iwfixed fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwMat2D& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
    }





    void CopyTrans(const CIwMat2D& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwMat2D const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1];
    }






    bool IsTransSame(CIwMat2D const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwMat2D const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwMat2D const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity()
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity()
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity()
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero()
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0;
    }


    bool IsTransZero()
    {
        return t.x == 0 &&
        t.y == 0;
    }


    bool IsZero()
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }

    iwfixed GetDeterminant() const
    {
        return IW_FIXED_MUL(m[0][0], m[1][1]) - IW_FIXED_MUL(m[0][1], m[1][0]);
    }




    CIwMat2D GetInverse() const;
# 930 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
private:


    static inline iwfixed FindComponentFromBA(const CIwMat2D& A, const CIwMat2D& B, const int i, const int j)
    {
# 947 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
        return (B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j]) >> 12;
    }



};
# 961 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h"
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h" 1
       
# 35 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
class CIwMat2D;
# 63 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
class CIwFMat2D
{
public:



    float m[2][2];



    CIwFVec2 t;




    static CIwFMat2D g_Identity;




    CIwFMat2D() {};





    explicit CIwFMat2D(float f)
    {
        m[0][0] = m[1][1] = f;
        m[0][1] = m[1][0] = 0;
        t.x = t.y = 0;
    }






    explicit CIwFMat2D(const CIwMat2D & M);





    inline CIwMat2D ConvertToCIwMat2D();
# 116 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFMat2D(CIwFMat2D const & R, CIwFVec2 const & T)
    {
        m[0][0] = R.m[0][0];
        m[1][0] = R.m[1][0];
        m[0][1] = R.m[0][1];
        m[1][1] = R.m[1][1];
        t = T;
    }







    void Serialise();





    void Normalise()
    {
        CIwFVec2* pVecX = (CIwFVec2*)&m[0][0];
        CIwFVec2* pVecY = (CIwFVec2*)&m[1][0];

        pVecX->Normalise();

        *pVecY = CIwFVec2(-pVecX->y, pVecX->x);
    }




    void Transpose();





    CIwFVec2 const & GetTrans() const
    {
        return t;
    }






    CIwFMat2D & SetTrans(CIwFVec2 const & v)
    {
        t = v;
        return *this;
    }







    CIwFMat2D & operator += (CIwFVec2 const & V)
    {
        t += V;
        return *this;
    }







    CIwFMat2D operator + (CIwFVec2 const & V) const
    {
        return CIwFMat2D(*this, t+V);
    }
# 203 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 ColumnX() const
    {
        return CIwFVec2(m[0][0], m[1][0]);
    }




    CIwFVec2 ColumnY() const
    {
        return CIwFVec2(m[0][1], m[1][1]);
    }







    CIwFVec2 RowX() const
    {
        return CIwFVec2(m[0][0], m[0][1]);
    }







    CIwFVec2 RowY() const
    {
        return CIwFVec2(m[1][0], m[1][1]);
    }






    CIwFVec2 RotateVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[1][0] * V.y)),
        ((m[0][1] * V.x) + (m[1][1] * V.y))
        );
    }
# 258 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransformVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[1][0] * V.y)) + t.x,
        ((m[0][1] * V.x) + (m[1][1] * V.y)) + t.y
        );
    }
# 273 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransposeRotateVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
        ((m[0][0] * V.x) + (m[0][1] * V.y)),
        ((m[1][0] * V.x) + (m[1][1] * V.y))
        );
    }
# 289 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
    CIwFVec2 TransposeTransformVec(CIwFVec2 const &V) const
    {
        return CIwFVec2(
            ((m[0][0] * (V.x-t.x)) + (m[0][1] * (V.y-t.y))),
            ((m[1][0] * (V.x-t.x)) + (m[1][1] * (V.y-t.y)))
            );
    }


    float TransformVecX(CIwFVec2 const &V) const { return (((m[0][0] * V.x) + (m[1][0] * V.y))) + t.x; }
    float TransformVecY(CIwFVec2 const &V) const { return (((m[0][1] * V.x) + (m[1][1] * V.y))) + t.y; }
    float TransformVecX(float x, float y) const { return (((m[0][0] * x) + (m[1][0] * y))) + t.x; }
    float TransformVecY(float x, float y) const { return (((m[0][1] * x) + (m[1][1] * y))) + t.y; }







    inline float RotateVecX(const CIwFVec2& V)
    {
            return m[0][0] * V.x + m[1][0] * V.y;
    }





    inline float RotateVecY(const CIwFVec2& V)
    {
            return m[0][1] * V.x + m[1][1] * V.y;
    }






    CIwFMat2D GetTranspose() const
    {
        CIwFMat2D N;
        N.m[0][0] = m[0][0];
        N.m[1][0] = m[0][1];
        N.m[0][1] = m[1][0];
        N.m[1][1] = m[1][1];


        N.t = CIwFVec2(0, 0);
        return N;
    }







    inline void SetRot(float r = 0, bool resetTrans = true)
    {
        if (resetTrans) t.x = t.y = 0;
        m[0][0] = m[1][1] = (float)cos(-r);
        m[0][1] = -(m[1][0] = (float)sin(-r));
    }






    inline void SetRot(float r, const CIwFVec2& centre)
    {
        m[0][0] = m[1][1] = (float)cos(-r);
        m[0][1] = -(m[1][0] = (float)sin(-r));
        t = centre - RotateVec(centre);
    }


    inline void PreRotate(float r)
    {
        CIwFMat2D rz;
        rz.SetRot(r, true);
        PreRotate(rz);
    }
    inline void PostRotate(float r)
    {
        CIwFMat2D rz;
        rz.SetRot(r, true);
        PostRotate(rz);
    }







    CIwFMat2D operator * (CIwFMat2D const & M) const
    {
        CIwFMat2D N;
        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        N.t = M.TransformVec(t);

        ((void)0);


        return N;
    }







    CIwFMat2D & PreMult(CIwFMat2D const & M)
    {
        return (*this = M * (*this));
    }




    CIwFMat2D & PreMultiply(CIwFMat2D const & M)
    {
        ((void)0);
        return PreMult(M);
    }







    CIwFMat2D & PostMult(CIwFMat2D const & M)
    {
        return (*this = (*this) * M);
    }




    CIwFMat2D & PostMultiply(CIwFMat2D const & M)
    {
        ((void)0);
        return PostMult(M);
    }







    CIwFMat2D& operator *= (CIwFMat2D const & M)
    {
        return PostMult(M);
    }







    CIwFMat2D& PostRotate(CIwFMat2D const& M)
    {
        CIwFMat2D N;

        N.m[0][0] = FindComponentFromBA(M,*this,0,0);
        N.m[0][1] = FindComponentFromBA(M,*this,0,1);

        N.m[1][0] = FindComponentFromBA(M,*this,1,0);
        N.m[1][1] = FindComponentFromBA(M,*this,1,1);

        CopyRot(N);

        return *this;
    }






    CIwFMat2D PreRotate(CIwFMat2D const& M)
    {
        CIwFMat2D t = M;
        t.t = this->t;
        return (*this = t.PostRotate(*this));
    }







    CIwFMat2D& ScaleRot(float v)
    {
        for (int i=0; i<2; i++)
            for (int j=0; j<2; j++)
                m[i][j] = (m[i][j]*v);
        return *this;
    }






    CIwFMat2D& ScaleTrans(float v)
    {
        t *= v;
        return *this;
    }





    CIwFMat2D& Scale(float v)
    {
        ScaleRot(v);
        ScaleTrans(v);
        return *this;
    }






    CIwFMat2D& operator *= (const float v)
    {
        Scale(v);
        return *this;
    }
# 544 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
    void InterpRot(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction);


    void InterpolateRot(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction)
    {
        ((void)0);
        InterpRot(m0, m1, fraction);
    }
# 563 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
    void InterpTrans(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction);


    void InterpolatePos(CIwFMat2D const & m0, CIwFMat2D const & m1, float fraction)
    {

        ((void)0);
        InterpTrans(m0, m1, fraction);
    }






    void CopyRot(const CIwFMat2D& m0)
    {
        m[0][0] = m0.m[0][0];
        m[0][1] = m0.m[0][1];
        m[1][0] = m0.m[1][0];
        m[1][1] = m0.m[1][1];
    }





    void CopyTrans(const CIwFMat2D& m0)
    {
        t = m0.t;
    }







    bool IsRotSame(CIwFMat2D const& m0) const
    {
        return m[0][0] == m0.m[0][0] &&
        m[0][1] == m0.m[0][1] &&
        m[1][0] == m0.m[1][0] &&
        m[1][1] == m0.m[1][1];
    }






    bool IsTransSame(CIwFMat2D const& m0) const
    {
        return (t == m0.t);
    }






    bool operator == (CIwFMat2D const & m0) const
    {
        return IsRotSame(m0) && IsTransSame(m0);
    }







    bool operator != (CIwFMat2D const & m0) const
    {
        return !IsRotSame(m0) || !IsTransSame(m0);
    }



    bool IsRotIdentity()
    {
        return IsRotSame(g_Identity);
    }


    bool IsTransIdentity()
    {
        return IsTransSame(g_Identity);
    }


    bool IsIdentity()
    {
        return (*this)==g_Identity;
    }


    void SetIdentity()
    {
        *this = g_Identity;
    }


    bool IsRotZero()
    {
        return m[0][0] == 0 &&
        m[0][1] == 0 &&
        m[1][0] == 0 &&
        m[1][1] == 0;
    }


    bool IsTransZero()
    {
        return t.x == 0 &&
        t.y == 0;
    }


    bool IsZero()
    {
        return IsRotZero() && IsTransZero();
    }


    void SetZero();


    void Zero()
    {
        ((void)0);
        SetZero();
    }

    float GetDeterminant() const
    {
        return m[0][0] * m[1][1] - m[0][1] * m[1][0];
    }




    CIwFMat2D GetInverse() const;
# 779 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
private:


    static inline float FindComponentFromBA(const CIwFMat2D& A, const CIwFMat2D& B, const int i, const int j)
    {
        return B.m[i][0]*A.m[0][j] + B.m[i][1]*A.m[1][j];

    }



};
# 802 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFMat2D.h"
inline CIwMat2D CIwFMat2D::ConvertToCIwMat2D()
    {
        return CIwMat2D(*this);
    }
# 962 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomMat2D.h" 2


inline CIwFMat2D CIwMat2D::ConvertToCIwFMat2D()
    {
        return CIwFMat2D(*this);
    }
# 25 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomPlane.h" 1
       
# 51 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomPlane.h"
class CIwPlane
{
public:




    CIwSVec3 v;
    int16 padding;





    int32 k;





    static CIwPlane g_YZ;



    static CIwPlane g_XZ;



    static CIwPlane g_XY;




    CIwPlane() {};





    CIwPlane(CIwSVec3 const & _v, int32 vk) : v(_v), k(vk) {};





    CIwPlane(CIwSVec3 const & _v, CIwVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.NormaliseSafe();
        k = v * vk;
    }





    CIwPlane(CIwSVec3 const & _v, CIwSVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.NormaliseSafe();
        k = v * vk;
    }






    CIwPlane(CIwVec3 const & _a, CIwVec3 const & _b, CIwVec3 const & _c)
    {
        v = ( (_a-_b)^(_c-_a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }






    CIwPlane(CIwSVec3 const & _a, CIwSVec3 const & _b, CIwSVec3 const & _c)
    {
        v = ( (_a-_b)^(_c-_a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }
# 150 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomPlane.h"
    int32 GetPerpDist(CIwVec3 const & a) const
    {
        return v * a - k;
    }





    CIwPlane operator - () const
    {
        return CIwPlane(-v,-k);
    }





    bool operator == (CIwPlane const & p) const
    {
        return k==p.k && v==p.v;
    }
};
# 26 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomQuat.h" 1
       
# 29 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomQuat.h"
static inline iwqfixed iwqfixed_mul30to13(iwqfixed a, iwqfixed b) {






    return (((a>>16)*(b>>16))>>15);
}
# 56 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomQuat.h"
class CIwQuat
{
public:



    iwqfixed s,
                x, y, z;




    static CIwQuat g_Identity;




    CIwQuat():x(0),y(0),z(0),s((1 << 30)) {}





    CIwQuat(iwqfixed s,iwqfixed x,iwqfixed y,iwqfixed z):x(x),y(y),z(z),s(s) {}







    CIwQuat(CIwMat const &mat);






    CIwQuat(iwqfixed s):x(0),y(0),z(0),s(s) {}






    CIwQuat(CIwVec3 const& v, iwqangle theta){
        CIwVec3 vn = v.GetNormalised();
        SetAxisAngle(vn.x<<(30 - 12), vn.y<<(30 - 12), vn.z<<(30 - 12), theta);
    }





    void Serialise()
    {
        IwSerialiseInt32(s, 4);
    }






    bool operator == (CIwQuat const &q) const {
        return (x == q.x && y == q.y && z == q.z && s == q.s);
    }






    bool operator != (CIwQuat const &q) const {
        return !(*this == q);
    }
# 140 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomQuat.h"
    void SetAxisAngle(iwqfixed x, iwqfixed y, iwqfixed z, iwqangle theta);





    iwqfixed GetLengthSquared() const;





    iwqfixed GetLength() const;







    CIwQuat operator * (CIwQuat const & q) const {
        return CIwQuat (IW_QFIXED_MUL_SAFE(s, q.s) - (IW_QFIXED_MUL_SAFE(q.x, x) + IW_QFIXED_MUL_SAFE(q.y, y) + IW_QFIXED_MUL_SAFE(q.z, z)),
            IW_QFIXED_MUL_SAFE(s, q.x) + IW_QFIXED_MUL_SAFE(q.s, x) + IW_QFIXED_MUL_SAFE(y, q.z) - IW_QFIXED_MUL_SAFE(z, q.y),
            IW_QFIXED_MUL_SAFE(s, q.y) + IW_QFIXED_MUL_SAFE(q.s, y) + IW_QFIXED_MUL_SAFE(z, q.x) - IW_QFIXED_MUL_SAFE(x, q.z),
            IW_QFIXED_MUL_SAFE(s, q.z) + IW_QFIXED_MUL_SAFE(q.s, z) + IW_QFIXED_MUL_SAFE(x, q.y) - IW_QFIXED_MUL_SAFE(y, q.x)
            );
    }






    CIwQuat operator << (const int c) const {
        return CIwQuat(s<<c, x<<c, y<<c, z<<c);
    }






    CIwQuat operator >> (const int c) const {
        return CIwQuat(s>>c, x>>c, y>>c, z>>c);
    }
# 193 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomQuat.h"
    CIwVec3 RotateVector (CIwVec3 const &v) const {


        int64 qxvx = (((int64)v.y * z) - ((int64)v.z * y)) >> (12 -1),
                    qxvy = (((int64)v.z * x) - ((int64)v.x * z)) >> (12 -1),
                    qxvz = (((int64)v.x * y) - ((int64)v.y * x)) >> (12 -1);

        int64 qxqxvx = (((int64)qxvy * z) - ((int64)qxvz * y)) >> (30 + (30 - 12)),
                  qxqxvy = (((int64)qxvz * x) - ((int64)qxvx * z)) >> (30 + (30 - 12)),
                  qxqxvz = (((int64)qxvx * y) - ((int64)qxvy * x)) >> (30 + (30 - 12));

        return CIwVec3(
            (int32)(v.x + ((s*qxvx) >> ((30 - 12) + 30)) + qxqxvx),
            (int32)(v.y + ((s*qxvy) >> ((30 - 12) + 30)) + qxqxvy),
            (int32)(v.z + ((s*qxvz) >> ((30 - 12) + 30)) + qxqxvz));

      }





    CIwQuat operator - () const {
        return CIwQuat(s, -x, -y, -z);
    }





    CIwQuat &NormaliseInPlace() {
        iwqfixed l = GetLengthSquared();

        ((void)0);
        if (l == 0) return *this;





        if (l < 0x3FE00000 || l > 0x40200000) {
            int64 recip = (((int64)1 << (30 << 1)) >> 2) / IW_GEOM_QSQRT(l);
            ((void)0);
            ((void)0);

            s = IW_QFIXED_MUL_SAFE(s, (iwqfixed)recip)<<2;
            x = IW_QFIXED_MUL_SAFE(x, (iwqfixed)recip)<<2;
            y = IW_QFIXED_MUL_SAFE(y, (iwqfixed)recip)<<2;
            z = IW_QFIXED_MUL_SAFE(z, (iwqfixed)recip)<<2;

        }

        return *this;
    }





    CIwVec3 GetRotationAxis(){
        CIwVec3 v(x>>(30 - 12),y>>(30 - 12),z>>(30 - 12));
        v.Normalise();
        return v;
    }





    iwqangle GetRotationAngle(){
        return IwGeomQACos (s) * 2;
    }




    CIwQuat operator * (iwqfixed const l) const {
        return CIwQuat (
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), s),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), x),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), y),
            IW_QFIXED_MUL_SAFE((l<<(30 - 12)), z));
    }






    CIwQuat operator + (CIwQuat const & q) const {






        return CIwQuat(s + q.s, x + q.x, y + q.y, z + q.z);
    }






    CIwQuat operator - (CIwQuat const & q) const {






        return CIwQuat(s - q.s, x - q.x, y - q.y, z - q.z);
    }






    CIwQuat &operator = (CIwQuat const &q) {
        s = q.s;
        x = q.x;
        y = q.y;
        z = q.z;
        return *this;
    }





    operator CIwMat() const {
        CIwMat m;

        iwqfixed x2 = iwqfixed_mul30to13(x,x),
                    y2 = iwqfixed_mul30to13(y,y),
                    z2 = iwqfixed_mul30to13(z,z),
                    xy = iwqfixed_mul30to13(x,y),
                    yz = iwqfixed_mul30to13(y,z),
                    xz = iwqfixed_mul30to13(x,z),
                    wx = iwqfixed_mul30to13(s,x),
                    wy = iwqfixed_mul30to13(s,y),
                    wz = iwqfixed_mul30to13(s,z);



        m.m[0][0] = (1 << 12) - y2 - z2;
        m.m[1][1] = (1 << 12) - x2 - z2;
        m.m[2][2] = (1 << 12) - x2 - y2;
        m.m[1][0] = xy - wz;
        m.m[2][0] = xz + wy;
        m.m[0][1] = xy + wz;
        m.m[2][1] = yz - wx;
        m.m[0][2] = xz - wy;
        m.m[1][2] = yz + wx;

        m.t.x = m.t.y = m.t.z = 0;
        return m;
    }
# 361 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomQuat.h"
    void Lerp(const CIwQuat &startQ, const CIwQuat &endQ, iwfixed const t);
# 371 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomQuat.h"
    void Slerp(const CIwQuat &startQ, const CIwQuat &endQ, iwfixed const t);
};
# 27 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSphere.h" 1
       
# 53 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSphere.h"
template <class V, class R>
class CIwSphereT
{
public:




    V t;




    R r;

    uint32 r2;




    CIwSphereT() {};





    CIwSphereT(V const & _t, R _r) : t(_t)
    {
        SetRadius(_r);
    };





    void Serialise();
# 97 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSphere.h"
    inline void SetRadius(R _r)
    {
        r = _r;
        r2 = ((r) * (r));
    };






    inline uint32 GetRadius() const
    {
        return r;
    };




    inline V const & GetTrans() const
    {
        return t;
    };
# 128 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSphere.h"
    template <class V2>
    void BoundVecs(V2* pVec, uint32 v)
    {
        ((void)0);


        t.x = t.y = t.z = 0;
        uint32 v2 = v;
        V2* pVec2 = pVec;
        while(v2--)
            t += *pVec2++;


        t = t / ((iwfixed)((v) * (1 << 12)));
        r = 0;
        while(v--)
        {


            CIwVec3 dv(*pVec);
            dv -= t;
            r = (((r) > ((int32)dv.GetLengthSafe())) ? (r) : ((int32)dv.GetLengthSafe()));
            pVec++;
        }


        r2 = ((r) * (r));
    }







    inline bool ClipToPlane(const CIwPlane& plane)
    {
        int32 dot = t * plane.v;
        int32 dotk = dot - plane.k;
        return dotk >= (int32)r;
    }
# 180 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSphere.h"
    bool ClipToFrustrum(CIwPlane* pPlanes, uint32 clipFlags)
    {
        ((void)0);
        while(clipFlags != 0)
        {
            if (
                (clipFlags & 0x1) &&
                (ClipToPlane(*pPlanes) == true)
                )

                return true;

            pPlanes++;
            clipFlags >>= 1;
        }

        return false;
    }
# 208 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSphere.h"
    iwufixed GetDistSqFromLine(const CIwVec3& point, const CIwVec3& dir) const
    {
        CIwVec3 delta = t-point;
        uint32 hyp2 = delta.GetLengthSquaredSafe();
        iwfixed adj = dir*(delta);
        iwufixed adj2 = IW_FIXED_MUL_SAFE(adj,adj);
        iwufixed perpdist2 = hyp2-adj2;
        return perpdist2;
    }
# 226 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomSphere.h"
    bool IntersectsLine(CIwVec3& point, CIwVec3& dir)
    {
        iwufixed r2_proper = IW_FIXED_MUL_SAFE(r,r);
        return GetDistSqFromLine(point,dir) <= r2_proper;
    }







    template <class V2>
    bool ContainsVec(const V2& v) const
    {
        return (v - t).GetLengthSafe() < r;
    }
};





typedef CIwSphereT<CIwVec3, iwfixed> CIwSphere;





typedef CIwSphereT<CIwSVec3, iwsfixed> CIwSSphere;
# 28 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomBBox.h" 1
       
# 26 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomBBox.h"
class CIwMat;
# 54 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomBBox.h"
template <class V>
class CIwBBoxT
{
public:




    V m_Min;





    V m_Max;




    CIwBBoxT() {};
# 82 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomBBox.h"
    CIwBBoxT(const V& _min, const V& _max) : m_Min(_min), m_Max(_max) {};





    void Serialise();





    V GetCentre() { return m_Min + (m_Max - m_Min) / ((iwfixed)((2) * (1 << 12))); }





    template <class V2>
    void BoundVec(V2* pVec)
    {
        m_Min.x = (((m_Min.x) < (pVec->x)) ? (m_Min.x) : (pVec->x));
        m_Min.y = (((m_Min.y) < (pVec->y)) ? (m_Min.y) : (pVec->y));
        m_Min.z = (((m_Min.z) < (pVec->z)) ? (m_Min.z) : (pVec->z));
        m_Max.x = (((m_Max.x) > (pVec->x)) ? (m_Max.x) : (pVec->x));
        m_Max.y = (((m_Max.y) > (pVec->y)) ? (m_Max.y) : (pVec->y));
        m_Max.z = (((m_Max.z) > (pVec->z)) ? (m_Max.z) : (pVec->z));
    }
# 119 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomBBox.h"
    template <class V2>
    void BoundVecs(V2* pVec, uint32 v)
    {
        ((void)0);

        m_Min = V(0x7fff, 0x7fff, 0x7fff);
        m_Max = V((-0x7fff - 1), (-0x7fff - 1), (-0x7fff - 1));
        while(v--)
        {
            BoundVec(pVec);
            pVec++;
        }
    }
# 141 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomBBox.h"
    template <class V2>
    bool ContainsVec(const V2& v, CIwMat* pMat = __null) const
    {
        if (pMat)
        {
            CIwVec3 dv = v - pMat->t;
            int32 lx, ly, lz;
            lx = pMat->RotateVecX(dv);
            if ((lx >= m_Min.x) && (lx <= m_Max.x))
            {
                ly = pMat->RotateVecY(dv);
                if ((ly >= m_Min.y) && (ly <= m_Max.y))
                {
                    lz = pMat->RotateVecZ(dv);
                    if ((lz >= m_Min.z) && (lz <= m_Max.z))
                        return true;
                }
            }
        }
        else
        {
            if (
                (v.x >= m_Min.x) && (v.x <= m_Max.x) &&
                (v.y >= m_Min.y) && (v.y <= m_Max.y) &&
                (v.z >= m_Min.z) && (v.z <= m_Max.z)
                )
                return true;
        }
        return false;
    }
};





typedef CIwBBoxT<CIwSVec3> CIwSBBox;





typedef CIwBBoxT<CIwVec3> CIwBBox;
# 29 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h" 1
       
# 40 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h"
extern int32 IW_GEOM_INTERSECT_EPSILON;
# 56 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLinePlane( const CIwVec3& vFrom,
                                const CIwVec3& vFromTo,
                                const CIwPlane& plane,
                                int32& f,
                                bool finite = true);
# 76 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineSegPlaneOneSided(const CIwVec3& vOrg,
                                        const CIwVec3& vDirn,
                                        const CIwPlane& plane,
                                        int32& f,
                                        bool finite = true);
# 91 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineSphere( const CIwVec3& vOrg,
                                const CIwVec3& vDirn,
                                const CIwSphere& sphere);
# 111 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineTriNorm( const CIwVec3& vOrg,
                                const CIwVec3& vDirn,
                                const CIwVec3& v0,
                                const CIwVec3& v1,
                                const CIwVec3& v2,
                                const CIwSVec3& norm,
                                int32& f,
                                bool finite = true);
# 136 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectLineLine2D( const CIwVec2& p1, const CIwVec2& dir1,
                                const CIwVec2& p2, const CIwVec2& dir2,
                                CIwVec2& collpt,
                                iwfixed& t1,
                                iwfixed& t2,
                                bool finite = true);
# 151 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomIntersect.h"
bool IwIntersectSphereSphere(const CIwSphere& s0, const CIwSphere& s1);
# 30 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2


# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h"
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFPlane.h" 1
       
# 45 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFPlane.h"
class CIwFPlane
{
public:




    CIwFVec3 v;
    int16 padding;





    float k;





    static CIwFPlane g_YZ;



    static CIwFPlane g_XZ;



    static CIwFPlane g_XY;




    CIwFPlane() {};





    CIwFPlane(CIwFVec3 const & _v, float vk) : v(_v), k(vk) {};





    CIwFPlane(CIwFVec3 const & _v, CIwFVec3 const & vk)
    {
        v = _v;
        if (!v.IsZero())
            v.Normalise();
        k = v * vk;
    }






    CIwFPlane(CIwFVec3 const & _a, CIwFVec3 const & _b, CIwFVec3 const & _c)
    {
        v = ( (_a - _b) ^ (_c - _a) );
        if (!v.IsZero())
            v.Normalise();
        k = v * _a;
    }
# 120 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFPlane.h"
    float GetPerpDist(CIwFVec3 const & a) const
    {
        return v * a - k;
    }





    CIwFPlane operator - () const
    {
        return CIwFPlane(-v, -k);
    }





    bool operator == (CIwFPlane const & p) const
    {
        return k == p.k && v == p.v;
    }
};
# 34 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h" 2
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFSphere.h" 1
# 21 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFSphere.h"
# 1 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFBBox.h" 1
       
# 22 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFBBox.h"
class CIwFMat;





class CIwFBBox
{
public:

    CIwFVec3 minV;
    CIwFVec3 maxV;


    CIwFBBox() {};
    CIwFBBox(const CIwFVec3& _min, const CIwFVec3& _max) : minV(_min), maxV(_max) {};


    CIwFVec3 GetCentre() { return minV + (maxV - minV) / 2; }


    inline void BoundVec(CIwFVec3* pVec)
    {
        minV.x = (((minV.x) < (pVec->x)) ? (minV.x) : (pVec->x));
        minV.y = (((minV.y) < (pVec->y)) ? (minV.y) : (pVec->y));
        minV.z = (((minV.z) < (pVec->z)) ? (minV.z) : (pVec->z));
        maxV.x = (((maxV.x) > (pVec->x)) ? (maxV.x) : (pVec->x));
        maxV.y = (((maxV.y) > (pVec->y)) ? (maxV.y) : (pVec->y));
        maxV.z = (((maxV.z) > (pVec->z)) ? (maxV.z) : (pVec->z));
    }


    void BoundVecs(CIwFVec3* pVec, uint32 v)
    {
        ((void)0);

        minV = CIwFVec3(3.402823466e+38F, 3.402823466e+38F, 3.402823466e+38F);
        maxV = CIwFVec3(-3.402823466e+38F, -3.402823466e+38F, -3.402823466e+38F);
        while(v--)
        {

            minV.x = (((minV.x) < (pVec->x)) ? (minV.x) : (pVec->x));
            minV.y = (((minV.y) < (pVec->y)) ? (minV.y) : (pVec->y));
            minV.z = (((minV.z) < (pVec->z)) ? (minV.z) : (pVec->z));
            maxV.x = (((maxV.x) > (pVec->x)) ? (maxV.x) : (pVec->x));
            maxV.y = (((maxV.y) > (pVec->y)) ? (maxV.y) : (pVec->y));
            maxV.z = (((maxV.z) > (pVec->z)) ? (maxV.z) : (pVec->z));
            pVec++;
        }
    }


    bool ContainsVec(CIwFVec3& v, CIwFMat* pMat = __null)
    {
        if (pMat)
        {
            CIwFVec3 dv = v - pMat->t;
            float lx, ly, lz;
            lx = pMat->m[0][0]*dv.x + pMat->m[1][0]*dv.y + pMat->m[2][0]*dv.z;
            if ((lx >= minV.x) && (lx <= maxV.x))
            {
                ly = pMat->m[0][1]*dv.x + pMat->m[1][1]*dv.y + pMat->m[2][1]*dv.z;
                if ((ly >= minV.y) && (ly <= maxV.y))
                {
                    lz = pMat->m[0][2]*dv.x + pMat->m[1][2]*dv.y + pMat->m[2][2]*dv.z;
                    if ((lz >= minV.z) && (lz <= maxV.z))
                        return true;
                }
            }
        }
        else
        {
            if (
                (v.x >= minV.x) && (v.x <= maxV.x) &&
                (v.y >= minV.y) && (v.y <= maxV.y) &&
                (v.z >= minV.z) && (v.z <= maxV.z)
                )
                return true;
        }
        return false;
    }
};
# 22 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFSphere.h" 2







class CIwFSphere
{
public:

    CIwFVec3 t;
    float r;
    float r2;


    CIwFSphere() {};
    CIwFSphere(const CIwFVec3& _t, float _r) : t(_t)
    {
        SetRadius(_r);
    };

    inline void SetRadius(float _r)
    {
        r = _r;
        r2 = r*r;
    };

    inline float GetRadius()
    {
        return r;
    };

    inline CIwFVec3 const & GetTrans() const
    {
        return t;
    };


    void BoundVecs(CIwFVec3* pVec, uint32 v)
    {
        ((void)0);

        CIwFBBox bbox;
        bbox.BoundVecs(pVec, v);

        t = bbox.GetCentre();
        r = 0;
        while(v--)
        {
            CIwFVec3 dv = *pVec;
            dv -= t;
            r = (((r) > (dv.GetLengthSquared())) ? (r) : (dv.GetLengthSquared()));
            pVec++;
        }


        r2 = r;

        r = (float)sqrt(r);
    }


    void Combine(CIwFSphere& rhs)
    {

        CIwFVec3 centre = rhs.t - t;
        float dist = centre.GetLength();

        if( dist + rhs.r <= r )
            return;

        if( dist + r <= rhs.r )
        {
            *this = rhs;
            return;
        }

        centre = centre / dist;

        t -= centre * r;

        t += rhs.t + centre * rhs.r;
        t = t / 2.0f;

        r = (dist + r + rhs.r) / 2.0f;
        r2 = r * r;

        ((void)0);
    }
# 146 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFSphere.h"
};




inline void IwSerialiseSphere(CIwFSphere& Sphere)
{
    Sphere.t.Serialise ();
    IwSerialiseFloat(Sphere.r);
    IwSerialiseFloat(Sphere.r2);
}
# 35 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h" 2
# 54 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLinePlane(const CIwFVec3& vFrom,
                          const CIwFVec3& vFromTo,
                          const CIwFPlane& plane,
                          float& f,
                          bool finite = true);
# 74 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineSegPlaneOneSided(const CIwFVec3& vOrg,
                                     const CIwFVec3& vDirn,
                                     const CIwFPlane& plane,
                                     float& f,
                                     bool finite = true);
# 89 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineSphere(const CIwFVec3& vOrg,
                           const CIwFVec3& vDirn,
                           const CIwFSphere& sphere);
# 109 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineTriNorm(const CIwFVec3& vOrg,
                            const CIwFVec3& vDirn,
                            const CIwFVec3& v0,
                            const CIwFVec3& v1,
                            const CIwFVec3& v2,
                            const CIwFVec3& norm,
                            float& f,
                            bool finite = true);
# 134 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectLineLine2D(const CIwFVec2& p1,
                           const CIwFVec2& dir1,
                           const CIwFVec2& p2,
                           const CIwFVec2& dir2,
                           CIwFVec2& collpt,
                           float& t1,
                           float& t2,
                           bool finite = true);
# 151 "d:/marmalade/6.1/modules/iwgeom/h/IwGeomFIntersect.h"
bool IwIntersectSphereSphere(const CIwFSphere& s0, const CIwFSphere& s1);
# 33 "d:/marmalade/6.1/modules/iwgeom/h/IwGeom.h" 2
# 23 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 1
       
# 16 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h" 1
       
# 42 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
typedef void*(*IwClassFactoryFn)();
typedef void*(*IwClassSizeFactoryFn)();
# 146 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryReserve(int number);
# 156 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
void* IwClassFactoryCreate(uint32 hash);
# 165 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
bool IwClassFactoryExists(uint32 hash);
# 174 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
void* IwClassFactoryCreate(const char* name);
# 184 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryAdd(uint32 hash, IwClassFactoryFn fn, uint32 size = 0);
# 193 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryAdd(const char* name, IwClassFactoryFn fn, uint32 size = 0);
# 202 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryRemove(uint32 hash);
# 211 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
IwClassFactoryFn IwClassFactoryGet(uint32 hash);

uint32 IwClassFactoryGetSize(uint32 hash);
# 223 "d:/marmalade/6.1/modules/iwutil/h/IwClassFactory.h"
void IwClassFactoryModify(uint32 hash, IwClassFactoryFn fn, uint32 size);
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwCopyingPtr.h" 1
       
# 29 "d:/marmalade/6.1/modules/iwutil/h/IwCopyingPtr.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwAllocator.h" 1
# 19 "d:/marmalade/6.1/modules/iwutil/h/IwAllocator.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eMemory.h" 1
# 20 "d:/marmalade/6.1/modules/iwutil/h/IwAllocator.h" 2
# 62 "d:/marmalade/6.1/modules/iwutil/h/IwAllocator.h"
class CIwDefaultMallocRouter
{
public:
    virtual ~CIwDefaultMallocRouter();
    virtual void* Alloc(uint32 size, uint32 objsize);
    virtual void Free(void* buf, uint32 objsize);
    virtual void* Realloc(void* buf, uint32 size, uint32 objsize);

    static CIwDefaultMallocRouter& Static();
    static void SetMallocRouter(CIwDefaultMallocRouter* a);

    static void* BaseAlloc(uint32 size, uint32 objsize);
    static void BaseFree(void* buf, uint32 objsize);
    static void* BaseRealloc(void* buf, uint32 size, uint32 objsize);
};
# 85 "d:/marmalade/6.1/modules/iwutil/h/IwAllocator.h"
template <class T>
class CIwMallocRouter : public CIwDefaultMallocRouter
{
public:
    static void* DoAlloc(uint32 size)
    {
        return BaseAlloc(size, sizeof(T));
    }
    static void DoFree(void* buf)
    {
        BaseFree(buf, sizeof(T));
    }
    static void* DoRealloc(void* buf, uint32 size)
    {
        return BaseRealloc(buf, size, sizeof(T));
    }
};
# 112 "d:/marmalade/6.1/modules/iwutil/h/IwAllocator.h"
template <class T, class M = CIwMallocRouter<T> > class CIwAllocator
{
public:
    typedef uint32 size_type;
    typedef int32 difference_type;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T value_type;
# 133 "d:/marmalade/6.1/modules/iwutil/h/IwAllocator.h"
    pointer allocate(size_type s)
    {
        return (pointer)M::DoAlloc(s);
    }





    pointer reallocate(pointer p, size_type s)
    {
        return (pointer)M::DoRealloc(p, s);
    }

    void deallocate(pointer p, size_type) { M::DoFree(p); }




};
# 30 "d:/marmalade/6.1/modules/iwutil/h/IwCopyingPtr.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h" 1
       
# 38 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
enum IwMemBucketID
{
    IW_MEM_BUCKET_ID_SYSTEM = 0,
    IW_MEM_BUCKET_ID_SYSTEM_DEBUG,
    IW_MEM_BUCKET_ID_USER,
};






enum IwMemBucketAllocFailBehaviour
{
    IW_MEM_BUCKET_ALLOC_FAIL_ERROR = 0,
    IW_MEM_BUCKET_ALLOC_FAIL_ASSERT,
    IW_MEM_BUCKET_ALLOC_FAIL_SILENT,

    IW_MEM_BUCKET_ALLOC_FAIL_DEFAULT = IW_MEM_BUCKET_ALLOC_FAIL_ERROR
};

class CIwMemBucket;

extern "C" {
# 74 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
void IwMemBucketCreate(uint32 bucketID, const char* name, uint32 size);
# 93 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
void IwMemBucketRegister(uint32 bucketID, const char* name, CIwMemBucket* bucket, void* data=__null);







void IwMemBucketFree(uint32 bucketID);







void IwMemBucketSet(uint32 bucketID);







uint32 IwMemBucketGetID();
# 127 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
int32 IwMemBucketGetFreeID(uint32 afterID = 0);







CIwMemBucket* IwMemBucketGet();







void IwMemBucketPush(uint32 bucketID);






void IwMemBucketPop();
# 172 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
void IwMemBucketSetAllocFailBehaviour(IwMemBucketAllocFailBehaviour behaviour);
# 182 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
IwMemBucketAllocFailBehaviour IwMemBucketGetAllocFailBehaviour();
# 199 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketCheckpoint();







uint32 IwMemBucketDebugGetID(void* item);
# 219 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketDebugCheck(uint32 bucketID, uint32 checkpoint, const char* filename);







void IwMemBucketVisualDump(const char* filename, int32 bucketID = -1);






typedef enum IwMemBucketDebugFlag
{
    IW_MEM_BUCKET_LOCK_FREE = 1 << 0,
    IW_MEM_BUCKET_LOCK_ALLOC = 1 << 1,
    IW_MEM_BUCKET_LOCK_SELECT = 1 << 2,
    IW_MEM_BUCKET_TRACE = 1 << 3,
    IW_MEM_BUCKET_LOCK_REALLOC = 1 << 4,
    IW_MEM_BUCKET_REUSE_IDS_FOR_REALLOC = 1 << 5,
} IwMemBucketDebugFlag;
# 251 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
void IwMemBucketDebugSetFlags(uint32 bucketID, uint32 flags);
# 260 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
void IwMemBucketDebugClearFlags(uint32 bucketID, uint32 flags);
# 270 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
void IwMemBucketDebugSetBreakpoint(uint32 allocationID);
# 289 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketGetFree(uint32 bucketID);
# 298 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketGetLargestFreeBlock(uint32 bucketID);
# 308 "d:/marmalade/6.1/modules/iwutil/h/IwMemory.h"
uint32 IwMemBucketGetUsed(uint32 bucketID);

}







class CIwAutoBucketSwitch
{
public:
    CIwAutoBucketSwitch(int bucket) : m_RestoreBucket(IwMemBucketGetID())
    {
        IwMemBucketSet(bucket);
    }
    ~CIwAutoBucketSwitch()
    {
        IwMemBucketSet(m_RestoreBucket);
    }

private:
    int m_RestoreBucket;
};
# 31 "d:/marmalade/6.1/modules/iwutil/h/IwCopyingPtr.h" 2
# 1 "d:/marmalade/6.1/s3e/h/std/c++/new" 1
# 21 "d:/marmalade/6.1/s3e/h/std/c++/new"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl/_prolog.h" 1
# 10 "d:/marmalade/6.1/s3e/h/std/c++/stl/_prolog.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h" 1
# 62 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl_user_config.h" 1
# 63 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h" 2




# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config_compat.h" 1
# 68 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h" 2



# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl/_site_config.h" 1
# 72 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h" 2


# 1 "d:/marmalade/6.1/s3e/h/std/c++/config/stlcomp.h" 1
# 54 "d:/marmalade/6.1/s3e/h/std/c++/config/stlcomp.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/config/stl_gcc_s3e.h" 1
# 67 "d:/marmalade/6.1/s3e/h/std/c++/config/stl_gcc_s3e.h"
     typedef char __stl_char;
# 55 "d:/marmalade/6.1/s3e/h/std/c++/config/stlcomp.h" 2
# 75 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h" 2
# 83 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/config/stl_confix.h" 1
# 84 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h" 2
# 488 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h"
namespace std { }
namespace __std_alias = std;
# 546 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config.h"
namespace _STL { }

namespace stlport = _STL;
# 11 "d:/marmalade/6.1/s3e/h/std/c++/stl/_prolog.h" 2





# 1 "d:/marmalade/6.1/s3e/h/std/c++/config/_prolog.h" 1
# 17 "d:/marmalade/6.1/s3e/h/std/c++/stl/_prolog.h" 2
# 22 "d:/marmalade/6.1/s3e/h/std/c++/new" 2




# 1 "d:/marmalade/6.1/s3e/h/std/c++/cstddef" 1
# 37 "d:/marmalade/6.1/s3e/h/std/c++/cstddef"
# 1 "d:/marmalade/6.1/s3e/h/ext/../std/stddef.h" 1
# 38 "d:/marmalade/6.1/s3e/h/std/c++/cstddef" 2



namespace _STL {
using ::ptrdiff_t;
using ::size_t;
}
# 27 "d:/marmalade/6.1/s3e/h/std/c++/new" 2
# 38 "d:/marmalade/6.1/s3e/h/std/c++/new"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/new.h" 1
# 52 "d:/marmalade/6.1/s3e/h/std/c++/new.h"
inline void* operator new(size_t, void* p) { return p;};
inline void* operator new[](size_t, void* p) { return p;};
inline void operator delete(void*, void*) {};
inline void operator delete[](void*, void*) {};
# 39 "d:/marmalade/6.1/s3e/h/std/c++/new" 2



# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl/_new.h" 1
# 11 "d:/marmalade/6.1/s3e/h/std/c++/stl/_new.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/exception" 1
# 58 "d:/marmalade/6.1/s3e/h/std/c++/exception"
# 1 "d:/marmalade/6.1/s3e/h/ext/../std/c++/exception.h" 1
# 18 "d:/marmalade/6.1/s3e/h/ext/../std/c++/exception.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/exception_gcc" 1
# 41 "d:/marmalade/6.1/s3e/h/std/c++/exception_gcc"
#pragma GCC visibility push(default)


extern "C++" {

namespace std
{
# 56 "d:/marmalade/6.1/s3e/h/std/c++/exception_gcc"
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();


    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }


    virtual ~bad_exception() throw();
  };


  typedef void (*terminate_handler) ();

  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();


  void terminate() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();


  void unexpected() __attribute__ ((__noreturn__));
# 104 "d:/marmalade/6.1/s3e/h/std/c++/exception_gcc"
  bool uncaught_exception() throw();
}

namespace __gnu_cxx
{
# 119 "d:/marmalade/6.1/s3e/h/std/c++/exception_gcc"
  void __verbose_terminate_handler ();
}

}


#pragma GCC visibility pop
# 19 "d:/marmalade/6.1/s3e/h/ext/../std/c++/exception.h" 2
# 59 "d:/marmalade/6.1/s3e/h/std/c++/exception" 2
# 75 "d:/marmalade/6.1/s3e/h/std/c++/exception"
namespace _STL {


using __std_alias::exception;
using __std_alias::bad_exception;
# 106 "d:/marmalade/6.1/s3e/h/std/c++/exception"
}
# 12 "d:/marmalade/6.1/s3e/h/std/c++/stl/_new.h" 2

namespace _STL {

struct nothrow_t {};


extern const nothrow_t nothrow;




class bad_alloc : public exception {
public:
  bad_alloc () throw() { }
  bad_alloc(const bad_alloc&) throw() { }
  bad_alloc& operator=(const bad_alloc&) throw() {return *this;}
  ~bad_alloc () throw() { }
  const char* what() const throw() { return "bad alloc"; }
};

}
# 50 "d:/marmalade/6.1/s3e/h/std/c++/stl/_new.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/new" 1
# 51 "d:/marmalade/6.1/s3e/h/std/c++/stl/_new.h" 2
# 80 "d:/marmalade/6.1/s3e/h/std/c++/stl/_new.h"
namespace _STL {





inline void* __stl_new(size_t __n) { void* __y = ::operator new(__n);if (__y == 0){;}return __y; }
inline void __stl_delete(void* __p) { ::operator delete(__p); }

}
# 43 "d:/marmalade/6.1/s3e/h/std/c++/new" 2



# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl/_epilog.h" 1
# 10 "d:/marmalade/6.1/s3e/h/std/c++/stl/_epilog.h"
# 1 "d:/marmalade/6.1/s3e/h/std/c++/config/_epilog.h" 1
# 11 "d:/marmalade/6.1/s3e/h/std/c++/stl/_epilog.h" 2



# 1 "d:/marmalade/6.1/s3e/h/std/c++/stl/_config_compat_post.h" 1
# 15 "d:/marmalade/6.1/s3e/h/std/c++/stl/_epilog.h" 2
# 47 "d:/marmalade/6.1/s3e/h/std/c++/new" 2
# 32 "d:/marmalade/6.1/modules/iwutil/h/IwCopyingPtr.h" 2


template<class T>
class CIwStandardAllocator
{
public:
    static T* allocate(uint32 size)
    {
        return (T*)s3eMalloc(size);
    }

    static T* reallocate(T* p, uint32 size)
    {
        return (T*)s3eRealloc(p, size);
    }

    static void deallocate(T* p, uint32) { s3eFree(p); }
};


template <class Type, class Allocator = CIwStandardAllocator<Type> >
class CIwCopyingPtr
{
public:
    CIwCopyingPtr() : m_Ptr(__null) {}
    ~CIwCopyingPtr()
    {
        if( m_Ptr )
        {
            m_Ptr->~Type();
            Allocator::deallocate(m_Ptr, 1);
        }
        m_Ptr = __null;
    }




    CIwCopyingPtr(const CIwCopyingPtr& rhs)
    {
        if (rhs.m_Ptr)
        {
            m_Ptr = new (Allocator::allocate(sizeof(Type))) Type;
            *m_Ptr = *rhs.m_Ptr;
        }
        else
        {
            m_Ptr = __null;
        }
    }

    CIwCopyingPtr& operator=(const CIwCopyingPtr& rhs)
    {
        if( m_Ptr )
        {
            m_Ptr->~Type();
            Allocator::deallocate(m_Ptr, 1);
        }

        if (rhs.m_Ptr)
        {
            m_Ptr = new (Allocator::allocate(sizeof(Type))) Type;
            *m_Ptr = *rhs.m_Ptr;
        }
        else
        {
            m_Ptr = __null;
        }
        return *this;
    }




    CIwCopyingPtr& operator= (Type* pPtr)
    {
        if( m_Ptr )
        {
            m_Ptr->~Type();
            Allocator::deallocate(m_Ptr, 1);
        }
        m_Ptr = pPtr;
        return *this;
    }

    Type* operator->() const
    {
        return m_Ptr;
    }

    Type& operator*() const
    {
        return *m_Ptr;
    }

    bool operator!= (Type* pPtr) const
    {
        return m_Ptr != pPtr;
    }


    void Release()
    {
        m_Ptr = __null;
    }

private:



    Type* m_Ptr;
};

template<class T>
class CIwDebugAllocator
{
public:
    static T* allocate(uint32 size)
    {




        T* alloc = (T*)s3eMalloc(size);




        return alloc;
    }

    static T* reallocate(T* p, uint32 size)
    {




        T* alloc = (T*)s3eRealloc(p, size);




        return alloc;
    }


    static void deallocate(T* p, uint32) { s3eFree(p); }
};
# 18 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwDivTable.h" 1
       
# 130 "d:/marmalade/6.1/modules/iwutil/h/IwDivTable.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwDivide.h" 1
# 131 "d:/marmalade/6.1/modules/iwutil/h/IwDivTable.h" 2
# 19 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwEvent.h" 1
       
# 26 "d:/marmalade/6.1/modules/iwutil/h/IwEvent.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h" 1
       
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h" 1
# 37 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwMath.h" 1
# 38 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h" 2
# 48 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
template <class X, class A>
class ReallocateDefault
{
public:
    static X* Reallocate(uint32 q, uint32 num_p, uint32 max_p, X* p, A& a)
    {
        return a.reallocate(p, q*sizeof(X));
    }
};

template <class X, class A>
class ReallocateStandard
{
public:
    static X* Reallocate(uint32 q, uint32 num_p, uint32 max_p, X* p, A& a)
    {
        X* new_p = a.allocate(q*sizeof(X));
        for (uint32 i = 0; i < num_p; i++)
        {
            new (&new_p[i]) X(p[i]);
            p[i].~X();
        }
        a.deallocate(p, max_p);
        return new_p;
    }
};






template <class X, class A=CIwAllocator<X>, class REALLOCATE = ReallocateDefault<X, A > >
class CIwArray
{
protected:
    X * p;
    uint32 num_p;
    uint32 max_p;
    bool block_delete : 1;
    bool no_grow : 1;
public:
    typedef X * iterator;
    typedef const X * const_iterator;





    iterator begin() const { return p; }





    iterator end() const { return p+num_p; }




    bool empty() const { return num_p==0; }




    uint32 size() const { return num_p; }





    uint32 capacity() const { return max_p; }





    X* data() { return p; }





    explicit CIwArray(uint32 sz=0) : p(0), num_p(0), max_p(0), block_delete(false), no_grow(false)
    {
        resize(sz);
        clear();
    }

    ~CIwArray()
    {
        for (uint32 i=0; i<num_p; i++)
            p[i].~X();
        if (!block_delete)
        {
            a.deallocate(p, num_p);
            p = 0;
        }
    }






    CIwArray(CIwArray const & v) : p(0), num_p(0), max_p(0), block_delete(false), no_grow(false)
    {
        (*this) = v;
    }







    void SerialiseHeader()
    {

        if (g_IwSerialiseContext.read)
        {
            uint32 s;
            IwSerialiseUInt32(s);
            resize_optimised(s);
        }
        else
        {
            uint32 s = size();
            IwSerialiseUInt32(s);
        }

    }






    void operator=(CIwArray const & v)
    {
        clear();
        if (v.size() < max_p/2 || v.size() > max_p)
            set_capacity(v.size());
        for (uint32 i=0; i<v.size(); i++)
            push_back( v.p[i] );
    }





    void clear()
    {
        truncate(0);
    }






    void clear_optimised()
    {
        truncate(0);
        set_capacity(0);
    }




    int MemoryUsage() const
    {
        return sizeof(X)*max_p + sizeof(*this);
    }







    void resize_optimised(uint32 s)
    {
        if (s > num_p)
            set_capacity(s);
        resize(s);
        set_capacity(num_p);
    }






    void optimise_capacity()
    {
        if (!block_delete)
            set_capacity(num_p);
    }






    void reserve(uint32 q)
    {
        if (q > max_p)
        {
            set_capacity( q+(max_p<16 ? 2 : max_p/8) );
        }
    }






    void reserve_optimised(int q)
    {
        ((void)0);
        if (q > (int)max_p)
        {
            set_capacity( q );
        }
    }







    void resize_quick(const uint32 q)
    {
        ((void)0);
        num_p = q;
    }






    void resize(const uint32 q)
    {
        if (q <= num_p)
            truncate(q);
        else
            push_back_qty(q-num_p);
    }
# 308 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    int find(X const & value) const
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                return i;
            }
        return -1;
    }






    bool contains(X const & value) const
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                return true;
            }
        return false;
    }
# 344 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    bool find_and_remove(X const & value)
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                erase(i, i+1);
                return true;
            }
        return false;
    }
# 366 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    bool find_and_remove_fast(X const & value)
    {
        for (uint32 i=0; i<num_p; i++)
            if (p[i]==value)
            {
                erase_fast(i, i+1);
                return true;
            }
        return false;
    }







    void pop_back()
    {
        truncate(num_p-1);
    }







    X pop_back_get()
    {
        ((void)0);

        X temp = p[num_p-1];
        pop_back();
        return temp;
    }
# 412 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    int erase_fast(const int i)
    {
        return erase_fast(i,i+1);
    }
# 428 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    int erase_fast(const int i, const int j)
    {
        ((void)0);

        const uint32 w = j-i;
        const uint32 w_copy = (((w) < (num_p-j)) ? (w) : (num_p-j));

        for (uint32 k=0; k<w_copy; k++)
            p[i+k] = p[num_p-w_copy+k];

        truncate(num_p-w);
        return i;
    }





    iterator erase_fast(iterator i)
    {
        return p + erase_fast(i-p,i-p+1);
    }






    iterator erase_fast(iterator i, iterator j)
    {
        return p + erase_fast(i-p,j-p);
    }
# 470 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    int erase(const int i)
    {
        return erase(i, i+1);
    }
# 484 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    int erase(const uint32 i, const uint32 j)
    {
        ((void)0);
        const int w = j-i;
        for (uint32 k=i; k<num_p-w; k++)
            p[k] = p[k+w];
        truncate(num_p-w);
        return i;
    }





    iterator erase(iterator i)
    {
        return p + erase(i-p,i-p+1);
    }






    iterator erase(iterator i, iterator j)
    {
        return p + erase(i-p,j-p);
    }







    void insert_slow(X const & x, uint32 pos)
    {
        ((void)0);
        if (pos==size())
            push_back(x);
        else
        {
            reserve(num_p+1);
            for (int k=num_p-pos-1; k>=0; k--)
                p[pos+k+1] = p[pos+k];
            num_p++;
            p[pos] = x;
        }
    }







    void insert_slow(CIwArray &a, uint32 pos)
    {
        ((void)0);
        if (pos==size())
            append(a);
        else
        {
            int s = a.size();
            reserve(num_p+s);
            for (int k=num_p-pos-1; k>=0; k--)
                p[pos+k+s] = p[pos+k];
            num_p+=s;
            for (int i=0;i<s;i++)
                p[pos+i] = a.p[i];
        }
    }






    X const & back() const
    {
        ((void)0);
        return p[size()-1];
    }
    X & back()
    {
        ((void)0);
        return p[size()-1];
    }






    X const & front() const
    {
        ((void)0);
        return p[0];
    }

    X & front()
    {
        ((void)0);
        return p[0];
    }





    int append(X const & x) { return push_back(x); }
# 603 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    int append(CIwArray & a)
    {
        int c = num_p;
        resize(num_p+a.num_p);
        for (uint32 d=0;d<a.num_p;d++)
            p[c+d] = a.p[d];
        return num_p-1;
    }







    int push_back(X const & x)
    {
# 632 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
        ((void)0);

        reserve(num_p+1);
        ((void)0);
        new (p+num_p) X(x);
        return num_p++;
    }






    int push_back()
    {
        reserve(num_p+1);
        new (p+num_p) X;
        return num_p++;
    }







    void push_back_qty(X const & x, int qty)
    {
        if (!qty) return;
        ((void)0);
        ((void)0);
        reserve(num_p+qty);
        for (int i=0; i<qty; i++)
        {
            new (p+num_p+i) X(x);



        }
        num_p+=qty;
    }






    void push_back_qty(int qty)
    {
        ((void)0);
        reserve(num_p+qty);
        for (int i=0; i<qty; i++)
            new (p+num_p+i) X;
        num_p+=qty;
    }







    X & operator [] (int const i) const
    {
        uint32 index = (uint32)i;
        ((void)0);
        return p[index];
    }






    void Share(CIwArray<X,A> const & other)
    {
        if (!block_delete)
            clear_optimised();
        p=other.p;
        num_p=other.num_p;
        max_p=other.max_p;
        block_delete = true;
    }
# 723 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    void Share(X* buffer, int current, int max)
    {
        if (!block_delete)
            clear_optimised();
        p=buffer;
        num_p=current;
        max_p=max;
        block_delete = true;
    }





    bool CanResize()
    {
        return !block_delete;
    }
# 749 "d:/marmalade/6.1/modules/iwutil/h/IwArray.h"
    void LockSize(bool lock)
    {
        no_grow = lock;
    }





    void set_capacity(uint32 q);






    void truncate(const uint32 q)
    {
        ((void)0);

        for (uint32 i=q; i<num_p; i++)
            p[i].~X();
        num_p = q;
    }





    void swap(CIwArray<X,A>& v)
    {
        X* tmp_p = p;
        uint32 tmp_num_p = num_p;
        uint32 tmp_max_p = max_p;
        bool tmp_block_delete = block_delete;
        bool tmp_no_grow = no_grow;

        p = v.p;
        num_p = v.num_p;
        max_p = v.max_p;
        block_delete = v.block_delete;
        no_grow = v.no_grow;

        v.p = tmp_p;
        v.num_p = tmp_num_p;
        v.max_p = tmp_max_p;
        v.block_delete = tmp_block_delete;
        v.no_grow = tmp_no_grow;
    }

private:
    A a;
};

template <class X, class A, class REALLOCATE>
void CIwArray<X,A,REALLOCATE>::set_capacity(uint32 q)
{
    ((void)0);
    ((void)0);
    ((void)0);
    if (max_p==q) return;
    max_p = q;
    if (q==0)
    {
        a.deallocate(p, max_p);
        p = 0;
    }
    else
    {
        p = REALLOCATE::Reallocate(q, num_p, max_p, p, a);
    }
}



template<>
class CIwArray<bool, CIwAllocator<bool> >
{
    CIwArray<uint32, CIwAllocator<uint32> > b;
    int l;
    void fit()
    {
        ((void)0);
        b.resize((l+31) >> 5);
    }
public:
    CIwArray<bool, CIwAllocator<bool> >(int sz=0) : l(sz) { fit(); }
    void resize(int s)
    {
        l = s;
        fit();
    }
    void resize(int s, bool set_value)
    {
        resize(s);
        set_all(set_value);
    }
    void clear()
    {
        resize(0);
    }
    void clear_optimised()
    {
        b.clear_optimised();
    }
    uint32 size() const
    {
        return l;
    }
    void push_back(bool i)
    {
        l++;
        fit();
        set(l-1, i);
    }
    bool pop_back()
    {
        ((void)0);
        bool r = (*this)[l-1];
        l--;
        fit();
        return r;
    }
    void set_all(bool v)
    {
        for (uint32 i=0; i<b.size(); i++)
            b[i] = v ? 0xffffffff : 0;
    }
    void set(int i, bool v)
    {
        ((void)0);
        if (v)
            b[i>>5] |= (1<<(i&31));
        else
            b[i>>5] &= ~(1<<(i&31));
    }
    bool operator[] (int i) const
    {
        ((void)0);
        return (b[i>>5] & (1<<(i&31))) != 0;
    }

    void Serialise()
    {

        int32 il = l;
        IwSerialiseInt32(il);
        l = il;
        b.SerialiseHeader();
        IwSerialiseUInt32(*b.data(), b.size());

    }
};
# 18 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h" 2



# 1 "d:/marmalade/6.1/modules/iwutil/h/IwHashString.h" 1
       
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwHashString.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwString.h" 1
# 24 "d:/marmalade/6.1/modules/iwutil/h/IwString.h"
# 1 "d:/marmalade/6.1/s3e/h/std/string.h" 1
# 17 "d:/marmalade/6.1/s3e/h/std/string.h"
extern "C" {

void *memcpy(void *dest, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
void *memmove(void *dest, const void *src, size_t n);
void *memchr(const void *s, int c, size_t n);
void *memrchr(const void *s, int c, size_t n);







int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
char *strsep(char **stringp, const char *delim);
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
char *strchr(const char *s, int c);
char *strstr(const char *haystack, const char *needle);
char *strrchr(const char *s, int c);
char *strdup(const char *s);
char *strtok(char *str, const char *delim);
char *strtok_r(char *str, const char *delim, char **saveptr);
char *strcat(char *dest, const char *src);
char *strncat(char *dest, const char *src, size_t n);
size_t strlen(const char *s);
size_t strnlen(const char *s, size_t n);
int strcasecmp(const char *s1, const char *s2);
int strncasecmp(const char *s1, const char *s2, size_t n);
size_t strspn(const char *s, const char *accept);
size_t strcspn(const char *s, const char *reject);
char *strpbrk(const char *s, const char *accept);
int strcoll(const char *s1, const char *s2);
char *strerror(int errnum);
size_t strxfrm(char *dest, const char *src, size_t n);

int strerror_r(int errnum, char *buf, size_t buflen);





size_t strlcpy(char* dest, const char* src, size_t len);
size_t strlcat(char* dest, const char* src, size_t len);

}
# 25 "d:/marmalade/6.1/modules/iwutil/h/IwString.h" 2
# 74 "d:/marmalade/6.1/modules/iwutil/h/IwString.h"
template <int N>
class CIwString
{


public:
    inline CIwString()
    {
        m_Buffer[0] = '\0';
    };

    CIwString(const char* pText)
    {
        m_Buffer[0] = '\0';
        ((void)0);
        strcpy(m_Buffer, pText);
    };
# 104 "d:/marmalade/6.1/modules/iwutil/h/IwString.h"
    inline const char* c_str() const {return m_Buffer;}
# 113 "d:/marmalade/6.1/modules/iwutil/h/IwString.h"
    inline int size() const {return strlen(m_Buffer);}
# 122 "d:/marmalade/6.1/modules/iwutil/h/IwString.h"
    inline int length() const {return strlen(m_Buffer);}






    inline int capacity() const {return N-1;}






    inline void setLength(int len)
    {
        ((void)0);
        ((void)0);
        m_Buffer[len] = '\0';
    }

    inline int find(const char* substr)
    {
        char*p = strstr(m_Buffer, substr);
        if (p)
            return (int)(p - m_Buffer);
        return -1;
    }

    inline CIwString substr(int pos, int len = -1) const
    {
        if (len < 0)
            len = length() - pos;

        CIwString s(m_Buffer + pos);
        s.setLength(len);
        return s;
    }

    inline char & operator [] (int i)
    {
        ((void)0);
        ((void)0);
        return m_Buffer[i];
    }

    inline const char & operator [] (int i) const
    {
        ((void)0);
        ((void)0);
        return m_Buffer[i];
    }






    const char* operator = (const char* pText)
    {
        ((void)0);
        strcpy(m_Buffer, pText);
        return m_Buffer;
    };

    const char* operator = ( CIwString const& str)
    {
        ((void)0);
        strcpy(m_Buffer, str.c_str());
        return m_Buffer;
    };

    const char* operator += (const char* pText)
    {
        ((void)0);
        strcat(m_Buffer, pText);
        return m_Buffer;
    };

    const char* operator += (CIwString const& str)
    {
        ((void)0);
        strcat(m_Buffer, str.c_str());
        return m_Buffer;
    };

    CIwString operator + (const char* pText)
    {
        ((void)0);
        CIwString ns = *this;
        strcat(ns.m_Buffer, pText);
        return ns;
    }

    CIwString operator + (const CIwString& str)
    {
        ((void)0);
        CIwString ns = *this;
        strcat(ns.m_Buffer, str.c_str());
        return ns;
    }

    const char* operator += (char c)
    {
        ((void)0);
        char str[2] = {c, '\0'};
        strcat(m_Buffer, str);
        return m_Buffer;
    };

    bool operator== (const char* str) const
    {
        return !strcmp(m_Buffer, str);
    }

    bool operator== (const CIwString& str) const
    {
        return !strcmp(m_Buffer, str.c_str());
    }







    inline void Serialise()
    {
        IwSerialiseString(m_Buffer, N);
    }



private:
    char m_Buffer[N];
};

template <int N>
static inline CIwString<N> operator + (const char *str1, const CIwString<N> &str2)
{
    return CIwString<N>(str1) + str2;
}






typedef CIwString<32> CIwStringS;




typedef CIwString<160> CIwStringL;
# 18 "d:/marmalade/6.1/modules/iwutil/h/IwHashString.h" 2
# 40 "d:/marmalade/6.1/modules/iwutil/h/IwHashString.h"
uint32 IwHashString(const char* pChar);
# 49 "d:/marmalade/6.1/modules/iwutil/h/IwHashString.h"
template<int N> uint32 IwHashString(const CIwString<N>& sz)
{
   

    return IwHashString(sz.c_str());
}
# 65 "d:/marmalade/6.1/modules/iwutil/h/IwHashString.h"
uint32 IwHashString(const char* pChar, uint32 hash);
# 22 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwTextParseable.h" 1
       
# 21 "d:/marmalade/6.1/modules/iwutil/h/IwTextParseable.h"
class CIwTextParserITX;
# 41 "d:/marmalade/6.1/modules/iwutil/h/IwTextParseable.h"
class CIwParseable
{
public:


    typedef CIwArray<CIwParseable*> Array;

    typedef Array::iterator ArrayIt;

    virtual ~CIwParseable() {}
# 60 "d:/marmalade/6.1/modules/iwutil/h/IwTextParseable.h"
    virtual void ParseOpen(CIwTextParserITX* pParser) = 0;







    virtual void ParseClose(CIwTextParserITX* pParser) = 0;







    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName) = 0;
};
# 24 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h" 1
       
# 22 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwSingleton.h" 1
# 23 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwTypes.h" 1
# 37 "d:/marmalade/6.1/modules/iwutil/h/IwTypes.h"
enum
{

    IW_TYPE_NONE = 0,
    IW_TYPE_CHAR,
    IW_TYPE_BOOL,
    IW_TYPE_INT8,
    IW_TYPE_UINT8,
    IW_TYPE_INT16,
    IW_TYPE_UINT16,
    IW_TYPE_INT32,
    IW_TYPE_UINT32,
    IW_TYPE_FLOAT,
    IW_TYPE_DOUBLE,
    IW_TYPE_STRING,
    IW_TYPE_COMPOUND,
    IW_TYPE_MAX,

    IW_TYPE_MAX_BIT = 4,


    IW_TYPE_PAD_F = (1 << 4),


    IW_TYPE_FREE_BIT = 6
};
# 25 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h" 2


class CIwMenuItem;
class CIwMenu;
# 44 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
typedef CIwStringS CIwMenuString;
# 53 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
class CIwMenuItem
{
public:

    enum
    {
        HILITE_F = (1 << 0),
        UNSELECTABLE_F = (1 << 1),
        NO_SCROLL_F = (1 << 2),
        PARAGRAPH_END_F = (1 << 3),
    };




    enum ColourID
    {
        TITLE,
        MENU,
        FIELD,
        BOOL,
        STRING,
        FIXED,
        HILITE,
        MAX_COLOUR_ID,
    };

    typedef CIwArray<CIwMenuItem*> Array;
    typedef Array::iterator ArrayIt;


    CIwMenuItem(const char* name, const char* text, uint32 flags = 0, ColourID colID = FIELD);
    virtual ~CIwMenuItem();





    virtual void Update(bool active);






    virtual void Render(int32 x, int32 y);





    virtual void Enter() { m_Flags |= HILITE_F;}





    virtual void Exit() { m_Flags &= ~HILITE_F;}





    virtual void Select() { };





    virtual void Back();





    virtual void Run()
    {

        Select();
    };





    virtual void Plus() { };





    virtual void Minus() { };






    inline void SetSelectable(bool s)
    {
        if (s == true)
            m_Flags &= ~UNSELECTABLE_F;
        else
            m_Flags |= UNSELECTABLE_F;
    }





    inline CIwMenu* GetMenu() const {return m_Menu;}




    const char* m_Name;
    ColourID m_ColourID;
    CIwMenuString m_Text;
    int32 m_X;
    int32 m_Y;
    int32 m_W;
    int32 m_H;
private:
    int32 m_Flags;
    CIwMenu* m_Menu;

    friend class CIwMenu;
};
# 189 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
class CIwMenu
{
public:

    enum
    {
        UPDATE_ALWAYS_F = (1 << 0),
        RENDER_ALWAYS_F = (1 << 1),
    };

    typedef CIwArray<CIwMenu*> Array;
    typedef Array::iterator ArrayIt;


    CIwMenu(int32 x = -1, int32 y = -1, uint32 flags = 0);
    virtual ~CIwMenu();


    virtual void Update(bool active);


    virtual void Render(bool active);


    virtual void Enter();


    virtual void Exit();






    virtual int32 AddItem(CIwMenuItem* item, int32 index = -1);





    virtual void RemoveItem(int32 index);







    virtual void SetNextSelectable(bool down, int start = -1, int count = 1);





    virtual void SetItemID(int32 id);






    virtual void SetXY(int32 x, int32 y) { m_X = x, m_Y = y;}




    CIwMenuItem::Array m_ItemArray;
    int32 m_Flags;
    int32 m_ItemID;
    int32 m_X;
    int32 m_Y;
    int32 m_ScrollID;
    int32 m_ScrollHeight;
    CIwMenu* m_Parent;
    bool m_Wrap;
};







class CIwMenuManager
{
public:



    typedef void(*TextCallback)(const char* line, int32 x, int32 y, CIwMenuItem::ColourID colID);



    typedef CIwMenu*(*MainFn)();


    enum
    {

        INPUT_UP_F = (1 << 0),
        INPUT_DOWN_F = (1 << 1),
        INPUT_LEFT_F = (1 << 2),
        INPUT_RIGHT_F = (1 << 3),
        INPUT_RUN_F = (1 << 4),
        INPUT_SHIFT_F = (1 << 5),
        INPUT_CTRL_F = (1 << 6),
        INPUT_PLUS_F = (1 << 7),
        INPUT_MINUS_F = (1 << 8),
        INPUT_MASK = (1 << 9) - 1,


        DESTROY_MENU_F = (1 << 10),
        SELECT_MENU_F = (1 << 11),
        REBUILD_MENU_F = (1 << 12),
        UPDATE_F = (1 << 14),
        RENDER_F = (1 << 15),
    };


    CIwMenuManager();
    virtual ~CIwMenuManager();




    void DestroyMenus();






    virtual void Update();






    virtual void Render();





    void AddMenu(CIwMenu* menu);





    void AddMenuOrDestroy(CIwMenu* pMenu);




    inline void DestroyMenu() {m_Flags |= DESTROY_MENU_F;}





    void SelectMenu(int32 forceID = -1)
    {
        m_Flags |= SELECT_MENU_F;
        m_ForceItemID = forceID;
    }





    void RebuildMenu(int32 forceID = -1)
    {
        m_Flags |= REBUILD_MENU_F;
        m_ForceItemID = forceID;
    }






    inline void SetMenuCharWH(uint32 w, uint32 h)
    {
        m_CharW = w;
        m_CharH = h;
    }






    inline void SetMenuDefaultXY(uint32 x, uint32 y)
    {
        m_MenuDefaultX = x;
        m_MenuDefaultY = y;
    }





    inline void SetMenuDefaultW(uint32 w)
    {
        m_MenuDefaultW = w;
    }





    inline void SetTextCallback(TextCallback cb) {m_TextCallback = cb;}





    inline void SetFocusKey(int32 k) {m_KeyDef[MK_FOCUS] = k;}





    inline bool HasFocus() {return m_Focus;}





    void SetFocus(bool focus);





    inline void SetMainMenuFn(MainFn cb) {m_MainFn = cb;}




    CIwMenu::Array m_MenuArray;
    CIwMenu* m_MenuActive;
    uint32 m_Flags;
    int32 m_ForceItemID;
    TextCallback m_TextCallback;
    uint32 m_CharW;
    uint32 m_CharH;
    uint32 m_MenuDefaultX;
    uint32 m_MenuDefaultY;
    uint32 m_MenuDefaultW;

private:
    enum CIwMenuKeyBind
    {
        MK_UP,
        MK_DOWN,
        MK_LEFT,
        MK_RIGHT,
        MK_ENTER,
        MK_SHIFT,
        MK_CONTROL,
        MK_PLUS,
        MK_MINUS,
        MK_INPUT,
        MK_FOCUS,
        COUNT_MENU_KEYS
    };
    uint32 m_KeyDef[COUNT_MENU_KEYS];
    bool m_Focus;
    bool m_Input;
    bool m_Destroy;
    bool m_Create;
    MainFn m_MainFn;
    uint32 m_LastInput;
    uint32 m_AutoRepeatTime;
};

extern CIwMenuManager* g_IwMenuManager;




inline CIwMenuManager* IwGetMenuManager() {return g_IwMenuManager;}
# 482 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
class CIwMenuItemString : public CIwMenuItem
{
public:






    CIwMenuItemString(const char* text, const char* string, uint32 flags = 0) : CIwMenuItem("", text, flags, CIwMenuItem::STRING), m_String(string) {};
    void Render(int32 x, int32 y);
    const char* m_String;
};




class CIwMenuItemEditValue : public CIwMenuItem
{
public:
    CIwMenuItemEditValue(const char* text, void* pValue, uint32 type, float delta = 1.0f, float min = 0.0f, float max = 1.0f, float def = 0.0f, CIwMenuItem::ColourID colID = CIwMenuItem::FIELD) : CIwMenuItem("", text, 0, colID)
    {
        m_Type = type;
        m_Value = pValue;
        m_Delta = delta;
        m_Default = def;
        m_Min = min;
        m_Max = max;
        if (m_Delta == 0.0f)
            m_ColourID = CIwMenuItem::FIXED;
    };
    ~CIwMenuItemEditValue() {};
    void Back() {IwGetMenuManager()->DestroyMenu();}
    void Plus();
    void Minus();
    virtual void EditMember(float delta);
    void Render(int32 x, int32 y);

    uint32 m_Type;
    void* m_Value;
    float m_Delta;
    float m_Default;
    float m_Min;
    float m_Max;
};







class CIwMenuItemEditInt8 : public CIwMenuItemEditValue
{
public:
# 546 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditInt8( const char* text, int8* pValue, float delta = 1.0f, float min = (float)(-0x7f - 1), float max = (float)0x7f, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_INT8, delta, min, max, def) {};
};




class CIwMenuItemEditUInt8 : public CIwMenuItemEditValue
{
public:
# 564 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditUInt8( const char* text, uint8* pValue, float delta = 1.0f, float min = (float)0x0, float max = (float)0xff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_UINT8, delta, min, max, def) {};
};




class CIwMenuItemEditInt16 : public CIwMenuItemEditValue
{
public:
# 582 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditInt16( const char* text, int16* pValue, float delta = 1.0f, float min = (float)(-0x7fff - 1), float max = (float)0x7fff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_INT16, delta, min, max, def) {};
};




class CIwMenuItemEditUInt16 : public CIwMenuItemEditValue
{
public:
# 600 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditUInt16( const char* text, uint16* pValue, float delta = 1.0f, float min = (float)0x0, float max = (float)0xffff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_UINT16, delta, min, max, def) {};
};




class CIwMenuItemEditInt32 : public CIwMenuItemEditValue
{
public:
# 618 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditInt32( const char* text, int32* pValue, float delta = 1.0f, float min = (float)(-0x7fffffffL - 1), float max = (float)0x7fffffffL, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_INT32, delta, min, max, def) {};
};




class CIwMenuItemEditUInt32 : public CIwMenuItemEditValue
{
public:
# 636 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditUInt32( const char* text, uint32* pValue, float delta = 1.0f, float min = (float)0x0000, float max = (float)0xffff, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_UINT32, delta, min, max, def) {};
};




class CIwMenuItemEditFloat : public CIwMenuItemEditValue
{
public:
# 654 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditFloat( const char* text, float* pValue, float delta = 0.01f, float min = (float)(-0x7fffffffL - 1), float max = (float)0x7fffffffL, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_FLOAT, delta, min, max, def) {};
};




class CIwMenuItemEditBool : public CIwMenuItemEditValue
{
public:
# 672 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditBool( const char* text, bool* pValue, float delta = 1.0f, float min = (float)0x0, float max = (float)0x1, float def = 0.0f) : CIwMenuItemEditValue(text, (void*)pValue, IW_TYPE_BOOL, delta, min, max, def, CIwMenuItem::BOOL) {};
};




class CIwMenuItemDisplayValue : public CIwMenuItemEditValue
{
public:
    CIwMenuItemDisplayValue(const char* text, uint32 Value, uint32 type, CIwMenuItem::ColourID colID = CIwMenuItem::FIXED) : CIwMenuItemEditValue(text, __null, type, 0, 0, 0, 0, colID)
    {
        m_Type = type;
        m_StoreValue = Value;
        m_Value = (void*)&m_StoreValue;
    };
    ~CIwMenuItemDisplayValue() {};
    virtual void EditMember(float delta) { }
    uint32 m_StoreValue;
};







class CIwMenuItemTitle: public CIwMenuItem
{
public:




    CIwMenuItemTitle(const char* text) : CIwMenuItem("", text, CIwMenuItem::UNSELECTABLE_F, CIwMenuItem::TITLE) {}
};







class CIwMenuItemEditFlags : public CIwMenuItemEditUInt32
{
public:






    CIwMenuItemEditFlags(const char* text, uint32* pValue, uint32 mask) : CIwMenuItemEditUInt32(text, pValue)
    {
        m_Type = IW_TYPE_UINT32;
        m_Default = (float)mask;
        m_ColourID = CIwMenuItem::BOOL;
    };
    void EditMember(float delta)
    {
        *(uint32*)m_Value ^= (uint32)m_Default;
    }
    void Render(int32 x, int32 y);
};







class CIwMenuItemEditEnum : public CIwMenuItemEditUInt32
{
public:
# 754 "d:/marmalade/6.1/modules/iwutil/h/IwMenu.h"
    CIwMenuItemEditEnum(const char* text, uint32* pValue, const char** ppNames = __null, bool edit = true, uint32 min = 0, uint32 max = 0);
    void Render(int32 x, int32 y);
    const char** m_Names;
};







class CIwMenuItemDisplayInt8 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayInt8( const char* text, int8 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_INT8) {};
};




class CIwMenuItemDisplayUInt8 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayUInt8( const char* text, uint8 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_UINT8) {};
};




class CIwMenuItemDisplayInt16 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayInt16( const char* text, int16 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_INT16) {};
};




class CIwMenuItemDisplayUInt16 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayUInt16( const char* text, uint16 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_UINT16) {};
};




class CIwMenuItemDisplayInt32 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayInt32( const char* text, int32 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_INT32) {};
};




class CIwMenuItemDisplayUInt32 : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayUInt32( const char* text, uint32 Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_UINT32) {};
};




class CIwMenuItemDisplayFloat : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayFloat( const char* text, float Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_FLOAT) {};
};




class CIwMenuItemDisplayBool : public CIwMenuItemDisplayValue
{
public:





    CIwMenuItemDisplayBool( const char* text, bool Value ) : CIwMenuItemDisplayValue(text, (uint32)Value, IW_TYPE_BOOL) {};
};
# 25 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h" 2

class CIwEvent;
class CIwManaged;
class CIwTextParserITX;
# 108 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
class CIwManaged : public CIwParseable
{
public:
    typedef CIwArray<CIwManaged*> Array;
    typedef Array::iterator ArrayIt;

    CIwManaged();
    virtual ~CIwManaged();






    virtual void Serialise();
# 134 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
    virtual void Resolve();
# 143 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
    virtual void ParseOpen(CIwTextParserITX* pParser) {};
# 154 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
    virtual bool ParseAttribute(CIwTextParserITX* pParser, const char* pAttrName);
# 164 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
    virtual void ParseClose(CIwTextParserITX* pParser);
# 176 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
    virtual void ParseCloseChild(CIwTextParserITX* pParser, CIwManaged* pChild);
# 187 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
    virtual bool HandleEvent(CIwEvent* pEvent) {return false;}
# 196 "d:/marmalade/6.1/modules/iwutil/h/IwManaged.h"
    virtual void SetName(const char* pName);


    virtual const char* GetClassName() const;


    inline const char* DebugGetName() const
    {



        ((void)0);
        return "";

    }


    virtual void DebugRender() {};


    virtual void DebugAddMenuItems(CIwMenu* pMenu);


    void _SetNameNoHash(const char* pName);
    void _CopyNameAndHash(const CIwManaged* pObj);

    uint32 m_Hash;

    static void _EnableParsing();

    virtual void _Replace(CIwManaged* pRHS);

protected:
    void DebugSerialiseName();

private:
    CIwCopyingPtr<CIwStringL, CIwDebugAllocator<CIwStringL> > m_DebugName;

    friend class CIwMaterial;
};




class CIwMenuItemManaged : public CIwMenuItemString
{
public:
    CIwMenuItemManaged(const char* pString, CIwManaged* pObj) : CIwMenuItemString("", "")
    {
        m_Obj = pObj;
        m_Text = (pString) ? pString : pObj->GetClassName();
    };
    void Select();
    CIwManaged* m_Obj;
};

typedef void (*IwManagedConstructorCallback)(CIwManaged*);
typedef void (*IwManagedDestructorCallback)(CIwManaged*);
typedef void (*IwManagedSerialiseCallback)(CIwManaged*);
void _IwManagedSetConstructorCallback(IwManagedConstructorCallback fn);
void _IwManagedSetDestructorCallback(IwManagedDestructorCallback fn);
void _IwManagedSetSerialiseCallback(IwManagedSerialiseCallback fn);
IwManagedConstructorCallback _IwManagedGetConstructorCallback();
IwManagedDestructorCallback _IwManagedGetDestructorCallback();
IwManagedSerialiseCallback _IwManagedGetSerialiseCallback();
# 27 "d:/marmalade/6.1/modules/iwutil/h/IwEvent.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h" 1
       
# 51 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
typedef void(*IwManagedListSerialiseCallback)(CIwManaged*);
void IwManagedListSetSerialiseCallbackPre(IwManagedListSerialiseCallback fn);
void IwManagedListSetSerialiseCallbackPost(IwManagedListSerialiseCallback fn);
IwManagedListSerialiseCallback IwManagedListGetSerialiseCallbackPre();
IwManagedListSerialiseCallback IwManagedListGetSerialiseCallbackPost();
# 68 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
class CIwManagedList
{
private:
    inline void _CheckAdd(CIwManaged* pObj, bool allowDups) const
    {
# 88 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    }
    inline void _CheckGet(uint32 hash, bool allowDups) const
    {
# 108 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    }

public:



    CIwManagedList() {}
    ~CIwManagedList() {}
# 128 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    void Serialise();
# 137 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    void Resolve();
# 146 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    void SerialisePtrs();





    inline void OptimizeCapacity() {m_List.optimise_capacity();}
# 161 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    void ResolvePtrs(const CIwManagedList& list);
# 172 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline void SerialiseHeader() {m_List.SerialiseHeader();}





    void Delete();







    inline void Clear() {m_List.clear();}







    inline void ClearAndFree() {m_List.clear_optimised();}
# 207 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    CIwManaged* GetObjNamed(const char* pName, bool allowDups = false) const;
# 223 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    CIwManaged* GetObjHashed(uint32 hash, bool allowDups = false) const;
# 239 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    CIwManaged::ArrayIt GetObjHashedNextIt(uint32 hash, CIwManaged::ArrayIt start = __null, bool allowDups = false) const;
# 251 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    void Add(CIwManaged* pObject, bool allowDups = false);
# 265 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline void Insert(CIwManaged* pObject, uint32 pos, bool allowDups = false)
    {
        _CheckAdd(pObject, allowDups);
        m_List.insert_slow(pObject, pos);
    }
# 279 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline bool RemoveSlow(CIwManaged* pObject) {return m_List.find_and_remove(pObject); }
# 289 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline bool RemoveFast(CIwManaged* pObject) {return m_List.find_and_remove_fast(pObject); }
# 299 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged** Erase(CIwManaged** it) {return m_List.erase(it);}
# 309 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline uint32 EraseFast(uint32 i) {return m_List.erase_fast(i);}
# 318 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline bool Contains(CIwManaged* pObject) const
    {
        return m_List.contains(pObject);
    }
# 331 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    int32 Find(CIwManaged* const& pObject) const
    {
        return m_List.find(pObject);
    }
# 343 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    void CopyList(const CIwManagedList& list);







    inline uint32 GetSize() const {return (uint32)m_List.size();}







    inline uint32 GetCapacity() const {return (uint32)m_List.capacity();}
# 370 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline void Push(CIwManaged* pObject, bool allowDups = false)
    {
        _CheckAdd(pObject, allowDups);
        m_List.push_back(pObject);
    }
# 383 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged* Pop() {return m_List.pop_back_get();}
# 392 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged* GetTop() {return m_List.back();}







    CIwManaged* & operator [] (int const i) const
    {
        uint32 index = (uint32)i;
        return m_List[index];
    }
# 413 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged** GetBegin() const {return m_List.begin();}
# 423 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline CIwManaged** GetEnd() const {return m_List.end();}
# 433 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline void Reserve(uint32 i) {m_List.reserve_optimised(i);}
# 442 "d:/marmalade/6.1/modules/iwutil/h/IwManagedList.h"
    inline void LockSize(bool lock) { m_List.LockSize(lock); }




    inline void _AddHashAsPointer(uint32 hash) {m_List.push_back((CIwManaged*)(intptr_t)hash);}
private:
    CIwManaged::Array m_List;
};


void IwResolveManagedHash(void* pptr, const CIwManagedList& list);







class CIwMenuItemManagedList : public CIwMenuItem
{
public:
    CIwMenuItemManagedList(const char* pString, CIwManagedList* pList) : CIwMenuItem("", pString, 0, CIwMenuItem::FIELD)
    {
        m_List = pList;
    }
    void Select();
    CIwManagedList* m_List;
};
# 28 "d:/marmalade/6.1/modules/iwutil/h/IwEvent.h" 2



enum IW_EVENT_TABLE_GLOBAL
{
    IW_EVENT_NULL = 0,


    IW_EVENT_GX = 0x0100,
    IW_EVENT_ENGINE = 0x0200,
    IW_EVENT_ANIM = 0x0300,
    IW_EVENT_GUI = 0x0400,




    IW_EVENT_USER = 0x8000,


    IW_EVENT_ALLOCATION_MASK = 0xFF00,
};







class CIwEvent : public CIwManaged
{
public:

    uint32 GetID() const { return m_Hash; }
    CIwManaged* GetSender() const { return m_Sender; }


    bool Send(CIwManaged *pTarget, CIwManaged *pSender);


    void Post(CIwManaged *pTarget, CIwManaged *pSender);

protected:
    CIwManaged* m_Sender;

    CIwEvent() : m_Sender(__null) { m_Hash = IW_EVENT_NULL; }
};





class CIwEventBroadcast : public CIwEvent
{
public:


    using CIwEvent::Send;


    bool Send(CIwManaged *pSender);


    void Post(CIwManaged *pSender);

protected:




    static void AddHandler(CIwManaged* pHandler, CIwManagedList **ppHList);
    static void RemoveHandler(CIwManaged* pHandler, CIwManagedList **ppHList);
    static void ReserveHandlers(CIwManagedList **ppHList, int size);
    virtual CIwManagedList *GetHandlers() = 0;
};






void IwEventInit();


void IwEventSetListStorage(uint16 eventQueueSize, uint16 handlerListSize);


void IwEventTerminate();


void IwEventDeliverPosted();


void IwEventClearAllHandlers();
# 20 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h" 1
       
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
struct s3eFile;
# 30 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
s3eResult IwFileCopy(const char* dest, const char* src);
# 41 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
s3eResult IwFileMakeDirs(const char* path);
# 52 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
s3eResult IwFileRmTree(const char* path);
# 65 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
s3eFile* IwFileOpenPrefixed(const char* filename, const char* mode);
# 75 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
bool IwFileGetPathPrefixed(const char* filename, const char* mode, char* out);







bool IwFileCheckExists(const char* filename);
# 93 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
void IwFileReadSetPathGlobals(const char** pGlobals);
# 103 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
void IwFileReadSetPathPrefixes(const char** pPrefixes);






void IwFileWriteSetPathPrefix(const char* pPrefix);
# 124 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
int64 IwFileGetDirSize(const char* path, bool bDoRecursive);
# 133 "d:/marmalade/6.1/modules/iwutil/h/IwFile.h"
int32 IwFileSubCopy(s3eFile* pSrc, s3eFile* pDst, int32 size);
# 21 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h" 1
       
# 22 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
class CIwImage;
class CIwMemBucket;
class CIwTexture;
struct PNGChunk;
struct PNGHeader;
struct CIwGxCompressedTextureBlock;


extern uint64 g_ColourReductionThreshold;
extern int g_ColourReductionDump;
extern int g_DoColourReduction;
# 85 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
class CIwImage
{
public:

    typedef enum FormatDataFlags
    {

        PALETTISED_4BIT_F = (1 << 0),
        PALETTISED_5BIT_F = (1 << 1),
        PALETTISED_6BIT_F = (1 << 2),
        PALETTISED_7BIT_F = (1 << 3),
        PALETTISED_8BIT_F = (1 << 4),
        PALETTISED_MASK = PALETTISED_4BIT_F | PALETTISED_5BIT_F | PALETTISED_6BIT_F | PALETTISED_7BIT_F | PALETTISED_8BIT_F,

        ALPHA_F = (1 << 5),
        REVERSE_F = (1 << 6),

        SIZE_8_F = (1 << 7),
        SIZE_16_F = (2 << 7),
        SIZE_24_F = (3 << 7),
        SIZE_32_F = (4 << 7),
        SIZE_MASK = (0x7 << 7),

        ALPHA_FLIP_F = (1 << 10),

        NON_PALETTE_ALPHA_F = (1 << 11),

    } FormatDataFlags;


    struct FormatData
    {
        uint16 m_Flags;
        uint8 m_NumBitsR;
        uint8 m_NumBitsG;
        uint8 m_NumBitsB;
        uint8 m_NumBitsA;

        int32 GetByteDepth() const { return (m_Flags & SIZE_MASK) >> 7; }
    };






    enum Format
    {
        FORMAT_UNDEFINED,

        RGB_332,
        BGR_332,


        RGB_565,
        BGR_565,


        RGBA_4444,
        ABGR_4444,
        RGBA_5551,
        ABGR_1555,


        RGB_888,
        BGR_888,


        RGBA_6666,
        ABGR_6666,


        RGBA_8888,
        ABGR_8888,
        RGBA_AAA2,
        ABGR_2AAA,


        PALETTE4_RGB_888,
        PALETTE4_RGBA_8888,
        PALETTE4_RGB_565,
        PALETTE4_RGBA_4444,
        PALETTE4_RGBA_5551,
        PALETTE4_ABGR_1555,

        PALETTE8_RGB_888,
        PALETTE8_RGBA_8888,
        PALETTE8_RGB_565,
        PALETTE8_RGBA_4444,
        PALETTE8_RGBA_5551,
        PALETTE8_ABGR_1555,

        PALETTE7_ABGR_1555,
        PALETTE6_ABGR_1555,
        PALETTE5_ABGR_1555,


        PVRTC_2,
        PVRTC_4,
        ATITC,
        COMPRESSED,

        PALETTE4_ABGR_4444,
        PALETTE8_ABGR_4444,

        A_8,

        ETC,
        ARGB_8888,

        PALETTE4_ARGB_8888,
        PALETTE8_ARGB_8888,

        DXT3,

        PALETTE4_BGR555,
        PALETTE8_BGR555,
        A5_PALETTE3_BGR_555,
        A3_PALETTE5_BGR_555,

        PALETTE4_BGR_565,
        PALETTE4_ABGR_8888,
        PALETTE8_BGR_565,
        PALETTE8_ABGR_8888,

        DXT1,
        DXT5,

        FORMAT_MAX,
    };


    enum ImageFlags
    {
        OWNS_TEXELS_F = (1 << 0),
        OWNS_PALETTE_F = (1 << 1),
        SERIALISE_NO_TEXELS_F = (1 << 2),
        USE_FIXED_BUFFER_F = (1 << 11),
        HAS_ALPHA_FROM_SOURCE_F = (1 << 12),
        NO_CONVERT_MAGENTA_F = (1 <<13),
        PAL_ZERO_IS_ALPHA_ZERO_F = (1 << 14),


        NON_PERSISTENT_FLAGS_MASK = OWNS_TEXELS_F | OWNS_PALETTE_F | USE_FIXED_BUFFER_F

    } ImageFlags;





    CIwImage();





    CIwImage(const CIwImage& img);




    ~CIwImage();

    void operator=(CIwImage const &pImg);
# 258 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void Serialise();

    void SerialisePaletteOnly();
# 269 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 GetBitDepth() const { return GetBitDepth(m_Format); }
# 279 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    static uint32 GetBitDepth(const Format &format);
# 288 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 GetByteDepth() const { return GetByteDepth(m_Format); }
# 298 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    static uint32 GetByteDepth(const Format &format) { return GetBitDepth(format) >> 3;}
# 307 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 GetTexelBitDepth() const { return GetTexelBitDepth(m_Format); }
# 317 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    static uint32 GetTexelBitDepth(const Format &format);
# 326 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 GetPaletteSize() const { return GetPaletteSize(m_Format); }
# 336 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    static uint32 GetPaletteSize(const Format &format);
# 346 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    inline uint32 GetTexelsMemSize() const
    {
        if (!IsCompressedFormat(GetFormat()))
        {
            return m_Pitch * m_Height;
        }

        return m_CompressedImageSize;
    }
# 363 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 GetPaletteMemSize() const { return GetPaletteMemSize(m_Format); }
# 373 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    static uint32 GetPaletteMemSize(const Format &format);
# 382 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void SetFormat(Format format);
# 391 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    inline Format GetFormat() const {return m_Format;}







    inline FormatData GetFormatData() const {return s_FormatData[m_Format];};






    inline uint16 GetFlags() const {return m_Flags;}






    void SetWidth(uint32 width);







    inline uint32 GetWidth() const {return m_Width;}
# 430 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    inline uint32 GetByteWidth() const
    {
        uint32 texBitDepth = GetTexelBitDepth();
        uint32 byteWidth = (m_Width * texBitDepth + 7)/8;

        ((void)0);

        return byteWidth;
    }







    void SetHeight(uint32 height);







    inline uint32 GetHeight() const {return m_Height;}






    void SetPitch(uint32 pitch);







    inline uint32 GetPitch() const {return m_Pitch;}







    inline uint8* GetTexels() const {return m_Texels;}







    inline uint8* GetPalette() const {return m_Palette;}
# 495 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 FormatColour(uint8 red, uint8 green, uint8 blue, uint8 alpha = 0xff);
# 505 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void SetOwnedBuffers(uint8* pTexels, uint8* pPalette);







    inline uint8 HasAlpha() const {return (s_FormatData[m_Format].m_Flags & ALPHA_F) != 0;}







    bool UsesAlpha(uint8 threshold = 0xff) const;
# 530 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    bool UsesChromakey() const;
# 539 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    bool TestForChromakey() const;
# 549 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void ReadFile(s3eFile* pFile);
# 562 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void ReadFile(s3eFile* pFile, uint8* pTexels, uint32 texelsSize, uint8* pPalette, uint32 palSize);
# 573 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void LoadFromFile(const char* imageFile);
# 588 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void ConvertToImage(CIwImage* pImage, bool chooseDepth = false);
# 607 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void ConvertToImage(CIwImage* pImage, uint8* pTexels, uint32 texelsSize, uint8* pPalette, uint32 palSize, bool chooseDepth);
# 616 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void ReplacePalette(uint8* pPalette);
# 635 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 ReplaceColour(uint8 srcR, uint8 srcG, uint8 srcB, uint8 srcA,
        uint8 dstR, uint8 dstG, uint8 dstB, uint8 dstA);




    uint32 ReplaceAlpha(uint8 threshold, uint8 chromaR, uint8 chromaG, uint8 chromaB);





    uint32 ReplaceAlphaColourWithSurrounding(uint8 threshold=0x80, uint8 numSurrounding=0x2);
# 662 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    uint32 MakeAlphaPalZero(uint8 threshold, uint8 keyR, uint8 keyG, uint8 keyB);







    void SetCompressed(CIwGxCompressedTextureBlock* pBlock);
# 735 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    static void FixedBufferSetSize(uint32 size);






    static void FixedBufferFree();






    static void FixedBufferCheckOverflow();
# 758 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    inline static bool FixedBufferAvailable()
    {
        return s_FixedBucket != __null;
    }






    inline void UseFixedBuffer(bool use)
    {
        if (use == true)
            m_Flags |= USE_FIXED_BUFFER_F;
        else
            m_Flags &= ~USE_FIXED_BUFFER_F;
    }



    static bool IsCompressedFormat(Format format)
    {
        return ( ((format >= PVRTC_2) && (format <= COMPRESSED))
            || ( format == ETC ) || ( format == DXT1 ) || ( format == DXT3 ) || ( format == DXT5 ) );
    }
# 800 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void SetBuffers(uint8* pTexels = __null, uint32 texelLen = 0, uint8* pPalette = __null, uint32 palSize = 0);







    void ReadPalette(uint8* pPaletteSrc);







    void ReadTexels(uint8* pTexelsSrc);





    int CountColours();
# 831 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void SaveBmp(const char* filename);
# 840 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void SaveTga(const char* filename);







    void SavePng(const char* filename);







    void SaveJpg(const char* filename, uint32 quality = 100);
# 866 "d:/marmalade/6.1/modules/iwutil/h/IwImage.h"
    void MakeOwner(uint32 flags);






    void SetOwn(CIwImage* pImg);


    void SetNoOwn(CIwImage* pImg);

private:

    void ReadData(uint32 pitch, uint8* pTexelsSrc, uint8* pPalette);


    void UpdateInfo(CIwImage* pImg);


    inline void SetFlags(uint16 flags) {m_Flags = flags;}


    void FreeData();

    void ConvertToPalettisedImage(CIwImage* pImage, bool useExistingPalette = false);
    void do_neuquant( CIwImage* destImage);
    bool ConvertToPalettisedImageSimple(CIwImage* pImage);
    void ConvertDataToFormat(uint8* pSrcBuffer, uint8* pDstBuffer, CIwImage* pImage, uint32 height, uint32 width);
    void ConvertIndexedDataToFormat(uint8* pPalette, uint8* pIndexData, uint8* pDstBuffer, CIwImage* pImage);
    void ConvertPixelToFormat(uint8* pSrc, uint8* pDst, const FormatData* pSrcFormat, const FormatData* pDstFormat);
    void DecodePixelRGBAFromFormat(uint8* pSrc, uint16* r, uint16* g, uint16* b, uint16* a, const FormatData* srcFormat) const;
    void EncodePixelRGBAToFormat(uint8* pDst, uint16 r, uint16 g, uint16 b, uint16 a, const FormatData* srcFormat, const FormatData* dstFormat) const;
    int ColourLookup(uint32 colour, uint8* pPalette, CIwImage* pImage, int32 paletteSize = -1) const;
    int ColourLookupNearest(uint8* colour, uint8* pPalette, CIwImage* pImage);

    void SetDefaultPitch();


    uint8* IwImageMakePow2(uint32 *outWidth, uint32 *outHeight,
                           uint32 minWidth = 1, uint32 minHeight = 1,
                           uint32 maxWidth = (uint32)-1, uint32 maxHeight = (uint32)-1);


    uint8* IwImageMakePow2Square(uint32 *outWidth, uint32 *outHeight, uint32 minWidth = 1, uint32 minHeight = 1);

    inline uint32 MapColourToResolution(uint32 bitDepthIn, uint32 bitDepthOut, uint16 col)
    {
        uint32 resIn = (1<<bitDepthIn)-1;
        uint32 resOut = (1<<bitDepthOut)-1;

        uint32 oldVal = (uint32)col;

        if(resIn == 0)
            return oldVal;

        return (resOut - (resOut*((resIn) - oldVal)/(resIn)));

    }

    inline uint32 ReformatColourComponent(uint32 bitDepthIn, uint32 bitDepthOut, uint16 col) const
    {
        uint32 mid = ((1<<bitDepthOut)-1)>>1;

        if(bitDepthOut<bitDepthIn)
        {

            uint16 rounded_col = col | (0x1<<(bitDepthIn-bitDepthOut-1));

            return rounded_col>>(bitDepthIn-bitDepthOut);
        }

        uint32 outCol = col<<(bitDepthOut-bitDepthIn);



        if(bitDepthIn && outCol >= mid)
        {
            outCol |= (1<<(bitDepthOut-bitDepthIn))-1;

        }

        return outCol;
    }

    inline void AssignRGB(uint8* pDst, uint8* pSrc, uint8 reverse)
    {
        pDst[0] = pSrc[reverse ? 2:0];
        pDst[1] = pSrc[1];
        pDst[2] = pSrc[reverse ? 0:2];

    }

    inline void AssignRGBA(uint8* pDst, uint8* pSrc, uint8 reverse)
    {
        pDst[0] = pSrc[reverse ? 3:0];
        pDst[1] = pSrc[reverse ? 2:1];
        pDst[2] = pSrc[reverse ? 1:2];
        pDst[3] = pSrc[reverse ? 0:3];
    }

    inline void AssignARGB(uint8* pDst, uint8* pSrc, uint8 reverse)
    {
        pDst[0] = pSrc[reverse ? 2:3];
        pDst[1] = pSrc[reverse ? 1:0];
        pDst[2] = pSrc[reverse ? 0:1];
        pDst[3] = pSrc[reverse ? 3:2];
    }

    void DecodeGIF(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeTGA(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodePNG(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeRAW(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeRP4(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void DecodeJPG(void* pSrc, uint32 srcLen, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);


    void DecodePVR(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);

    void DecodeATI(void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);

    uint32 ByteRead32(uint8* pSrc, int32 length) const;

    void ByteWrite32(uint32 val, uint8* pDst, int32 length) const;






    void IwImageReplicateColumns(uint32 outWidth, uint8 *outImage);






    void IwImageReplicateRows(uint32 outWidth, uint32 outHeight, uint8 *outImage);





    void ReduceImagePalette8( CIwImage* pImage, bool chooseDepth );





    void ResizeToImage(CIwImage* pImage);



    bool CanMipMapImage() const;
    uint32 CalculateMipMapLevels() const;
    uint32 CalculateMipMapBufferSize(uint32 level) const;
    void CalculateMipMapDimensions(uint32* width, uint32* height, uint32 level) const;
    bool CreateMipMip(CIwImage* pImage, uint32 level, uint8* pTexels, uint32 texelLen,
        bool doChromaKeyTransparency) const;
    inline void ReadAndAccumulateSample(uint16* pR, uint16* pG, uint16* pB, uint16* pA,
        uint8* pSrc, uint32 stepX, uint32 stepY, uint32 numX, uint32 numY,
        bool doChromaKeyTransparency) const;

protected:


    static void ConvertTexelsBetweenFormats ( void* pSrcTexels, void* pDstTexels, Format srcFormat, Format dstFormat, uint32 width, uint32 height);
    static void ConvertPaletteBetweenFormats( void* pSrcPalette, void* pDstPalette,Format srcFormat, Format dstFormat);

private:
    uint16 m_Flags;
    Format m_Format;
    uint8 pad0;
    uint16 pad1;
    uint16 m_Width;
    uint16 m_Height;
    uint16 m_Pitch;
    uint8* m_Texels;
    uint8* m_Palette;
    uint32 m_CompressedImageSize;

    static const FormatData s_FormatData[];
    static CIwMemBucket* s_FixedBucket;
    static uint8* s_FixedBucketControlled;
    static uint32 s_FixedBufferSize;
    friend class CIwTexture;





    uint8* Alloc(uint32 size);

public:
    static const char* g_FormatNames[];

    friend class CIwGxMipMapBuilder;
    friend void CopyTGATexel(CIwImage* image, uint8* dest, uint8* src);
    friend void DecodeIHDRChunk(void* pSrc, PNGHeader* pHeader, CIwImage* pImg,uint8* pTexels, uint32 texelsLen,uint8* pPalette, uint32 palLen);
    friend void DecodePLTEChunk(void* pSrc, PNGChunk* pChunk, CIwImage* pImg);
    friend void FinishIDATDecode(PNGHeader* pHeader, CIwImage* pImg);
    friend void DecodetRNSChunk(void* pSrc, PNGHeader* pHeader, PNGChunk* pChunk, CIwImage* pImg);
    friend void SelectImageFormat(PNGHeader* pHeader, uint8 alpha, CIwImage* pImg);
    void _DecodeBMP(void* pHdr, void* pSrc, uint8* pTexels, uint32 texelsLen, uint8* pPalette, uint32 palSize);
    void _SetMagentaConversion(bool on) {on?m_Flags &= ~NO_CONVERT_MAGENTA_F:m_Flags |= NO_CONVERT_MAGENTA_F; };




};


enum CompressedBlockVersion
{
    IW_GX_COMP_OLD_DATA = 0,
    IW_GX_COMP_VERS_1 = 1,
    IW_GX_COMP_VERS_2 = 2,
};

struct CIwGxCompressedTextureBlock
{

    enum { MAX_MIPMAPS_LEVELS = 12 };

    static CIwGxCompressedTextureBlock* Create(CIwImage::Format fmt,
        uint32 uploadFormat,
        uint32 width,
        uint32 height,
        uint32 numLevels,
        uint8** levels,
        uint32 *sizes);

    uint16 m_ImageFormat;
    uint16 m_Version;
    uint32 m_BlockSize;
    uint32 m_OpenGLFormat;
    uint32 m_NumMipmaps;
    uint32 m_TextureWidth;
    uint32 m_TextureHeight;
    uint32 m_CompressedTextureSizes[MAX_MIPMAPS_LEVELS];
};
# 23 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h" 1
       
# 21 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucket;

typedef int32 IwMemBlockIterator(CIwMemBucket* bucket, void* item, void* user);
# 43 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucket
{
protected:
    CIwMemBucket();

public:
    virtual ~CIwMemBucket();






    void SetName(const char* name);






    inline const char* GetName() {return m_Name;}


    inline const char* DebugGetName() {return GetName();}




    const char* m_Name;
# 80 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void Free(void* item) = 0;
# 90 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void* Realloc(void* item, int32 size) = 0;
# 99 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 Owns(void* item) = 0;






    virtual int32 DebugTestIntegrity() {return 0;}
# 119 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetSize(void* item) {return -1;}
# 131 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetMemUsage(void* item) {return -1;}
# 142 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetFree() {return -1;}







    virtual int32 GetUsed() {return -1;}
# 160 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetLargestFreeBlock() {return -1;}
# 170 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetFragmentation() {return -1;}
# 180 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 GetTotalSize(){return -1;}
# 192 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual int32 IterateBlocks(IwMemBlockIterator* fn, void* user) {return -1;}
};
# 203 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucketDebuggerInterface
{
protected:
    CIwMemBucketDebuggerInterface() : m_NextDebugger(0)
    {}

public:
    virtual ~CIwMemBucketDebuggerInterface() {}
# 219 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void PreFree(CIwMemBucket* bucket, void* item){};
# 228 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void PostFree(CIwMemBucket* bucket, void* item) {};
# 238 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void PreRealloc(CIwMemBucket* bucket, void* old_item, int32 new_size) {};
# 247 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void PostRealloc(CIwMemBucket* oldBucket, void* old_item, CIwMemBucket* newBucket, void* new_item, int32 new_size) {};
# 257 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void DebugSetName(CIwMemBucket* bucket, void* item, const char* name) {};
# 267 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual void AllocationFailure(CIwMemBucket* bucket, void* item, int32 size_requested) {};

    CIwMemBucketDebuggerInterface* m_NextDebugger;
};
# 280 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
class CIwMemBucketSelector
{
    CIwMemBucketDebuggerInterface* m_FirstDebugger;

protected:
    CIwMemBucketSelector() : m_FirstDebugger(0) {}

public:
    virtual ~CIwMemBucketSelector() {}
# 299 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual CIwMemBucket* FindBucket(void* item) = 0;
# 309 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual CIwMemBucket* SelectBucket(int32 size) = 0;
# 322 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    virtual CIwMemBucket* SelectRebucket(CIwMemBucket* oldBucket, void* item, int32 newSize) = 0;







    void AddDebugger(CIwMemBucketDebuggerInterface* p);







    void RemoveDebugger(CIwMemBucketDebuggerInterface* p);

    CIwMemBucketDebuggerInterface* GetFirstDebugger() { return m_FirstDebugger; }

private:
    CIwMemBucket* _SysFindBucket(void* item);
    CIwMemBucket* _SysSelectBucket(int32 size);
    CIwMemBucket* _SysSelectRebucket(CIwMemBucket* oldBucket, void* item, int32 newSize);
    friend void* IwMallocNamed(int32, const char*);
    friend void IwMallocRename(void*, const char*);
    friend void* IwRealloc2(void*, int);
    friend void IwFree2(void*);
};







void IwMemBucketSetSelector(CIwMemBucketSelector* s);
# 367 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
CIwMemBucketSelector* IwMemBucketGetSelector();
# 377 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
CIwMemBucket* IwMemBucketSetOverride(CIwMemBucket* s);
# 442 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
void* IwMalloc2(int size);
# 452 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    void* IwRealloc2(void* item, int new_size);






void IwFree2(void* item);
# 478 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    void* IwMallocBucket(CIwMemBucket* bucket, int32 new_size);
# 489 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    void* IwReallocBucket(CIwMemBucket* bucket, void* item, int32 new_size);
# 502 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    void* IwReallocBucketChange(CIwMemBucket* bucket, void* item, CIwMemBucket* newBucket, int32 new_size);
# 511 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
    void IwFreeBucket(CIwMemBucket* bucket, void* item);
# 523 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
void IwMemBucketDebugAdd(CIwMemBucketDebuggerInterface* debug);
# 533 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
void IwMemBucketDebugRemove(CIwMemBucketDebuggerInterface* debug);







class CIwMemBucketSystem : public CIwMemBucket
{
public:
    CIwMemBucketSystem();
    virtual ~CIwMemBucketSystem() {}

    virtual void Free(void* item);
    virtual void* Realloc(void* item, int32 size);
    virtual int32 Owns(void* item);
    virtual int32 GetFree();
    virtual int32 GetUsed();
    virtual int32 GetLargestFreeBlock();
    virtual int32 GetTotalSize();
};


void IwMemBucketInit();
void IwMemBucketTerminate();
# 584 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
inline void * operator new(size_t size, const char* name, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
# 597 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
inline void operator delete(void* item, const char* name, CIwMemBucket* bucket)
{
    s3eFree(item);
}

inline void * operator new [] (size_t size, const char* name, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
inline void operator delete [] (void* item, const char* name, CIwMemBucket* bucket)
{
    s3eFree(item);
}
inline void * operator new(size_t size, const char* name, CIwMemBucket& bucket)
{
    return IwMallocBucket(&bucket, size);
}
inline void operator delete(void* item, const char* name, CIwMemBucket& bucket)
{
    s3eFree(item);
}
inline void * operator new(size_t size, CIwMemBucket& bucket)
{
    return IwMallocBucket(&bucket, size);
}
inline void operator delete(void* item, CIwMemBucket& bucket)
{
    IwFreeBucket(&bucket, item);
}
inline void * operator new [] (size_t size, CIwMemBucket& bucket)
{
    return IwMallocBucket(&bucket, size);
}
inline void operator delete [] (void* item, CIwMemBucket& bucket)
{
    IwFreeBucket(&bucket, item);
}
inline void * operator new(size_t size, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
inline void operator delete(void* item, CIwMemBucket* bucket)
{
    IwFreeBucket(bucket, item);
}
inline void * operator new [] (size_t size, CIwMemBucket* bucket)
{
    return IwMallocBucket(bucket, size);
}
inline void operator delete [] (void* item, CIwMemBucket* bucket)
{
    IwFreeBucket(bucket, item);
}
# 667 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucket.h"
extern CIwMemBucketSystem* g_SystemBucket;
# 25 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h" 1
       
# 17 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
# 1 "d:/marmalade/6.1/s3e/h/s3eKeyboard.h" 1
# 18 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h" 2
# 47 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
void IwKeymapMapKey(uint32 gameKey, s3eKey sysKey);
# 56 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
int32 IwKeymapGetKey(s3eKey sysKey);
# 65 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
s3eKey IwKeymapGetSystemKey(uint32 gameKey);
# 76 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
int32 IwKeymapGetState(uint32 gameKey);





s3eBool IwKeymapCanBind(s3eKey key);
# 97 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
typedef enum
{
        IwGameKeyFirst,


        IwKeyPSX_Start ,
        IwKeyPSX_Select ,
        IwKeyPSX_Left ,
        IwKeyPSX_Up ,
        IwKeyPSX_Right ,
        IwKeyPSX_Down ,
        IwKeyPSX_Triangle ,
        IwKeyPSX_Circle ,
        IwKeyPSX_Cross ,
        IwKeyPSX_Square ,
        IwKeyPSX_Left_Shoulder ,
        IwKeyPSX_Right_Shoulder ,
        IwKeyPSX_Left_Shoulder2 ,
        IwKeyPSX_Right_Shoulder2 ,
        IwKeyPSX_Escape ,


        IwKeyGameSpecific_0 ,
        IwKeyGameSpecific_1 ,
        IwKeyGameSpecific_2 ,
        IwKeyGameSpecific_3 ,
        IwKeyGameSpecific_4 ,
        IwKeyGameSpecific_5 ,
        IwKeyGameSpecific_6 ,
        IwKeyGameSpecific_7 ,
        IwKeyGameSpecific_8 ,
        IwKeyGameSpecific_9 ,
        IwKeyGameSpecific_10 ,
        IwKeyGameSpecific_11 ,
        IwKeyGameSpecific_12 ,
        IwKeyGameSpecific_13 ,
        IwKeyGameSpecific_14 ,
        IwKeyGameSpecific_15 ,
        IwKeyGameSpecific_16 ,
        IwKeyGameSpecific_17 ,
        IwKeyGameSpecific_18 ,
        IwKeyGameSpecific_19 ,
        IwKeyGameSpecific_20 ,
        IwKeyGameSpecific_21 ,
        IwKeyGameSpecific_22 ,
        IwKeyGameSpecific_23 ,
        IwKeyGameSpecific_24 ,
        IwKeyGameSpecific_25 ,
        IwKeyGameSpecific_26 ,
        IwKeyGameSpecific_27 ,
        IwKeyGameSpecific_28 ,
        IwKeyGameSpecific_29 ,
        IwKeyGameSpecific_30 ,
        IwKeyGameSpecific_31 ,

} IwGameKey;


extern "C" {
# 166 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
s3eKey IwKeymapGetSegKey(IwGameKey gameKey);
# 176 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
IwGameKey IwKeymapGetGameKey(s3eKey mapKey);
# 185 "d:/marmalade/6.1/modules/iwutil/h/IwKeymap.h"
int32 IwKeymapGetGameKeyState(IwGameKey gameKey);







void IwKeymapClearGameKeyState(IwGameKey gameKey);







void IwKeymapEnable();







void IwKeymapDisable();


}
# 27 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h" 1
       
# 20 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwMemManagerDL.h" 1
# 40 "d:/marmalade/6.1/modules/iwutil/h/IwMemManagerDL.h"
struct DL_Malloc_Info {
  int arena;
  int ordblks;
  int smblks;
  int hblks;
  int hblkhd;
  int usmblks;
  int fsmblks;
  int uordblks;
  int fordblks;
  int keepcost;
  int maxblock;
  int freeattop;
};

struct malloc_state;


extern "C" {


void* DL_Malloc_malloc(struct malloc_state * av, uint32 bytes);



void DL_Malloc_free(struct malloc_state * av, void* mem);

void* DL_Malloc_realloc(struct malloc_state * av, void* oldmem, uint32 bytes);
struct DL_Malloc_Info DL_Malloc_mallinfo(struct malloc_state * av);
void DL_Malloc_malloc_consolidate(struct malloc_state * av);
void DL_Malloc_setnoncontiguous(struct malloc_state * av);


int DL_Malloc_GetSize(void* p);
# 85 "d:/marmalade/6.1/modules/iwutil/h/IwMemManagerDL.h"
}

class DL_Malloc
{
    char av_[888];
    malloc_state* m_State;

    typedef unsigned int uint32;
    typedef unsigned int INTERNAL_SIZE_T;

    void* sYSMALLOc(INTERNAL_SIZE_T nb);
    void malloc_consolidate();
    void** iALLOc(uint32 n_elements, uint32* sizes, int opts, void* chunks[]);

public:
    friend void *DL_Malloc_MORECORE (malloc_state * av, long size);

    DL_Malloc_Info mallinfo() { return DL_Malloc_mallinfo(m_State); }

    char * dl_malloc_buffer;
    int dl_malloc_buffer_pos;
    int dl_malloc_buffer_len;







    DL_Malloc(void * a, int l)
    {
        Init(a, l);
    }

    void Init(void* a, int l)
    {
        memset(av_, 0, 888);
        m_State = (malloc_state*)(void*)av_;
        dl_malloc_buffer_pos = 0;
        dl_malloc_buffer_len = l&~7;
        dl_malloc_buffer = (char*)a;






        Free(Alloc((dl_malloc_buffer_len)-16-4));
    }
# 197 "d:/marmalade/6.1/modules/iwutil/h/IwMemManagerDL.h"
    void* Finish() {

        void* p = dl_malloc_buffer;

        dl_malloc_buffer_pos = 0;
        dl_malloc_buffer_len = 0;
        dl_malloc_buffer = 0;

        return p;
    }
# 215 "d:/marmalade/6.1/modules/iwutil/h/IwMemManagerDL.h"
    void Free(void * data)
    {
        DL_Malloc_free(m_State, data);
    }
    void* Realloc(void * data, int bytes)
    {
        return DL_Malloc_realloc(m_State, data,bytes);
    }
    void* Alloc(int bytes)
    {
        return DL_Malloc_malloc(m_State, bytes);
    }

    bool Owned(void * data)
    {
# 242 "d:/marmalade/6.1/modules/iwutil/h/IwMemManagerDL.h"
        if(data<dl_malloc_buffer || data>=dl_malloc_buffer+dl_malloc_buffer_len)
            return false;
        return true;
    }

    int GetFree()
    {
        return dl_malloc_buffer_len - mallinfo().uordblks;
    }

    int GetLFB()
    {
        DL_Malloc_malloc_consolidate(m_State);
        DL_Malloc_Info m(mallinfo());
        return m.maxblock;
    }

    int GetSize()
    {
        return dl_malloc_buffer_len;
    }

    bool IsEmpty()
    {
        if (dl_malloc_buffer)
            return (mallinfo().uordblks <= 4);
        else
            return true;
    }
};
# 21 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h" 2
# 44 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
int32 BlockIteratorMeasureInt(CIwMemBucket* bucket, void* item, void* user);




class CIwMemBucketBuffer : public CIwMemBucket
{
protected:
    uint32* mem32;
    uint32 size32;

public:






    CIwMemBucketBuffer(void* mem, int32 size, const char* _name)
    {
        ((void)0);

        intptr_t begin = (((intptr_t)mem + 3) & ~3);
        intptr_t end = (intptr_t)mem + size;

        mem32 = (uint32*)begin;
        size32 = (end-begin) >> 2;

        SetName(_name);
    }

    virtual ~CIwMemBucketBuffer()
    {}

    virtual int32 GetTotalSize()
    {
        return size32<<2;
    }

    virtual int32 Owns(void* item)
    {
        return (uint32)((uint32*)item - mem32) < size32;
    }
};




class CIwMemBucketDLBuffer : public CIwMemBucketBuffer
{
    DL_Malloc DL_Manager;

public:






    CIwMemBucketDLBuffer(void* mem, int32 size, const char* _name)
        : CIwMemBucketBuffer(mem, size, _name),
            DL_Manager(mem,size)
    {
    }

    virtual ~CIwMemBucketDLBuffer() {}

    virtual int32 GetSize(void* item)
    {
        return 0;
    }

    virtual int32 GetMemUsage(void* item)
    {
        return 0;
    }

    virtual void Free(void* item)
    {
        DL_Manager.Free(item);
    }

    virtual void* Realloc(void* item, int32 size)
    {
        return DL_Manager.Realloc(item, size);
    }

    virtual int32 GetFree();

    virtual int32 GetUsed() ;

    virtual int32 GetLargestFreeBlock();

    virtual int32 Owns(void* item)
    {
        if(item<mem32 || item>=mem32+size32)
            return false;

        return true;
    }
};





class CIwMemBucketFixedSize : public CIwMemBucketBuffer
{
    struct Item
    {
        Item* prev;
        Item* next;
        char _data[1];
    };

    Item* used;
    Item* free;
    int32 componentSize;
    int32 realComponentSize;
    int32 capacity;
    int32 numFree;

    Item* GetItem(int i)
    {
        return (Item*)(((intptr_t)mem32) + realComponentSize*i);
    }

    Item* GetItem(void* item)
    {
        ((void)0);
        return (Item*)((intptr_t)item - sizeof(Item*)*2);
    }

    void Free(Item* item)
    {

        if (used==item)
            used = item->next;
        if (item->prev) item->prev->next = item->next;
        if (item->next) item->next->prev = item->prev;


        numFree++;
        item->prev = 0;
        item->next = free;
        free = item;
        if (item->next) item->next->prev = item;
    }

    void* AllocNew()
    {
        if (!free)
            return 0;

        Item* item = free;


        numFree--;
        free = free->next;
        if (item->next) item->next->prev = 0;



        item->next = used;
        used = item;
        if (item->next) item->next->prev = item;

        return item->_data;
    }

public:
# 223 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
    CIwMemBucketFixedSize(void* mem, int32 size, int32 component_size, const char * _name)
        : CIwMemBucketBuffer(mem, size, _name)
    {

        componentSize = ((component_size+3) & ~3);
        realComponentSize = componentSize + 2*sizeof(Item*);
        capacity = (size32 * sizeof(uint32)) / realComponentSize;


        for (int32 i=0; i<capacity; i++)
        {
            GetItem(i)->prev = (i==0) ? 0 : GetItem(i-1);
            GetItem(i)->next = (i==capacity-1) ? 0 : GetItem(i+1);
        }
        used = 0;
        free = GetItem(0);
        numFree = capacity;
    }

    virtual int32 GetSize(void* item)
    {
        ((void)0);
        return componentSize;
    }

    virtual int32 GetMemUsage(void* item)
    {
        ((void)0);
        return realComponentSize;
    }

    virtual void Free(void* item)
    {

        Free(GetItem(item));
    }

    virtual void* Realloc(void* item, int32 size)
    {
        if (size > componentSize)
        {

            return 0;
        }
        else if (item)
        {

            return item;
        }
        else
        {
            return AllocNew();
        }
    }

    virtual int32 GetFree()
    {
        return numFree * componentSize;
    }

    virtual int32 GetUsed()
    {
        return (capacity - numFree) * componentSize;
    }

    virtual int32 GetLargestFreeBlock()
    {
        return numFree>0 ? componentSize : -1;
    }

    virtual int32 GetFragmentation()
    {
        return 0;
    }

    virtual int32 IterateBlocks(IwMemBlockIterator* fn, void* user)
    {
        for (Item * i = used; i; i=i->next)
        {
            int32 r = fn(this, i, user);
            if (r)
                return r;
        }
        return 0;
    }
};







template <class X, int32 size>
class CIwMemBucketBuiltin : public X
{
    char internal[size - sizeof(X)];

public:






    CIwMemBucketBuiltin(const char* name) : X(internal, sizeof(internal), name)
    {}

    virtual ~CIwMemBucketBuiltin() {}
};






template <int32 size>
class CIwMemBucketBuiltinFixedSize : public CIwMemBucketFixedSize
{
    char internal[size - sizeof(CIwMemBucketFixedSize)];

public:
    CIwMemBucketBuiltinFixedSize(int32 component_size, const char * name) : CIwMemBucketFixedSize(internal, sizeof(internal), component_size, name)
    {}
};
# 361 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
class CIwMemBucketGuarded : public CIwMemBucket
{
    CIwMemBucket* const m_Parent;
    const bool m_OwnsParent;
    int32 m_NumMarked;





    struct Footer
    {
        uint32 magicDefense;
        uint32 blockSize;
    };
    struct Header
    {
        uint32 blockSize;
        Header *prev, *next;
        uint32 magicDefense;

        Footer* GetFooter();
        void Test();
        void Unmark();
        void Mark(int32 size);
    };
    Header* m_FirstHeader;
    friend struct CIwMemBucketGuarded::Header;

    void* ConvertToInternal(void* item);
    void* ConvertToExternal(void* item);
    void* Mark(void* item, int32 size);
    void* Unmark(void* item);
    void* TestExternal(void* item);
    void* TestInternal(void* item);
    void TestAll();
    int32 GetSize(int32 requestSize);

    static int32 IterateWrapFn(CIwMemBucket* bucket, void* item, void* user);

public:







    CIwMemBucketGuarded(CIwMemBucket* _parent, bool ownership);

    ~CIwMemBucketGuarded() ;


    virtual void Free(void* item);
    virtual void* Realloc(void* item, int32 size);
    virtual int32 Owns(void* item) { return m_Parent->Owns(ConvertToInternal(item)); }

    virtual int32 GetSize(void* item) {return m_Parent->GetSize(TestExternal(item));}
    virtual int32 GetMemUsage(void* item) {return m_Parent->GetMemUsage(TestExternal(item));}

    virtual int32 DebugTestIntegrity() {int32 i=m_Parent->DebugTestIntegrity(); TestAll(); return i;}

    virtual int32 GetFree() {return m_Parent->GetFree()-sizeof(Header)-sizeof(Footer);}
    virtual int32 GetUsed() {return m_Parent->GetUsed();}
    virtual int32 GetLargestFreeBlock() {return m_Parent->GetLargestFreeBlock()-sizeof(Header)-sizeof(Footer);}
    virtual int32 GetFragmentation() {return m_Parent->GetFragmentation();}

public:
    virtual int32 IterateBlocks(IwMemBlockIterator* fn, void* user) ;
};






class CIwMemBucketDebugBigAllocationSpotter : public CIwMemBucketDebuggerInterface
{
    int32 m_WarnSize;

public:
    CIwMemBucketDebugBigAllocationSpotter(int32 warnSize) : m_WarnSize(warnSize)
    {
    }

    ~CIwMemBucketDebugBigAllocationSpotter()
    {
    }

    virtual void PreRealloc (CIwMemBucket* bucket, void* old_item, int32 new_size)
    {
        ((void)0);
    }
};





class CIwMemBucketDebugTester : public CIwMemBucketDebuggerInterface
{

    CIwMemBucket* m_Watching[20];

public:

    bool m_TestFree;

    bool m_TestRealloc;

    CIwMemBucketDebugTester() : m_TestFree(true), m_TestRealloc(true)
    {
        for (int32 i=0; i<20; i++)
            m_Watching[i] = 0;
    }
    virtual ~CIwMemBucketDebugTester()
    {}







    void TestAll();
# 494 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
    void Add(CIwMemBucket* i);
# 503 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
    void Remove(CIwMemBucket* i);




    virtual void PreFree (CIwMemBucket* bucket, void* item) { if (m_TestFree) TestAll(); }



    virtual void PreRealloc (CIwMemBucket* bucket, void* old_item, int32 new_size) { if (m_TestRealloc) TestAll(); }
};





class CIwMemBucketDebugWatcher : public CIwMemBucketDebuggerInterface
{
# 530 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
public:



    struct Info
    {
        const char* callstack[0x50];
        char name[20];
        void* item;
        CIwMemBucket* bucket;
        int32 itemSize;







        void Clear();






        void SetName(const char * n);





        void SetCallstack();
    };

private:

    Info mInfo[20000];
    int32 used[20000];
    int32 numInfo;

    Info* AllocInfo(CIwMemBucket* bucket, void* item, const char* name);
    void FindAndFreeInfo(void* item);

public:

    CIwMemBucketDebugWatcher();
    virtual ~CIwMemBucketDebugWatcher() {}
# 586 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
    Info* FindInfo(void* item);
# 595 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
    int32 NumInfo() { return numInfo; }
# 605 "d:/marmalade/6.1/modules/iwutil/h/IwMemBucketHelpers.h"
    Info* GetInfoID(int32 i) { return &mInfo[used[i]]; }



    virtual void PreFree (CIwMemBucket* bucket, void* item);



    virtual void PostFree (CIwMemBucket* bucket, void* item);



    virtual void PreRealloc (CIwMemBucket* bucket, void* old_item, int32 new_size);






    virtual void PostRealloc (CIwMemBucket* oldBucket, void* old_item, CIwMemBucket* newBucket, void* new_item, int32 new_size);



    virtual void SetDebugName (CIwMemBucket* bucket, void* item, const char* name);



    virtual void AllocationFailure (CIwMemBucket* bucket, void* item, int32 size_requested);
};







class CIwMemBucketSystemDebug : public CIwMemBucketDLBuffer
{
public:
    CIwMemBucketSystemDebug(void* mem, int32 size, const char* _name) :
        CIwMemBucketDLBuffer(mem, size, _name) {};
};
# 29 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwProfileMenu.h" 1
       
# 29 "d:/marmalade/6.1/modules/iwutil/h/IwProfileMenu.h"
class CIwProfileMenuItem : public CIwMenuItem
{
public:

    CIwProfileMenuItem(const char* text, uint16 id, CIwMenuItem::ColourID colID);
    ~CIwProfileMenuItem() {};
    virtual void Select();
    virtual void Back();
    virtual void Render(int32 x, int32 y);
    virtual void Plus();
    virtual void Minus();


    uint16 m_Index;

    static const int32 g_CharW;
    static const int32 g_FieldW0;
    static const int32 g_FieldW1;
};
# 59 "d:/marmalade/6.1/modules/iwutil/h/IwProfileMenu.h"
class CIwProfileMenuList : public CIwMenu
{
public:

    CIwProfileMenuList(CIwProfileIterator* pIt);
    void Enter();


    CIwProfileIterator* m_ProfileIt;
};





class CIwProfileMenu
{
public:

    CIwProfileMenu();
    ~CIwProfileMenu();


    static CIwProfileMenu& Get() {return *g_Singleton;}


    CIwMenu* m_Menu;
    CIwProfileIterator* m_ProfileIt;


    static CIwProfileMenu* g_Singleton;

    static uint32 g_ProfilePage;
};
# 31 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwResource.h" 1
       
# 28 "d:/marmalade/6.1/modules/iwutil/h/IwResource.h"
class CIwMenu;
class CIwResTemplate;






class CIwManagedRefCount : public CIwManaged
{
public:
    enum
    {
        RESOLVED_F = (1 << 0),
    };

    typedef CIwArray<CIwManagedRefCount*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;
    inline CIwManagedRefCount()
    {
        m_RefCount = 0;
        m_Flags = 0;
    }
    virtual void DebugAddMenuItems(CIwMenu* pMenu);

    inline void IncCount() {m_RefCount++;}
    inline void DecCount()
    {
        ((void)0);
        --m_RefCount;
    }
    inline bool IsCountZero() const {return m_RefCount == 0;}
    inline void SetResolved() {m_Flags |= RESOLVED_F;}
    inline bool IsResolved() const {return (m_Flags & RESOLVED_F) != 0;}

    const CIwManagedRefCount& operator= (const CIwManagedRefCount &source)
    {
        CIwManaged::operator=(source);
        m_Flags = source.m_Flags;
        return *this;
    }

    virtual void _Replace(CIwManaged* pRHS);

private:
    uint16 m_RefCount;
    uint16 m_Flags;
};






class CIwResource : public CIwManagedRefCount
{
public:
    typedef CIwArray<CIwResource*> Array; typedef Array::iterator ArrayIt; const char* GetClassName() const;;

    CIwResource() {};


    virtual void ApplyScale(int32 scale) {}

    virtual void ApplyScale(float scale) {}

};
# 32 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2


# 1 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h" 1
       
# 20 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwTextParser.h" 1
       
# 54 "d:/marmalade/6.1/modules/iwutil/h/IwTextParser.h"
class CIwTextParser
{
public:
# 70 "d:/marmalade/6.1/modules/iwutil/h/IwTextParser.h"
    virtual void* ParseFile(const char* pPathname, bool allowNonExist = false);







    virtual void* ParseString(const char* pString, const char* pPathname = __null);





    typedef void(*TokenFn)(CIwTextParser* pImp);


    inline bool IsWhitespace(char c) {return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');}


    inline bool IsTerminator(char c) {return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r') || (c == '\0');}


    struct TokenInfo
    {
        const char* m_String;
        TokenFn m_Fn;
    };



    typedef CIwArray<TokenInfo> TokenInfoArray;


    typedef TokenInfoArray::iterator TokenInfoArrayIt;


    struct State
    {
        s3eFile* m_File;
        const char* m_Pathname;
        const char* m_CharStart;
        const char* m_Char;
        int32 m_TokenOfs;
        char m_Token[200];
        void* m_ReturnValue;
        int32 m_Line;
        int32 m_Col;
    };


    typedef CIwArray<State> StateArray;


    typedef StateArray::iterator StateArrayIt;

    CIwTextParser();
    virtual ~CIwTextParser();






    void AddTokenFunction(const char* pString, TokenFn pFn);





    inline void _PushState(const State& state) {m_StateStack.push_back(state);}




    inline void _PopState() {m_StateStack.pop_back();}





    inline State* _GetState()
    {
        ((void)0);
        return m_StateStack.end() - 1;
    }





    inline void SetReturnValue(void* value)
    {
        State* pState = _GetState();
        pState->m_ReturnValue = value;
    }






    inline State* _GetStateNoAssert()
    {
        if (!m_StateStack.size())
            return __null;
        else
            return m_StateStack.end() - 1;
    }





    bool ParseToken();





    char ReadChar(bool checkValid = true);

    void UnreadChar();







    bool MatchStrings(const char* pChar0, const char* pChar1);
# 209 "d:/marmalade/6.1/modules/iwutil/h/IwTextParser.h"
    bool MatchStringsIgnoreCase(const char* pChar0, const char* pChar1);




    void SkipBackToken();

private:
    void _Parse();
    TokenInfoArray m_TokenInfos;
    StateArray m_StateStack;
    friend void IwTextParserAssertCallback(char* pBuffer);
};
# 21 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h" 2
# 41 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
class CIwParseable;
class CIwTextParserITX;
# 65 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
class CIwTextParserITX : public CIwTextParser
{
public:




    typedef CIwString<40> Field;




    typedef CIwArray<Field> FieldArray;




    typedef FieldArray::iterator FieldArrayIt;




    CIwTextParserITX();




    ~CIwTextParserITX();
# 102 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    virtual void* ParseFile(const char* pPathname, bool allowNonExist = false);
# 116 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void SkipScope();
# 139 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    inline void SetAssertOnUnrecognisedTokens(bool as)
    {
        m_AssertOnUnrecognisedTokens = as;
    }
# 154 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadString(char* pBuffer, uint32 buffSize, bool checkValid = true);
# 163 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadString(CIwStringS& string, bool checkValid = true) { ReadString((char*)string.c_str(), 32, checkValid); }
# 172 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadString(CIwStringL& string, bool checkValid = true) { ReadString((char*)string.c_str(), 160, checkValid); }
# 182 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    char* ReadString(bool checkValid = true);
# 191 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void PeekString(char* pString, int32 len, bool checkValid = true);
# 200 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadStringHash(uint32* pValue);
# 211 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadScope(char* pBuffer, uint32 buffSize);
# 221 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadLine(char* pBuffer, uint32 buffSize);
# 230 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    static void FieldStripQuotes(Field& f);
# 241 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    static void FilterString(const char*& pChar, FieldArray& fields, const char* fieldBreaks, const char* stringBreaks);
# 252 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    static uint32 FilterStringGetFlags(const char* pChar, const char** ppNames);
# 264 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringSetFlags(const char* pChar, const char** ppNames, uint32& flags);
# 276 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringResetFlags(const char* pChar, const char** ppNames, uint32& flags);
# 287 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringGetEnum(const char* pChar, const char** ppNames, uint32& value);
# 298 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    static bool FilterStringGetEnumAsserted(const char* pChar, const char** ppNames, uint32& value);
# 307 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadInt32(int32* pValue);
# 316 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadUInt32(uint32* pValue);
# 325 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadInt16(int16* pValue);
# 334 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadUInt16(uint16* pValue);
# 343 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadInt8(int8* pValue);
# 352 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadUInt8(uint8* pValue);
# 361 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadBool(bool* pValue);

    enum IntType
    {
        S_8 = 0,
        U_8,
        S_16,
        U_16,
        S_32,
        U_32
    };
# 382 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadInt32Array(int32* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, S_32);}
# 393 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadUInt32Array(uint32* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, U_32);}
# 404 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadInt16Array(int16* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, S_16);}
# 415 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadUInt16Array(uint16* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, U_16);}
# 426 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadInt8Array(int8* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, S_8);}
# 437 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    inline void ReadUInt8Array(uint8* pValue, uint32 maxVals) {ReadIntArray(pValue, maxVals, U_8);}
# 446 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadFloat(float* pValue);
# 455 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadDouble(double* pValue);
# 466 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadFloatArray(float* pValue, uint32 maxVals);
# 477 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadDoubleArray(double* pValue, uint32 maxVals);
# 488 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadFixed(iwfixed* pValue, uint32 shift = 12);
# 500 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadFixedArray(iwfixed* pValue, uint32 maxVals, uint32 shift = 12);






    void ReadAngleRadians(iwangle* pValue);
# 516 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadAngleDegrees(iwangle* pValue);
# 525 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    CIwManaged* GetObject(int32 level = 0);







    void PushObject(CIwManaged* pObject);







    CIwManaged* PopObject();
# 553 "d:/marmalade/6.1/modules/iwutil/h/IwTextParserITX.h"
    void ReadManagedReference(CIwManaged** pPointer);






    inline void StoreObject(CIwManaged* pObject)
    {
        m_NamedObjects.push_back(pObject);
    }


    void ResolveReferences();

private:

    class CIwReference
    {
    public:
        CIwReference() : m_pPointer(__null), m_Hash(0) {};
        CIwManaged** m_pPointer;
        uint32 m_Hash;





    };

    void ReadIntArray(void *pValue, uint32 maxVals, IntType type);


    CIwManaged* ForceCurrentObject(CIwManaged* pObj);

    char m_String[0x100];
    CIwArray<CIwManaged*> m_ObjectStack;
    CIwArray<CIwManaged*> m_NamedObjects;
    CIwArray<CIwReference> m_UnresolvedReferences;
    bool m_AssertOnUnrecognisedTokens;

    friend class CIwManaged;
    friend void _ITXReadUnknown(CIwTextParser* _pParser);
};

extern CIwTextParserITX* g_IwTextParserITX;




inline CIwTextParserITX* IwGetTextParserITX()
{

    if( !g_IwTextParserITX )
        do { IwDebugErrorShow ("To use the text parser in non-resource-building builds you must explicitly instantiate it using \"new CIwTextParserITX();\"") ; do {if (s3eDebugIsDebuggerPresent()) *(int*)0xfffffff4 = 0; } while(0); } while(0);

    return g_IwTextParserITX;
}
# 35 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2


# 1 "d:/marmalade/6.1/modules/iwutil/h/IwUncopyable.h" 1
       
# 24 "d:/marmalade/6.1/modules/iwutil/h/IwUncopyable.h"
class CIwUncopyable
{
public:
    CIwUncopyable() {}

private:
    CIwUncopyable(const CIwUncopyable& rhs);
    CIwUncopyable& operator=(const CIwUncopyable& rhs);
};
# 38 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwUtilInitTerm.h" 1
       
# 33 "d:/marmalade/6.1/modules/iwutil/h/IwUtilInitTerm.h"
void IwUtilInit();







void IwUtilTerminate();
# 39 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2




# 1 "d:/marmalade/6.1/modules/iwutil/h/IwAutoFile.h" 1
# 43 "d:/marmalade/6.1/modules/iwutil/h/IwAutoFile.h"
class CIwAutoFile
{
    s3eFile* m_File;

public:




    CIwAutoFile(const char* filename, const char* mode = "rb")
    {
        m_File = s3eFileOpen(filename, mode);
    }





    CIwAutoFile(void* buffer, uint32 size)
    {
        m_File = s3eFileOpenFromMemory(buffer,size);
    }




    ~CIwAutoFile()
    {
        if (m_File)
            s3eFileClose(m_File);
        m_File = 0;
    }






    s3eFile* s3eFileGet()
    {
        return m_File;
    }





    operator s3eFile* ()
    {
        return m_File;
    }
};
# 44 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h" 1
# 35 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
class CIwBuffer
{
public:






    class ByteProxy
    {
        public:
            ByteProxy(CIwBuffer& buffer, uint32 index);
            ByteProxy& operator=(const ByteProxy& right);
            ByteProxy& operator=(uint8 b);
            operator uint8() const;
            operator uint8&();
            uint8* operator&();
            const uint8* operator&() const;

        private:
            CIwBuffer& buffer;
            uint32 index;

    };




    CIwBuffer();




    CIwBuffer(const void *newData, uint32 newLength);







    explicit CIwBuffer(const char *string);




    CIwBuffer(const CIwBuffer& that);




    const CIwBuffer& operator=(const CIwBuffer& right);




    virtual ~CIwBuffer();







    int32 SetData(const void* newData, uint32 newLength);






    int32 SetData(const char* string);







    int32 SetData(const CIwBuffer& that);






    void Dump(CIwBuffer& out, int start = 0, int end = -1);
# 134 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    void SetDataNoCopy(void *newData, uint32 newLength);
# 145 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    void SetDataNoOwn(void* newData, uint32 newLength);
    void SetDataNoOwn(void* newData, uint32 newLength, uint32 maxLength);
# 155 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    void SetDataResizableNoOwn(void* newData, uint32 newLength, uint32 maxLength);





    void Move(CIwBuffer& buffer);






    void SetEmpty();






    int32 SetValue(const uint8 b, uint32 length);
# 185 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    s3eResult Resize(uint32 newLength);






    void ResizeMax();
# 202 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    s3eResult TrimBack(uint32 bytesToTrim);
# 211 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    s3eResult HintLength(uint32 hintedSize);

    void DontFree();

    void UseIntegerCompression(bool compress);
# 227 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    const uint8* GetData() const;
    const uint8* ptr() const { return GetData(); }
    uint8* GetDataWritable() { return (uint8*)GetData();};







    uint32 GetLength() const { return m_DataLength; }
    uint32 size() const { return GetLength(); }




    const ByteProxy operator[](uint32 index) const;




    ByteProxy operator[](uint32 index);
# 259 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    s3eResult Overlay(uint32 destIndex, const void* src, uint32 length);




    CIwBuffer& operator+=(const CIwBuffer& that);

    bool operator==(const CIwBuffer& that) const;
    bool operator!=(const CIwBuffer& that) const { return !(*this == that);};

    friend class ByteProxy;







    CIwBuffer Slice(uint32 start, uint32 len);
# 287 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    CIwBuffer DestructiveSlice(uint32 start, uint32 len);
# 298 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    bool Unpack(uint64* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int64* number, uint32& offset, uint32 len=1) const;
    bool Unpack(uint32* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int32* number, uint32& offset, uint32 len=1) const;
    bool Unpack(uint16* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int16* number, uint32& offset, uint32 len=1) const;
    bool Unpack(uint8* number, uint32& offset, uint32 len=1) const;
    bool Unpack(int8* number, uint32& offset, uint32 len=1) const;
    bool Unpack(float* number, uint32& offset, uint32 len=1) const;
# 317 "d:/marmalade/6.1/modules/iwutil/h/IwBuffer.h"
    bool Unpack(CIwBuffer &bufffer, uint32 &offset, bool destructive=false);






    virtual s3eResult Pack(const void* data, uint32 length);






    virtual s3eResult Pack(const char*);






    virtual s3eResult Pack(float n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const float* n, uint32 num);






    virtual s3eResult Pack(int64 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int64* n, uint32 num) { return Pack((const uint64*)n, num); }






    virtual s3eResult Pack(int32 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int32* n, uint32 num) { return Pack((const uint32*)n, num); }






    virtual s3eResult Pack(int16 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int16* n, uint32 num) { return Pack((const uint16*)n, num); }






    virtual s3eResult Pack(int8 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const int8* n, uint32 num) { return Pack((const uint8*)n, num); }






    virtual s3eResult Pack(uint64 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint64* n, uint32 num);






    virtual s3eResult Pack(uint32 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint32* n, uint32 num);






    virtual s3eResult Pack(uint16 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint16* n, uint32 num);






    virtual s3eResult Pack(uint8 n) { return Pack(&n, 1); }
    virtual s3eResult Pack(const uint8* n, uint32 num);






    virtual s3eResult Pack(bool b) { return Pack((uint8) b); }







    virtual s3eResult Pack(const CIwBuffer &);

    s3eResult PackSize(uint32 size);

    s3eResult PackNumber(uint32 num, bool reverse=false);

    s3eResult UnpackNumber(uint32& num, uint32& offset, bool reverse=false) const;

    s3eResult Append(const uint8* data, int len);

    uint32 Flags() { return m_Flags; }

protected:
    void CopyIfNeeded();

    static int PackUint64 (uint64 n, uint8* to, bool bendian=false);
    static int PackUint32 (uint32 n, uint8* to, bool bendian=false);
    static int PackUint16 (uint16 n, uint8* to, bool bendian=false);
    static int PackUint8 (uint8 n, uint8* to, bool bendian=false);
    static int UnpackUint64(uint64* n, const uint8* from, bool bendian=false);
    static int UnpackUint32(uint32* n, const uint8* from, bool bendian=false);
    static int UnpackUint16(uint16* n, const uint8* from, bool bendian=false);
    static int UnpackUint8 (uint8* n, const uint8* from, bool bendian=false);

    virtual uint8* Alloc(uint32 size);
    virtual void Free(uint8* ptr);
private:
    uint32& GetRefCount() const;
    int32& GetOffsetWord() const;
    void DeleteData();

protected:
    uint8* m_Data;
    uint32 m_DataLength;
    uint32 m_ActualLength;
    uint32 m_Flags;
};




CIwBuffer operator+(const CIwBuffer& left, const CIwBuffer& right);
# 45 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2

# 1 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h" 1
# 38 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
extern "C" {
# 52 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
char* IwPathGetExtension(const char* filename, char* pExt);
# 66 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
char* IwPathGetFilename(const char* filename, char* leaf, s3eBool withExt =(1));
# 81 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
char* IwPathGetDirname(const char* filename, char* path);
# 91 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
char* IwPathGetDrive(const char* filename, char *drive);






s3eBool IwPathHasDrive(const char* filename);
# 108 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
char* IwPathStripDrive(char *filename);
# 120 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
char* IwPathJoin(char* path, const char* file, int len =128);
# 130 "d:/marmalade/6.1/modules/iwutil/h/IwPath.h"
char* IwPathNorm(char* path, s3eBool useCase = (0));

}
# 47 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 1 "d:/marmalade/6.1/modules/iwutil/h/IwList.h" 1
# 52 "d:/marmalade/6.1/modules/iwutil/h/IwList.h"
class CIwListNode
{
public:
    CIwListNode* m_Prev;
    CIwListNode* m_Next;
    inline CIwListNode() { Init(); }
    virtual ~CIwListNode() {};
    inline void Init() { m_Prev = m_Next = this; }
};






void IwListAddNode(CIwListNode* pRoot, CIwListNode* pNode);






void IwListRemoveNode(CIwListNode* pRoot, CIwListNode* pNode);
# 88 "d:/marmalade/6.1/modules/iwutil/h/IwList.h"
static inline void IwListAddNodeEnd(CIwListNode* pRoot, CIwListNode* pNode)
{
    ((void)0);
    ((void)0);
    pNode->m_Next = pRoot;
    pNode->m_Prev = pRoot->m_Prev;
    pNode->m_Prev->m_Next = pNode;
    pRoot->m_Prev = pNode;
}







static inline bool IwListEmpty(CIwListNode* pRoot)
{
    return pRoot->m_Next == pRoot;
}
# 128 "d:/marmalade/6.1/modules/iwutil/h/IwList.h"
typedef CIwListNode IwListNode;





template<class X>
class CIwList
{
public:
    uint32 num_p;






    class Store
    {
    public:
        Store(X const& _el) : el(_el), next(0),prev(0) {}
        X el;
        Store* next;
        Store* prev;
    } *head, *last;

    class iterator
    {
    public:
        iterator(Store* _st) : st(_st) {}
        X* operator->() {return &st->el;}
        X& operator*() {return st->el;}
        iterator& operator++() {((void)0); st = st->next; return *this;}
        iterator operator++(int) {((void)0); iterator tp = *this; st = st->next; return tp;}
        iterator& operator--() {((void)0); st = st->prev; return *this;}
        iterator operator--(int) {((void)0); iterator tp = *this; st = st->prev; return tp;}
        bool operator==(const iterator& r) const
        {
            return (st == r.st);
        }
        bool operator!=(const iterator& r) const
            {
            return (st != r.st);
            }
        Store* st;
    };


    CIwList () : num_p(0), head(0), last(0) {}
    ~CIwList () {clear();}





    void clear()
    {
        iterator i = begin();
        while (i != end())
            i=erase(i);
    }

    int size() const
    {
        return num_p;
    }
# 202 "d:/marmalade/6.1/modules/iwutil/h/IwList.h"
    void push_back(X const& x)
    {
        if (!head) {
            ((void)0);
            head = last = new Store(x);
        }
        else {
            last->next = new Store(x);
            last->next->prev = last;
            last = last->next;
        }
        num_p++;
    }
# 223 "d:/marmalade/6.1/modules/iwutil/h/IwList.h"
    void append(X const & x) { push_back(x); }






    iterator erase(const iterator& it)
    {
        if (it.st->prev)
            it.st->prev->next = it.st->next;
        else {
            ((void)0);
            head = it.st->next;
        }
        if (it.st->next)
            it.st->next->prev = it.st->prev;
        else {
            last = it.st->prev;
        }
        iterator ret = ++iterator(it.st);
        delete it.st;
        num_p--;
        return ret;
    }






    iterator erase(X* el)
    {
        iterator it((Store*) el);
        return erase(it);
    }






    bool find_and_remove(X& el)
    {
        Store* st = head;
        while (st)
        {
            if (st->el == el) {
                erase(st);
                return true;
            }
            st=st->next;
        }
        return false;
    }






    iterator begin() {return iterator(head);}






    iterator end() {return iterator(__null);}






    X& element_at(int idx)
    {
        ((void)0);
        Store* s = head;
        while (idx--)
        {
            ((void)0);
            s = s->next;
        }
        ((void)0);
        return s->el;
    }




    X & front()
    {
        ((void)0);
        return head->el;
    }




    X & back()
    {
        ((void)0);
        return last->el;
    }

};
# 48 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2


# 1 "d:/marmalade/6.1/modules/iwutil/h/IwRandom.h" 1
# 23 "d:/marmalade/6.1/modules/iwutil/h/IwRandom.h"
extern "C" {
# 48 "d:/marmalade/6.1/modules/iwutil/h/IwRandom.h"
void IwRandSeed(int32 seed);
# 57 "d:/marmalade/6.1/modules/iwutil/h/IwRandom.h"
int32 IwRand();
# 71 "d:/marmalade/6.1/modules/iwutil/h/IwRandom.h"
static inline int32 IwRandRange(int range) { if (!range) return 0; return IwRand() % range; }
# 82 "d:/marmalade/6.1/modules/iwutil/h/IwRandom.h"
static inline int32 IwRandMinMax(int min, int max) { return IwRandRange(max-min) + min; }


}
# 51 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2



# 1 "d:/marmalade/6.1/modules/iwutil/h/IwUTF8.h" 1
# 43 "d:/marmalade/6.1/modules/iwutil/h/IwUTF8.h"
typedef unsigned short ucs2char;
# 85 "d:/marmalade/6.1/modules/iwutil/h/IwUTF8.h"
int IwWideCharToUTF8( const ucs2char * wideString,
                        int wideStringLength,
                        char * utf8Buffer,
                        unsigned int utf8BufferSize );
# 125 "d:/marmalade/6.1/modules/iwutil/h/IwUTF8.h"
int IwUTF8ToWideChar( const char * utf8String,
                        int utf8StringSize,
                        ucs2char * wideBuffer,
                        unsigned int wideBufferSize );
# 55 "d:/marmalade/6.1/modules/iwutil/h/IwUtil.h" 2
# 24 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h" 2
# 37 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
class CIwMaterial;




class CIw2DImage
{
public:






    virtual int16 GetWidth() = 0;







    virtual int16 GetHeight() = 0;







    virtual CIwMaterial* GetMaterial() = 0;

    virtual ~CIw2DImage() {};
};




class CIw2DFont
{
public:






    virtual int32 GetHeight() = 0;

    virtual ~CIw2DFont() {};
};




class CIw2DSurface
{
public:
    virtual ~CIw2DSurface() {};
};
# 118 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetColour(CIwColour colour);
# 132 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetColour(uint32 colour);
# 141 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIwColour Iw2DGetColour();






enum CIw2DImageTransform
{
        IW_2D_IMAGE_TRANSFORM_NONE,
        IW_2D_IMAGE_TRANSFORM_ROT90 = ((1 << 0) | (1 << 2)),
        IW_2D_IMAGE_TRANSFORM_ROT180 = ((1 << 0) | (1 << 1)),
        IW_2D_IMAGE_TRANSFORM_ROT270 = ((1 << 1) | (1 << 2)),
        IW_2D_IMAGE_TRANSFORM_FLIP_X = ((1 << 0)),
        IW_2D_IMAGE_TRANSFORM_FLIP_Y = ((1 << 1)),
};
# 168 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DImageTransform Iw2DImageTransformOp(CIw2DImageTransform state, CIw2DImageTransform operation);
# 177 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetImageTransform(CIw2DImageTransform trans);
# 186 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DImageTransform Iw2DGetImageTransform();
# 197 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetFont(CIw2DFont* font);
# 206 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DFont* Iw2DGetFont();
# 219 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
bool Iw2DSetSurface(CIw2DSurface* surface);







CIw2DSurface* Iw2DGetSurface();


enum CIw2DAlphaMode
{
    IW_2D_ALPHA_NONE,
    IW_2D_ALPHA_HALF,
    IW_2D_ALPHA_ADD,
    IW_2D_ALPHA_SUB,
};
# 246 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetAlphaMode(CIw2DAlphaMode mode);
# 255 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DAlphaMode Iw2DGetAlphaMode();
# 266 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetTransformMatrix(const CIwMat2D& matrix);
# 275 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIwMat2D Iw2DGetTransformMatrix();
# 285 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetTransformMatrixSubPixel(const CIwMat2D& matrix);
# 295 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIwMat2D Iw2DGetTransformMatrixSubPixel();







void Iw2DSetSubPixelCoords(bool subPixel);






bool Iw2DGetSubPixelCoords();
# 322 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetUseMipMapping(bool mipmapping);






bool Iw2DGetUseMipMapping();
# 345 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
typedef void (*CIw2DPostTransformFn)(CIwSVec2* pPoints, CIwColour* pCols, int32 numberPoints);
# 358 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DSetPostTransformFn(CIw2DPostTransformFn fn);
# 367 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DPostTransformFn Iw2DGetPostTransformFn();
# 395 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawArc(CIwSVec2 centre, CIwSVec2 size, iwangle start, iwangle end, int32 numberSegments = 0);
# 405 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawLine(CIwSVec2 start, CIwSVec2 end);
# 416 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawPolygon(CIwSVec2* verts, int32 numberVerts, bool closed);
# 426 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawRect(CIwSVec2 topLeft, CIwSVec2 size);
# 439 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DFillArc(CIwSVec2 centre, CIwSVec2 size, iwangle start, iwangle end, int32 numberSegments = 0);
# 449 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DFillPolygon(CIwSVec2* verts, int32 numberVerts);
# 459 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DFillRect(CIwSVec2 topLeft, CIwSVec2 size);
# 482 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImage(const char* filename);
# 492 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImageResource(const char* resource);
# 503 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImageResource(uint32 resourceHash);
# 513 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImage(CIwImage& image);
# 524 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DImage* Iw2DCreateImage(CIw2DSurface* surface);
# 535 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImage(CIw2DImage* image, CIwSVec2 topLeft);
# 547 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImage(CIw2DImage* image, CIwSVec2 topLeft, CIwSVec2 size);
# 559 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImageRegion(CIw2DImage* image, CIwSVec2 topLeft, CIwSVec2 regionOffset, CIwSVec2 regionSize);
# 573 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImageRegion(CIw2DImage* image, CIwSVec2 topLeft, CIwSVec2 size, CIwSVec2 regionOffset, CIwSVec2 regionSize);
# 589 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawImageStretch(CIw2DImage* image, CIwSVec2* areas, CIwSVec2* regions);
# 614 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DFont* Iw2DCreateFontResource(const char* resource);
# 627 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DFont* Iw2DCreateFont(const char* filename);


enum CIw2DFontAlign
{
    IW_2D_FONT_ALIGN_TOP,
    IW_2D_FONT_ALIGN_LEFT = IW_2D_FONT_ALIGN_TOP,
    IW_2D_FONT_ALIGN_CENTRE,
    IW_2D_FONT_ALIGN_BOTTOM,
    IW_2D_FONT_ALIGN_RIGHT = IW_2D_FONT_ALIGN_BOTTOM,
};
# 650 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawString(const char* string, CIwSVec2 topLeft, CIwSVec2 size, CIw2DFontAlign horzAlign, CIw2DFontAlign vertAlign);
# 663 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DDrawString(uint16* string, CIwSVec2 topLeft, CIwSVec2 size, CIw2DFontAlign horzAlign, CIw2DFontAlign vertAlign);
# 673 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
int32 Iw2DGetStringWidth(const char* string);
# 683 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
int32 Iw2DGetStringWidth(uint16* string);
# 699 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DInit();







void Iw2DTerminate();






void Iw2DFinishDrawing();







void Iw2DSurfaceShow();







void Iw2DSurfaceClear(CIwColour c);
void Iw2DSurfaceClear(uint32 c);
# 740 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
void Iw2DGetSurfaceInfo(s3eSurfaceInfo& outInfo);







int32 Iw2DGetSurfaceWidth();







int32 Iw2DGetSurfaceHeight();
# 767 "d:/marmalade/6.1/modules/iw2d/h/Iw2D.h"
CIw2DSurface* Iw2DCreateSurface(int32 w, int32 h);
# 3 "c:/Users/dreambit/Documents/memorygame/src/main.cpp" 2
# 1 "c:/Users/dreambit/Documents/memorygame/h/game.h" 1



class GameCondition
{
public:
 GameCondition();
 GameCondition(uint32 complexity);
 uint32 complexity;
 uint32 timeleft;
 uint32 points;
 CIwSVec2 *resolution;
};





class IGameElement
{
public:
 virtual void Draw() = 0;
 virtual void Update() = 0;
 virtual void Init(GameCondition gameCondition){};
};


class Sprite : public IGameElement
{
public:
 Sprite(char *src);
 ~Sprite();
 virtual void Draw();
 virtual void Update();
 CIw2DImage *image;
 CIwSVec2 *position;
 CIwSVec2 *size;
};
# 51 "c:/Users/dreambit/Documents/memorygame/h/game.h"
class SecretBox : public Sprite
{
public:
 SecretBox();
 ~SecretBox();
};


class SecretBoxArea : public IGameElement
{
public:
 SecretBoxArea();
 ~SecretBoxArea();
 void Draw();
 void Update();
 void Init(GameCondition gameCondition);
private:
 CIwArray<SecretBox*> secretboxes;
 uint32 boxescount;
 CIwSVec2* boxSize;
 CIwSVec2* getBoxSize(CIwSVec2* resolution, uint32 boxCount);
};




class Game
{
public:
    Game();
    ~Game();
    void Update();
    void Render();
 void NewGame();
private:
 GameCondition gameCondition;
 SecretBoxArea secretBoxArea;
 Sprite* backGround;
};
# 4 "c:/Users/dreambit/Documents/memorygame/src/main.cpp" 2

int main()
{
    Iw2DInit();
    Game* game = new Game();
 game->NewGame();
    while(!s3eDeviceCheckQuitRequest())
    {
  Iw2DSurfaceClear(0xff000000);
  game->Render();
  Iw2DSurfaceShow();
        s3ePointerUpdate();
        s3eKeyboardUpdate();
        s3eDeviceYield();
    }

    delete game;

    Iw2DTerminate();

    return 0;
}
